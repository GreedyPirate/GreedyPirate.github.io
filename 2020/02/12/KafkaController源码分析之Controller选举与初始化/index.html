<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="KafkaController源码分析之Controller选举与初始化"><meta name="keywords" content="kafka,中间件,消息"><meta name="author" content="紫夜,undefined"><meta name="copyright" content="紫夜"><title>KafkaController源码分析之Controller选举与初始化 | 紫夜の博客</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6ba54465c1ff0c31b169e7a89d3dbe37";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#KafkaController"><span class="toc-number">1.</span> <span class="toc-text">KafkaController</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KafkaController启动"><span class="toc-number">2.</span> <span class="toc-text">KafkaController启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KafkaController选举"><span class="toc-number">3.</span> <span class="toc-text">KafkaController选举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KafkaController初始化"><span class="toc-number">4.</span> <span class="toc-text">KafkaController初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#controller-epoch"><span class="toc-number">4.1.</span> <span class="toc-text">controller.epoch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册节点监听器"><span class="toc-number">4.2.</span> <span class="toc-text">注册节点监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化ControllerContext"><span class="toc-number">4.3.</span> <span class="toc-text">初始化ControllerContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initializeControllerContext"><span class="toc-number">4.3.1.</span> <span class="toc-text">initializeControllerContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分区改变事件处理器"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">分区改变事件处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化分区副本分配关系"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">初始化分区副本分配关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分区leader缓存与分区reassign"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">分区leader缓存与分区reassign</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#topic删除管理器"><span class="toc-number">4.3.2.</span> <span class="toc-text">topic删除管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#副本状态机与分区状态机的启动"><span class="toc-number">4.3.3.</span> <span class="toc-text">副本状态机与分区状态机的启动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ae01.alicdn.com/kf/He0f82cbc452e4e99b7da670575752df0l.png"></div><div class="author-info__name text-center">紫夜</div><div class="author-info__description text-center">stay hungry, stay foolish</div><div class="follow-button"><a href="https://github.com/GreedyPirate" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/yj7758423" target="_blank">我的CSDN</a><a class="author-info-links__name text-center" href="https://segmentfault.com/blog/code-craft" target="_blank">膜拜大神</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ae01.alicdn.com/kf/H6e9ae455bca04f4098243e3f73a85c4fb.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">紫夜の博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">KafkaController源码分析之Controller选举与初始化</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Kafka-Tutorial/">Kafka Tutorial</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,951</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文来分析下kafka的重要模块——Controller，主要介绍Controller的选举与初始化过程</p>
<h1 id="KafkaController"><a href="#KafkaController" class="headerlink" title="KafkaController"></a>KafkaController</h1><p>初始化的入口依然在KafkaServer#startup方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建BrokerInfo: &#123;Broker&#123;id,EndPoint,rack&#125;, apiversion, jmxport&#125;</span></span><br><span class="line">val brokerInfo = createBrokerInfo </span><br><span class="line"><span class="comment">// zk中注册 /brokers/ids/0 节点</span></span><br><span class="line">zkClient.registerBrokerInZk(brokerInfo)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start kafka controller */</span></span><br><span class="line">kafkaController = <span class="keyword">new</span> KafkaController(config, zkClient, time, metrics, brokerInfo, tokenManager, threadNamePrefix)</span><br><span class="line">kafkaController.startup()</span><br></pre></td></tr></table></figure></p>
<p>在讲解KafkaController#startup之前，需要说明下KafkaController中有很多成员变量，主要分为</p>
<ol>
<li>zk事件处理器(ZNodeChangeHandler，ZNodeChildChangeHandler)</li>
<li>StateMachine(有限状态机): 副本的状态机，分区的状态机，主要负责状态的维护及转换时的处理</li>
<li>ControllerContext：broker，topic，partition，replica相关的数据缓存</li>
<li>ControllerEventManager: zk事件管理器，详见<a href="">Zookeeper初始化与Watcher监听事件分发</a></li>
</ol>
<h1 id="KafkaController启动"><a href="#KafkaController启动" class="headerlink" title="KafkaController启动"></a>KafkaController启动</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">startup</span><span class="params">()</span> </span>= &#123;</span><br><span class="line">	<span class="comment">// StateChangeHandler用于处理ZooKeeper AuthFailed事件，Zookeeper初始化与Watcher监听事件分发一文有提到</span></span><br><span class="line">	zkClient.registerStateChangeHandler(<span class="keyword">new</span> StateChangeHandler &#123;</span><br><span class="line">		<span class="comment">// 非核心...</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// Startup是一个ControllerEvent，ControllerEventThread会执行它的process方法</span></span><br><span class="line">	eventManager.put(Startup)</span><br><span class="line">	<span class="comment">// 启动了ControllerEventManager</span></span><br><span class="line">	eventManager.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Startup类定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> object Startup extends ControllerEvent &#123;</span><br><span class="line">    def state = ControllerState.ControllerChange</span><br><span class="line"></span><br><span class="line">    <span class="function">override def <span class="title">process</span><span class="params">()</span>: Unit </span>= &#123;</span><br><span class="line">      <span class="comment">// 如方法名所示：注册监听/controller节点的handler, 并检查/controller节点是否存在</span></span><br><span class="line">      zkClient.registerZNodeChangeHandlerAndCheckExistence(controllerChangeHandler)</span><br><span class="line">      <span class="comment">// Controller选举</span></span><br><span class="line">      elect()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注册的ControllerChangeHandler主要监听/controller节点的创建，删除，以及数据改变事件，此处暂且不深入研究</p>
<h1 id="KafkaController选举"><a href="#KafkaController选举" class="headerlink" title="KafkaController选举"></a>KafkaController选举</h1><p>接下来的elect方法是关于Controller选举的核心方法，前文说过，选举很简单，负责的是里面各种变量的初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">elect</span><span class="params">()</span>: Unit </span>= &#123;</span><br><span class="line">    val timestamp = time.milliseconds</span><br><span class="line">    <span class="comment">// 获取zk /controller节点中的ControllerId，没有返回-1</span></span><br><span class="line">    activeControllerId = zkClient.getControllerId.getOrElse(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ControllerId=-1，表示当前broker已成为Controller，属于特殊场景下的防止死循环优化</span></span><br><span class="line">    <span class="keyword">if</span> (activeControllerId != -<span class="number">1</span>) &#123;</span><br><span class="line">      debug(s<span class="string">"Broker $activeControllerId has been elected as the controller, so stopping the election process."</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试去创建/controller节点，如果创建失败了(已存在)，会在catch里处理NodeExistsException</span></span><br><span class="line">      zkClient.checkedEphemeralCreate(ControllerZNode.path, ControllerZNode.encode(config.brokerId, timestamp))</span><br><span class="line">      info(s<span class="string">"$&#123;config.brokerId&#125; successfully elected as the controller"</span>)</span><br><span class="line">      activeControllerId = config.brokerId</span><br><span class="line">      onControllerFailover()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _: NodeExistsException =&gt;</span><br><span class="line">        <span class="comment">// If someone else has written the path, then</span></span><br><span class="line">        activeControllerId = zkClient.getControllerId.getOrElse(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果/controller已存在， brokerid就不会是-1</span></span><br><span class="line">        <span class="comment">// &#123;"version":1,"brokerid":0,"timestamp":"1582610063256"&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (activeControllerId != -<span class="number">1</span>)</span><br><span class="line">          debug(s<span class="string">"Broker $activeControllerId was elected as controller instead of broker $&#123;config.brokerId&#125;"</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 上一届controller刚下台，节点还没删除的情况</span></span><br><span class="line">          warn(<span class="string">"A controller has been elected but just resigned, this will result in another round of election"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> e2: Throwable =&gt;</span><br><span class="line">        error(s<span class="string">"Error while electing or becoming controller on broker $&#123;config.brokerId&#125;"</span>, e2)</span><br><span class="line">        triggerControllerMove()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个选举过程并不复杂，选举流程如下图所示<br><img src="https://ae01.alicdn.com/kf/H9597605bc9844f07abc7848ec538840cJ.png" alt="选举过程"></p>
<h1 id="KafkaController初始化"><a href="#KafkaController初始化" class="headerlink" title="KafkaController初始化"></a>KafkaController初始化</h1><p>真正复杂的是broker在成为Controller之后，在onControllerFailover方法中进行的一系列初始化动作<br>下面是源码，接下来是对onControllerFailover方法的分段讲解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">onControllerFailover</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Reading controller epoch from ZooKeeper"</span>)</span><br><span class="line">    readControllerEpochFromZooKeeper()</span><br><span class="line">    info(<span class="string">"Incrementing controller epoch in ZooKeeper"</span>)</span><br><span class="line">    incrementControllerEpoch()</span><br><span class="line">    info(<span class="string">"Registering handlers"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val childChangeHandlers = Seq(brokerChangeHandler, topicChangeHandler, topicDeletionHandler, logDirEventNotificationHandler,</span><br><span class="line">      isrChangeNotificationHandler)</span><br><span class="line">    childChangeHandlers.foreach(zkClient.registerZNodeChildChangeHandler)</span><br><span class="line">    val nodeChangeHandlers = Seq(preferredReplicaElectionHandler, partitionReassignmentHandler)</span><br><span class="line">    nodeChangeHandlers.foreach(zkClient.registerZNodeChangeHandlerAndCheckExistence)</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Deleting log dir event notifications"</span>)</span><br><span class="line">    zkClient.deleteLogDirEventNotifications()</span><br><span class="line">    info(<span class="string">"Deleting isr change notifications"</span>)</span><br><span class="line">    zkClient.deleteIsrChangeNotifications()</span><br><span class="line">    info(<span class="string">"Initializing controller context"</span>)</span><br><span class="line">    initializeControllerContext()</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Fetching topic deletions in progress"</span>)</span><br><span class="line">    val (topicsToBeDeleted, topicsIneligibleForDeletion) = fetchTopicDeletionsInProgress()</span><br><span class="line">    info(<span class="string">"Initializing topic deletion manager"</span>)</span><br><span class="line">    topicDeletionManager.init(topicsToBeDeleted, topicsIneligibleForDeletion)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to send UpdateMetadataRequest after the controller context is initialized and before the state machines</span></span><br><span class="line">    <span class="comment">// are started. The is because brokers need to receive the list of live brokers from UpdateMetadataRequest before</span></span><br><span class="line">    <span class="comment">// they can process the LeaderAndIsrRequests that are generated by replicaStateMachine.startup() and</span></span><br><span class="line">    <span class="comment">// partitionStateMachine.startup().</span></span><br><span class="line">    info(<span class="string">"Sending update metadata request"</span>)</span><br><span class="line">    sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq)</span><br><span class="line"></span><br><span class="line">    replicaStateMachine.startup()</span><br><span class="line">    partitionStateMachine.startup()</span><br><span class="line"></span><br><span class="line">    info(s<span class="string">"Ready to serve as the new controller with epoch $epoch"</span>)</span><br><span class="line"></span><br><span class="line">    maybeTriggerPartitionReassignment(controllerContext.partitionsBeingReassigned.keySet)</span><br><span class="line"></span><br><span class="line">    topicDeletionManager.tryTopicDeletion()</span><br><span class="line"></span><br><span class="line">    val pendingPreferredReplicaElections = fetchPendingPreferredReplicaElections()</span><br><span class="line">    onPreferredReplicaElection(pendingPreferredReplicaElections)</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Starting the controller scheduler"</span>)</span><br><span class="line">    kafkaScheduler.startup()</span><br><span class="line">    <span class="keyword">if</span> (config.autoLeaderRebalanceEnable) &#123;</span><br><span class="line">      scheduleAutoLeaderRebalanceTask(delay = <span class="number">5</span>, unit = TimeUnit.SECONDS)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config.tokenAuthEnabled) &#123;</span><br><span class="line">      info(<span class="string">"starting the token expiry check scheduler"</span>)</span><br><span class="line">      tokenCleanScheduler.startup()</span><br><span class="line">      tokenCleanScheduler.schedule(name = <span class="string">"delete-expired-tokens"</span>,</span><br><span class="line">        fun = tokenManager.expireTokens,</span><br><span class="line">        period = config.delegationTokenExpiryCheckIntervalMs,</span><br><span class="line">        unit = TimeUnit.MILLISECONDS)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="controller-epoch"><a href="#controller-epoch" class="headerlink" title="controller.epoch"></a>controller.epoch</h2><p>controller.epoch表示Controller的版本号，初始值为0，每次产生新的Controller都会自增1<br>它的作用类似乐观锁的版本号，在Controller操作zk相关节点时，需要用它来表示节点是被哪一个Controller更新的</p>
<p>以下是初始化Controller时，从zk中/controller_epoch节点读取epoch的值，加1设置回zk，并更新本地缓存中的epoch<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 这一段代码就是获取controller.epoch，并自增+1设置回zk</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">info(<span class="string">"Reading controller epoch from ZooKeeper"</span>)</span><br><span class="line"><span class="comment">// 获取/controller_epoch节点数据，初始化ControllerContext的epoch和epochZkVersion字段</span></span><br><span class="line">readControllerEpochFromZooKeeper()</span><br><span class="line">info(<span class="string">"Incrementing controller epoch in ZooKeeper"</span>)</span><br><span class="line">incrementControllerEpoch()</span><br><span class="line">info(<span class="string">"Registering handlers"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="注册节点监听器"><a href="#注册节点监听器" class="headerlink" title="注册节点监听器"></a>注册节点监听器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 注册一组childrenChangeHandler，在NodeChildrenChange事件触发后，会分发给这些handler</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// before reading source of truth from zookeeper, register the listeners to get broker/topic callbacks</span></span><br><span class="line">val childChangeHandlers = Seq(brokerChangeHandler, topicChangeHandler, topicDeletionHandler, logDirEventNotificationHandler,</span><br><span class="line">  isrChangeNotificationHandler)</span><br><span class="line">childChangeHandlers.foreach(zkClient.registerZNodeChildChangeHandler)</span><br><span class="line"><span class="comment">// 注册/admin/preferred_replica_election, /admin/reassign_partitions节点事件处理</span></span><br><span class="line"><span class="comment">// 也是注册，不过要检查节点是否存在(这里不对是否存在做处理，只是保证没有异常)</span></span><br><span class="line">val nodeChangeHandlers = Seq(preferredReplicaElectionHandler, partitionReassignmentHandler)</span><br><span class="line">nodeChangeHandlers.foreach(zkClient.registerZNodeChangeHandlerAndCheckExistence)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除节点：/log_dir_event_notification/log_dir_event_xxx，/isr_change_notification/isr_change_xxx节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">info(<span class="string">"Deleting log dir event notifications"</span>)</span><br><span class="line">zkClient.deleteLogDirEventNotifications()</span><br><span class="line">info(<span class="string">"Deleting isr change notifications"</span>)</span><br><span class="line">zkClient.deleteIsrChangeNotifications()</span><br></pre></td></tr></table></figure>
<p>这里注册了很多handler，先用一个表格大致介绍一下，后面会有详细讲解</p>
<table>
<thead>
<tr>
<th>handler</th>
<th>监听的zk节点</th>
<th>事件</th>
<th>ControllerEvent</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>brokerChangeHandler</td>
<td>/brokers/ids</td>
<td>childChange</td>
<td>BrokerChange</td>
<td></td>
</tr>
<tr>
<td>topicChangeHandler</td>
<td>/brokers/topics</td>
<td>childChange</td>
<td>TopicChange</td>
<td></td>
</tr>
<tr>
<td>topicDeletionHandler</td>
<td>/admin/delete_topics</td>
<td>childChange</td>
<td>TopicDeletion</td>
<td></td>
</tr>
<tr>
<td>logDirEventNotificationHandler</td>
<td>/log_dir_event_notification</td>
<td>childChange</td>
<td>LogDirEventNotification</td>
<td></td>
</tr>
<tr>
<td>isrChangeNotificationHandler</td>
<td>/isr_change_notification</td>
<td>childChange</td>
<td>IsrChangeNotification</td>
<td></td>
</tr>
<tr>
<td>partitionReassignmentHandler</td>
<td>/admin/reassign_partitions</td>
<td>create</td>
<td>PartitionReassignment</td>
<td>执行副本重分配</td>
</tr>
<tr>
<td>preferredReplicaElectionHandler</td>
<td>/admin/preferred_replica_election</td>
<td>create</td>
<td>PreferredReplicaLeaderElection</td>
<td>Preferred leader副本选举</td>
</tr>
</tbody>
</table>
<h2 id="初始化ControllerContext"><a href="#初始化ControllerContext" class="headerlink" title="初始化ControllerContext"></a>初始化ControllerContext</h2><p>首先需要说下ControllerContext是什么，以及它的功能</p>
<p>ControllerContext是zk中broker，topic，partition，replica等元数据的缓存对象，它主要有以下几个缓存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller epoch 在kafka中epoch就相当于乐观锁的version</span></span><br><span class="line">var epoch: Int = KafkaController.InitialControllerEpoch - <span class="number">1</span></span><br><span class="line"><span class="comment">// 这是zk自带的version，通用的用于更新节点数据</span></span><br><span class="line">var epochZkVersion: Int = KafkaController.InitialControllerEpochZkVersion - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map[Topic, Map[Partition, Seq[Replica]]] 存储每个topic的每个分区的副本集合</span></span><br><span class="line"><span class="keyword">private</span> var partitionReplicaAssignmentUnderlying: mutable.Map[String, mutable.Map[Int, Seq[Int]]] = mutable.Map.empty</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeaderIsrAndControllerEpoch: &#123;"controller_epoch":19,"leader":0,"version":1,"leader_epoch":57,"isr":[0,1,2]&#125;</span></span><br><span class="line">val partitionLeadershipInfo: mutable.Map[TopicPartition, LeaderIsrAndControllerEpoch] = mutable.Map.empty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备要重分配副本的分区</span></span><br><span class="line">val partitionsBeingReassigned: mutable.Map[TopicPartition, ReassignedPartitionsContext] = mutable.Map.empty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这要等到向Controller发送LeaderAndIsr请求之后，才能初始化，key是brokerId</span></span><br><span class="line">val replicasOnOfflineDirs: mutable.Map[Int, Set[TopicPartition]] = mutable.Map.empty</span><br><span class="line"></span><br><span class="line"><span class="comment">//存活的broker</span></span><br><span class="line"><span class="keyword">private</span> var liveBrokersUnderlying: Set[Broker] = Set.empty</span><br><span class="line"><span class="keyword">private</span> var liveBrokerIdsUnderlying: Set[Int] = Set.empty</span><br></pre></td></tr></table></figure></p>
<p>比较重要的几个变量是：</p>
<ol>
<li>partitionReplicaAssignmentUnderlying：表示topic-partition-replica之间的关系数据</li>
<li>partitionLeadershipInfo：每个分区对应的leader信息</li>
<li>LeaderIsr：表示分区的leader以及isr信息</li>
<li>LeaderIsrAndControllerEpoch：在LeaderIsr的基础上加上controller epoch，表示它是被哪一个Controller写入的</li>
<li>state节点：以test的第0个分区为例：/brokers/topics/test/partition/0/state中的样例数据为<br> {“controller_epoch”:19,”leader”:0,”version”:1,”leader_epoch”:57,”isr”:[0,1,2]}</li>
</ol>
<h3 id="initializeControllerContext"><a href="#initializeControllerContext" class="headerlink" title="initializeControllerContext"></a>initializeControllerContext</h3><p>controller选举的第三步——ControllerContext初始化，源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">initializeControllerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// update controller cache with delete topic information</span></span><br><span class="line">    <span class="comment">// 更新controllerContext缓存中的liveBrokers和allTopics信息</span></span><br><span class="line">    controllerContext.liveBrokers = zkClient.getAllBrokersInCluster.toSet  <span class="comment">// /brokers/ids 下所有的Broker信息（id，ip，port等）</span></span><br><span class="line">    controllerContext.allTopics = zkClient.getAllTopicsInCluster.toSet <span class="comment">// brokers/topics下所有的topic名</span></span><br><span class="line">    registerPartitionModificationsHandlers(controllerContext.allTopics.toSeq) <span class="comment">// 为allTopics中的每个topic注册监听处理器</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 通过allTopics获取Map[TopicPartition, Seq[Replica]]</span></span><br><span class="line"><span class="comment">      * 再讲该map保存到controllerContext的Map[Topic, Map[partition, Seq[replicas]]] partitionReplicaAssignmentUnderlying</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    zkClient.getReplicaAssignmentForTopics(controllerContext.allTopics.toSet).foreach &#123;</span><br><span class="line">      <span class="keyword">case</span> (topicPartition, assignedReplicas) =&gt; controllerContext.updatePartitionReplicaAssignment(topicPartition, assignedReplicas)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化partitionLeadershipInfo和shuttingDownBrokerIds</span></span><br><span class="line">    controllerContext.partitionLeadershipInfo.clear()</span><br><span class="line">    controllerContext.shuttingDownBrokerIds = mutable.Set.empty[Int]</span><br><span class="line">    <span class="comment">// register broker modifications handlers</span></span><br><span class="line">    <span class="comment">// 注册监听 /brokers/ids/0节点的handler，endpoint字段变化会更新liveBrokers缓存</span></span><br><span class="line">    registerBrokerModificationsHandler(controllerContext.liveBrokers.map(_.id))</span><br><span class="line">    <span class="comment">// update the leader and isr cache for all existing partitions from Zookeeper</span></span><br><span class="line">    <span class="comment">// 获取分区节点的数据，并缓存到controllerContext.partitionLeadershipInfo对象里</span></span><br><span class="line">    updateLeaderAndIsrCache()</span><br><span class="line">    <span class="comment">// start the channel manager</span></span><br><span class="line">    <span class="comment">// 启动ControllerChannelManager中处理ControllerEvent的RequestSendThread线程</span></span><br><span class="line">    <span class="comment">// Zookeeper初始化与Watcher监听事件分发中有详细介绍</span></span><br><span class="line">    startChannelManager()</span><br><span class="line">    <span class="comment">// 看有没有要分区重分配的操作，有就加到partitionsBeingReassigned缓存里</span></span><br><span class="line">    initializePartitionReassignment()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要是为了初始化ControllerContext的各个缓存，调用的方法也很多，下面选几个重要变量初始化的过程</p>
<h4 id="分区改变事件处理器"><a href="#分区改变事件处理器" class="headerlink" title="分区改变事件处理器"></a>分区改变事件处理器</h4><p>上面的registerPartitionModificationsHandlers为每一个topic新建了PartitionModificationsHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">registerPartitionModificationsHandlers</span><span class="params">(topics: Seq[String])</span> </span>= &#123;</span><br><span class="line">  <span class="comment">// 每一个topic新建处理器，并且添加到partitionModificationsHandlers</span></span><br><span class="line">  topics.foreach &#123; topic =&gt;</span><br><span class="line">    val partitionModificationsHandler = <span class="keyword">new</span> PartitionModificationsHandler(<span class="keyword">this</span>, eventManager, topic)</span><br><span class="line">    partitionModificationsHandlers.put(topic, partitionModificationsHandler)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册到zk watcher的NodeChangeHandler里</span></span><br><span class="line">  partitionModificationsHandlers.values.foreach(zkClient.registerZNodeChangeHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PartitionModificationsHandler主要处理/brokers/topics/topicxxx节点的数据改变事件，首先看一下该节点存储的样例数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"version"</span>:<span class="number">1</span>,<span class="attr">"partitions"</span>:&#123;<span class="attr">"4"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],<span class="attr">"5"</span>:[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>],<span class="attr">"1"</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],<span class="attr">"0"</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>],<span class="attr">"2"</span>:[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>],<span class="attr">"3"</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是topic每一个分区的副本映射</p>
<h4 id="初始化分区副本分配关系"><a href="#初始化分区副本分配关系" class="headerlink" title="初始化分区副本分配关系"></a>初始化分区副本分配关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkClient.getReplicaAssignmentForTopics(controllerContext.allTopics.toSet).foreach &#123;</span><br><span class="line">  <span class="keyword">case</span> (topicPartition, assignedReplicas) =&gt; controllerContext.updatePartitionReplicaAssignment(topicPartition, assignedReplicas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是在初始化ControllerContext的partitionReplicaAssignmentUnderlying缓存，它保存的是每个topic的每个分区的副本映射，因此它是一个嵌套map类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map[Topic, Map[Partition, Seq[Replica]]] partitionReplicaAssignmentUnderlying</span><br></pre></td></tr></table></figure></p>
<h4 id="分区leader缓存与分区reassign"><a href="#分区leader缓存与分区reassign" class="headerlink" title="分区leader缓存与分区reassign"></a>分区leader缓存与分区reassign</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">updateLeaderAndIsrCache</span><span class="params">(partitions: Seq[TopicPartition] = controllerContext.allPartitions.toSeq)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每个分区节点的数据对象 &#123;"controller_epoch":19,"leader":0,"version":1,"leader_epoch":57,"isr":[0,1,2]&#125;</span></span><br><span class="line">  val leaderIsrAndControllerEpochs = zkClient.getTopicPartitionStates(partitions)</span><br><span class="line">  leaderIsrAndControllerEpochs.foreach &#123; <span class="keyword">case</span> (partition, leaderIsrAndControllerEpoch) =&gt;</span><br><span class="line">    <span class="comment">// Map[TopicPartition, LeaderIsrAndControllerEpoch]</span></span><br><span class="line">    controllerContext.partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateLeaderAndIsrCache方法会遍历controllerContext.allPartitions，获取/brokers/topics/topicxxx/partitions/xxx/state节点的数据<br>该节点的样例数据如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"controller_epoch"</span>:<span class="number">19</span>,<span class="attr">"leader"</span>:<span class="number">0</span>,<span class="attr">"version"</span>:<span class="number">1</span>,<span class="attr">"leader_epoch"</span>:<span class="number">57</span>,<span class="attr">"isr"</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure></p>
<p>分区reassign即分区副本重分配，相关内容后续会说到，这里仅说初始化<br>从/admin/reassign_partitions(临时节点)获取重分配方案，并复制给controllerContext.partitionsBeingReassigned<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">initializePartitionReassignment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// read the partitions being reassigned from zookeeper path /admin/reassign_partitions</span></span><br><span class="line">  val partitionsBeingReassigned = zkClient.getPartitionReassignment</span><br><span class="line">  info(s<span class="string">"Partitions being reassigned: $partitionsBeingReassigned"</span>)</span><br><span class="line"></span><br><span class="line">  controllerContext.partitionsBeingReassigned ++= partitionsBeingReassigned.iterator.map &#123; <span class="keyword">case</span> (tp, newReplicas) =&gt;</span><br><span class="line">    val reassignIsrChangeHandler = <span class="keyword">new</span> PartitionReassignmentIsrChangeHandler(<span class="keyword">this</span>, eventManager, tp)</span><br><span class="line">    tp -&gt; <span class="keyword">new</span> ReassignedPartitionsContext(newReplicas, reassignIsrChangeHandler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="topic删除管理器"><a href="#topic删除管理器" class="headerlink" title="topic删除管理器"></a>topic删除管理器</h3><p>初始化ControllerContext之后，接下来是topicDeletionManager——topic删除管理器的初始化<br>注：topic删除只会在delete.topic.enable为true时才能进行，而且分阶段进行删除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要删除的topics和删除失败的topics</span></span><br><span class="line">info(<span class="string">"Fetching topic deletions in progress"</span>)</span><br><span class="line">val (topicsToBeDeleted, topicsIneligibleForDeletion) = fetchTopicDeletionsInProgress()</span><br><span class="line"><span class="comment">// 初始化topic删除管理器</span></span><br><span class="line">info(<span class="string">"Initializing topic deletion manager"</span>)</span><br><span class="line">topicDeletionManager.init(topicsToBeDeleted, topicsIneligibleForDeletion)</span><br></pre></td></tr></table></figure></p>
<p>fetchTopicDeletionsInProgress的源码分析如下，init方法比较简单，这里就不说了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">fetchTopicDeletionsInProgress</span><span class="params">()</span>: <span class="params">(Set[String], Set[String])</span> </span>= &#123;</span><br><span class="line">  <span class="comment">// 获取/admin/delete_topics 删除的topic</span></span><br><span class="line">  val topicsToBeDeleted = zkClient.getTopicDeletions.toSet</span><br><span class="line">  <span class="comment">// 存在不在线的副本的topic</span></span><br><span class="line">  val topicsWithOfflineReplicas = controllerContext.allTopics.filter &#123; topic =&gt; &#123;</span><br><span class="line">    val replicasForTopic = controllerContext.replicasForTopic(topic)</span><br><span class="line">    replicasForTopic.exists(r =&gt; !controllerContext.isReplicaOnline(r.replica, r.topicPartition))</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  <span class="comment">// 要reassign的topic</span></span><br><span class="line">  val topicsForWhichPartitionReassignmentIsInProgress = controllerContext.partitionsBeingReassigned.keySet.map(_.topic)</span><br><span class="line">  <span class="comment">// 求二者并集，即有副本不在线的，和要reassign副本的topic都不能删，标记为不能删除(Ineligible)</span></span><br><span class="line">  val topicsIneligibleForDeletion = topicsWithOfflineReplicas | topicsForWhichPartitionReassignmentIsInProgress</span><br><span class="line">  (topicsToBeDeleted, topicsIneligibleForDeletion)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We need to send UpdateMetadataRequest after the controller context is initialized and before the state machines</span></span><br><span class="line"><span class="comment">// are started. The is because brokers need to receive the list of live brokers from UpdateMetadataRequest before</span></span><br><span class="line"><span class="comment">// they can process the LeaderAndIsrRequests that are generated by replicaStateMachine.startup() and</span></span><br><span class="line"><span class="comment">// partitionStateMachine.startup().</span></span><br><span class="line"><span class="comment">// 在处理LeaderAndIsrRequest请求之前，先更新所有broker以及所有partition的元数据</span></span><br><span class="line">sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq)</span><br></pre></td></tr></table></figure></p>
<p>最后一行代码是为后面的副本状态机，分区状态机的启动做准备，将元数据同步给其它broker，让它们可以处理LeaderAndIsrRequest请求</p>
<h3 id="副本状态机与分区状态机的启动"><a href="#副本状态机与分区状态机的启动" class="headerlink" title="副本状态机与分区状态机的启动"></a>副本状态机与分区状态机的启动</h3><p>Controller初始化接下来的动作是启动副本状态机和分区状态机，二者都比较复杂，在另一篇文章中分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaStateMachine.startup()</span><br><span class="line">partitionStateMachine.startup()</span><br></pre></td></tr></table></figure></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Controller的初始化代码很多，后面的操作主要依赖于ControllerContext里的缓存以及与zk的交互，代码虽然很多，但却不难<br>后面的源码分析见以下文章列表</p>
<p><a href="">KafkaController源码分析之副本状态机与分区状态机的启动</a><br><a href="">KafkaController源码分析之分区重分配(PartitionReassignment)</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">紫夜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://greedypirate.github.io/2020/02/12/KafkaController源码分析之Controller选举与初始化/">https://greedypirate.github.io/2020/02/12/KafkaController源码分析之Controller选举与初始化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kafka/">kafka</a><a class="post-meta__tags" href="/tags/中间件/">中间件</a><a class="post-meta__tags" href="/tags/消息/">消息</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ae01.alicdn.com/kf/H50b5d4d79e454447974210dae2d054435.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ae01.alicdn.com/kf/H45f5b133580045879faaa5fcbe9b598fu.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b6532776de86c85" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/04/KafkaController源码分析之副本状态机与分区状态机的启动/"><i class="fa fa-chevron-left">  </i><span>KafkaController源码分析之副本状态机与分区状态机的启动</span></a></div><div class="next-post pull-right"><a href="/2020/02/06/kafka-server端源码分析之Zookeeper初始化与Watcher监听事件分发/"><span>kafka-server端源码分析之Zookeeper初始化与Watcher监听事件分发</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '0349a7a18b86f2a653e3',
  clientSecret: '567ba8cefbe2ecffbbc04e676652ae4b43e7f952',
  repo: 'GreedyPirate.github.io',
  owner: 'GreedyPirate',
  admin: 'GreedyPirate',
  id: md5(decodeURI(location.pathname)),
  language: ''
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 紫夜</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://GreedyPirate.github.io">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>