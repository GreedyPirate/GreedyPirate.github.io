<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="KafkaController源码分析之副本状态机与分区状态机的启动"><meta name="keywords" content="kafka,中间件,消息"><meta name="author" content="紫夜,undefined"><meta name="copyright" content="紫夜"><title>KafkaController源码分析之副本状态机与分区状态机的启动 | 紫夜の博客</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6ba54465c1ff0c31b169e7a89d3dbe37";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#副本状态机"><span class="toc-number">1.</span> <span class="toc-text">副本状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化副本状态缓存"><span class="toc-number">1.1.</span> <span class="toc-text">初始化副本状态缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分区状态机"><span class="toc-number">2.</span> <span class="toc-text">分区状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化分区状态缓存"><span class="toc-number">2.1.</span> <span class="toc-text">初始化分区状态缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分区leader选举"><span class="toc-number">2.2.</span> <span class="toc-text">分区leader选举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NewPartition状态的分区选举leader副本"><span class="toc-number">2.2.1.</span> <span class="toc-text">NewPartition状态的分区选举leader副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OfflinePartition-OnlinePartition状态的分区选举leader副本"><span class="toc-number">2.2.2.</span> <span class="toc-text">OfflinePartition/OnlinePartition状态的分区选举leader副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#leaderForOffline选举"><span class="toc-number">2.2.3.</span> <span class="toc-text">leaderForOffline选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选举算法"><span class="toc-number">2.2.4.</span> <span class="toc-text">选举算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">2.2.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ae01.alicdn.com/kf/He0f82cbc452e4e99b7da670575752df0l.png"></div><div class="author-info__name text-center">紫夜</div><div class="author-info__description text-center">stay hungry, stay foolish</div><div class="follow-button"><a href="https://github.com/GreedyPirate" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/yj7758423" target="_blank">我的CSDN</a><a class="author-info-links__name text-center" href="https://segmentfault.com/blog/code-craft" target="_blank">膜拜大神</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ae01.alicdn.com/kf/H6e9ae455bca04f4098243e3f73a85c4fb.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">紫夜の博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">KafkaController源码分析之副本状态机与分区状态机的启动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Kafka-Tutorial/">Kafka Tutorial</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3,963</span><span class="post-meta__separator">|</span><span>Reading time: 18 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文承接上篇<a href="">kafka-server端源码分析之Controller初始化</a>，继续讲解Controller初始化过程中副本状态机与分区状态机的启动</p>
<h1 id="副本状态机"><a href="#副本状态机" class="headerlink" title="副本状态机"></a>副本状态机</h1><p>kafka将副本分为7个状态，下图是状态之间的流转图</p>
<p><img src="https://ae01.alicdn.com/kf/H43a853d3980c475c9f6894950bb29e41v.png" alt="副本状态流转图"></p>
<p>副本状态用ReplicaState接口表示，需要说下validPreviousStates方法，它表示合法的开始状态，以NewReplica为例，它只能由NonExistentReplica状态转换而来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> object NewReplica extends ReplicaState &#123;</span><br><span class="line">  val state: Byte = <span class="number">1</span></span><br><span class="line">  val validPreviousStates: Set[ReplicaState] = Set(NonExistentReplica)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而状态之间的转换，必将涉及到大量的更新操作，ReplicaStateMachine#doHandleStateChanges方法统一处理了状态转换</p>
<p>回过头来说replicaStateMachine.startup()方法，它主要是将在线的副本转换为OnlineReplica状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这一步简单却很重要，初始化replicaState，它保存了每个副本的状态</span></span><br><span class="line">  <span class="comment">// 为之后handleStateChanges转变为OnlineReplica做准备</span></span><br><span class="line">  initializeReplicaState()</span><br><span class="line"></span><br><span class="line">  handleStateChanges(controllerContext.allLiveReplicas().toSeq, OnlineReplica)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化副本状态缓存"><a href="#初始化副本状态缓存" class="headerlink" title="初始化副本状态缓存"></a>初始化副本状态缓存</h2><p>首先看initializeReplicaState的初始化，只要理解了controllerContext没有什么难度<br>该方法主要初始化了一个replicaState缓存，记录了每一个副本的状态，根据是否在线分为OnlineReplica和ReplicaDeletionIneligible状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">initializeReplicaState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controllerContext.allPartitions.foreach &#123; partition =&gt;</span><br><span class="line">    val replicas = controllerContext.partitionReplicaAssignment(partition)</span><br><span class="line">    replicas.foreach &#123; replicaId =&gt;</span><br><span class="line">      val partitionAndReplica = PartitionAndReplica(partition, replicaId)</span><br><span class="line">      <span class="keyword">if</span> (controllerContext.isReplicaOnline(replicaId, partition))</span><br><span class="line">        replicaState.put(partitionAndReplica, OnlineReplica)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// mark replicas on dead brokers as failed for topic deletion, if they belong to a topic to be deleted.</span></span><br><span class="line">      <span class="comment">// This is required during controller failover since during controller failover a broker can go down,</span></span><br><span class="line">      <span class="comment">// so the replicas on that broker should be moved to ReplicaDeletionIneligible to be on the safer side.</span></span><br><span class="line">        replicaState.put(partitionAndReplica, ReplicaDeletionIneligible)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化replicaState之后，handleStateChanges将所有存活的副本转换为OnlineReplica，此时正常的副本就是从OnlineReplica -&gt; OnlineReplica<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">handleStateChanges</span><span class="params">(replicas: Seq[PartitionAndReplica], targetState: ReplicaState,</span></span></span><br><span class="line"><span class="function"><span class="params">                       callbacks: Callbacks = new Callbacks()</span>): Unit </span>= &#123;</span><br><span class="line">  <span class="keyword">if</span> (replicas.nonEmpty) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      controllerBrokerRequestBatch.newBatch()</span><br><span class="line">      replicas.groupBy(_.replica).map &#123; <span class="keyword">case</span> (replicaId, replicas) =&gt;</span><br><span class="line">        val partitions = replicas.map(_.topicPartition)</span><br><span class="line">        doHandleStateChanges(replicaId, partitions, targetState, callbacks)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 发送ControllerChannelManager中积攒的请求</span></span><br><span class="line">      controllerBrokerRequestBatch.sendRequestsToBrokers(controllerContext.epoch)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: Throwable =&gt; error(s<span class="string">"Error while moving some replicas to $targetState state"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>doHandleStateChanges用于处理副本状态转换，此时我们只关注targetState是OnlineReplica的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">doHandleStateChanges</span><span class="params">(replicaId: Int, partitions: Seq[TopicPartition], targetState: ReplicaState,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   callbacks: Callbacks)</span>: Unit </span>= &#123;</span><br><span class="line">  <span class="comment">// 这里又组成了Seq[PartitionAndReplica]</span></span><br><span class="line">  val replicas = partitions.map(partition =&gt; PartitionAndReplica(partition, replicaId))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看该副本的状态，不存在Update为NonExistentReplica</span></span><br><span class="line">  replicas.foreach(replica =&gt; replicaState.getOrElseUpdate(replica, NonExistentReplica))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isValidTransition: 对转换的开始状态做合法性校验，参考前面副本状态机的介绍</span></span><br><span class="line">  <span class="comment">// 注意这里的partition方法不是分区的意思，它是一个布尔分组器</span></span><br><span class="line">  <span class="comment">// validReplicas是转换合法的副本，invalidReplicas是非合法的</span></span><br><span class="line">  val (validReplicas, invalidReplicas) = replicas.partition(replica =&gt; isValidTransition(replica, targetState))</span><br><span class="line">  <span class="comment">// 不合法主要用日志记录异常</span></span><br><span class="line">  invalidReplicas.foreach(replica =&gt; logInvalidTransition(replica, targetState))</span><br><span class="line">  <span class="comment">// 初始化Controller时，targetState=OnlineReplica</span></span><br><span class="line">  <span class="comment">//validReplicas==&gt;Seq[PartitionAndReplica]</span></span><br><span class="line">  targetState match &#123;</span><br><span class="line">    <span class="keyword">case</span> OnlineReplica =&gt; <span class="comment">// previousState: NewReplica, OnlineReplica, OfflineReplica, ReplicaDeletionIneligible</span></span><br><span class="line">        validReplicas.foreach &#123; replica =&gt;</span><br><span class="line">          val partition = replica.topicPartition</span><br><span class="line">          replicaState(replica) match &#123; <span class="comment">// 这里获取的是副本的状态</span></span><br><span class="line">            <span class="keyword">case</span> NewReplica =&gt;</span><br><span class="line">              <span class="comment">// NewReplica-&gt;OnlineReplica，本地分区副本分配缓存里如果没有该副本，就更新进去</span></span><br><span class="line">              val assignment = controllerContext.partitionReplicaAssignment(partition) <span class="comment">// 从缓存中获取分区对应的副本集合</span></span><br><span class="line">              <span class="keyword">if</span> (!assignment.contains(replicaId)) &#123;</span><br><span class="line">                controllerContext.updatePartitionReplicaAssignment(partition, assignment :+ replicaId) </span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">case</span> _ =&gt;</span><br><span class="line">              controllerContext.partitionLeadershipInfo.get(partition) match &#123;</span><br><span class="line">                <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(leaderIsrAndControllerEpoch)</span> </span>=&gt;</span><br><span class="line">                  <span class="comment">// 发送LeaderAndIsr请求(放入等待队列)</span></span><br><span class="line">                  controllerBrokerRequestBatch.addLeaderAndIsrRequestForBrokers(Seq(replicaId),</span><br><span class="line">                    replica.topicPartition,</span><br><span class="line">                    leaderIsrAndControllerEpoch,</span><br><span class="line">                    controllerContext.partitionReplicaAssignment(partition), isNew = <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">case</span> None =&gt;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          logSuccessfulTransition(replicaId, partition, replicaState(replica), OnlineReplica)</span><br><span class="line">          replicaState.put(replica, OnlineReplica)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 省略其他状态的处理 ......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NewReplica, OnlineReplica, OfflineReplica, ReplicaDeletionIneligible状态都可以转换到OnlineReplica状态<br>NewReplica会检查本地缓存，没有就更新,而其他状态需要发送LeaderAndIsr请求同步broker之间的数据</p>
<p>至此副本状态机的启动结束了，LeaderAndIsr请求作为kafka最核心的一个请求会在后面单独的篇章解析。</p>
<h1 id="分区状态机"><a href="#分区状态机" class="headerlink" title="分区状态机"></a>分区状态机</h1><p>分区状态机相比于副本状态机而言，状态个数只有4个，但是涉及到副本leader选举，状态流转的复杂度高很多</p>
<p><img src="https://ae01.alicdn.com/kf/Hba4113a46e4248c6bf942b6b46374ca1i.png" alt="分区状态流转图"></p>
<p>PartitionStateMachine的startup方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化分区的state</span></span><br><span class="line">  initializePartitionState()</span><br><span class="line">  triggerOnlinePartitionStateChange()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化分区状态缓存"><a href="#初始化分区状态缓存" class="headerlink" title="初始化分区状态缓存"></a>初始化分区状态缓存</h2><p>和副本状态机类似，initializePartitionState也是用一个partitionState初始化每个分区的状态<br>将缓存中所有分区分为3种初始化状态</p>
<ol>
<li>有leader副本，并且在线，标记为OnlinePartition状态，不在线为OfflinePartition</li>
<li>没有leader标记分区为NewPartition状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">initializePartitionState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (topicPartition &lt;- controllerContext.allPartitions) &#123;</span><br><span class="line">    <span class="comment">// check if leader and isr path exists for partition. If not, then it is in NEW state</span></span><br><span class="line">    <span class="comment">// 获取leader和isr信息</span></span><br><span class="line">    controllerContext.partitionLeadershipInfo.get(topicPartition) match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(currentLeaderIsrAndEpoch)</span> </span>=&gt;</span><br><span class="line">        <span class="comment">// else, check if the leader for partition is alive. If yes, it is in Online state, else it is in Offline state</span></span><br><span class="line">        <span class="comment">// leader存活就是OnlinePartition状态的分区，否则就是OfflinePartition</span></span><br><span class="line">        <span class="keyword">if</span> (controllerContext.isReplicaOnline(currentLeaderIsrAndEpoch.leaderAndIsr.leader, topicPartition))</span><br><span class="line">        <span class="comment">// leader is alive</span></span><br><span class="line">          partitionState.put(topicPartition, OnlinePartition)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          partitionState.put(topicPartition, OfflinePartition)</span><br><span class="line">      <span class="keyword">case</span> None =&gt;</span><br><span class="line">        <span class="comment">// 没有leader为NewPartition状态</span></span><br><span class="line">        partitionState.put(topicPartition, NewPartition)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>初始化之后partitionState，分区状态机会把OfflinePartition和NewPartition的分区转换为OnlinePartition状态，<br>broker正常运行的情况下，分区都是OnlinePartition状态，此时handleStateChanges不会执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">triggerOnlinePartitionStateChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// try to move all partitions in NewPartition or OfflinePartition state to OnlinePartition state except partitions</span></span><br><span class="line">  <span class="comment">// that belong to topics to be deleted</span></span><br><span class="line">  <span class="comment">// 正常情况下partitionsToTrigger为空的，启动kafka时所有分区都是OnlinePartition</span></span><br><span class="line">  val partitionsToTrigger = partitionState.filter &#123; <span class="keyword">case</span> (partition, partitionState) =&gt;</span><br><span class="line">    !topicDeletionManager.isTopicQueuedUpForDeletion(partition.topic) &amp;&amp;</span><br><span class="line">      (partitionState.equals(OfflinePartition) || partitionState.equals(NewPartition))</span><br><span class="line">  &#125;.keys.toSeq</span><br><span class="line">  <span class="comment">// 把所有OfflinePartition，NewPartition和非准备删除的分区 转换为OnlinePartition</span></span><br><span class="line">  handleStateChanges(partitionsToTrigger, OnlinePartition, Option(OfflinePartitionLeaderElectionStrategy))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">handleStateChanges</span><span class="params">(partitions: Seq[TopicPartition], targetState: PartitionState,</span></span></span><br><span class="line"><span class="function"><span class="params">                       partitionLeaderElectionStrategyOpt: Option[PartitionLeaderElectionStrategy] = None)</span>: Unit </span>= &#123;</span><br><span class="line">  <span class="keyword">if</span> (partitions.nonEmpty) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      controllerBrokerRequestBatch.newBatch()</span><br><span class="line">      doHandleStateChanges(partitions, targetState, partitionLeaderElectionStrategyOpt)</span><br><span class="line">      <span class="comment">// 发送一次请求队列，包括了doHandleStateChanges里新增的请求</span></span><br><span class="line">      controllerBrokerRequestBatch.sendRequestsToBrokers(controllerContext.epoch)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: Throwable =&gt; error(s<span class="string">"Error while moving some partitions to $targetState state"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分区leader选举"><a href="#分区leader选举" class="headerlink" title="分区leader选举"></a>分区leader选举</h2><p>doHandleStateChanges主要是选举分区的leader副本，这里现将分区分为两类：</p>
<ol>
<li>未初始化的分区(uninitializedPartitions)：状态是NewPartition的分区</li>
<li>准备要选举leader副本的分区(partitionsToElectLeader)：状态是OfflinePartition，OnlinePartition的分区<br>doHandleStateChanges主要是对这两类分区选举leader，并放到前面说的partitionState缓存中</li>
</ol>
<p>注：注意前面传递过来的选举策略是OfflinePartitionLeaderElectionStrategy<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">doHandleStateChanges</span><span class="params">(partitions: Seq[TopicPartition], targetState: PartitionState,</span></span></span><br><span class="line"><span class="function"><span class="params">                         partitionLeaderElectionStrategyOpt: Option[PartitionLeaderElectionStrategy])</span>: Unit </span>= &#123;</span><br><span class="line">  <span class="comment">// 这里的处理和副本状态机一样</span></span><br><span class="line">  val stateChangeLog = stateChangeLogger.withControllerEpoch(controllerContext.epoch)</span><br><span class="line">  partitions.foreach(partition =&gt; partitionState.getOrElseUpdate(partition, NonExistentPartition))</span><br><span class="line">  val (validPartitions, invalidPartitions) = partitions.partition(partition =&gt; isValidTransition(partition, targetState))</span><br><span class="line">  invalidPartitions.foreach(partition =&gt; logInvalidTransition(partition, targetState))</span><br><span class="line">  targetState match &#123;</span><br><span class="line">    <span class="keyword">case</span> OnlinePartition =&gt;</span><br><span class="line">      val uninitializedPartitions = validPartitions.filter(partition =&gt; partitionState(partition) == NewPartition) <span class="comment">// 类型：Seq[TopicPartition]</span></span><br><span class="line">      val partitionsToElectLeader = validPartitions.filter(partition =&gt; partitionState(partition) == OfflinePartition || partitionState(partition) == OnlinePartition)</span><br><span class="line">      <span class="comment">// 状态为NewPartition的分区处理</span></span><br><span class="line">      <span class="keyword">if</span> (uninitializedPartitions.nonEmpty) &#123;</span><br><span class="line">        <span class="comment">// 初始化新分区的leader</span></span><br><span class="line">        val successfulInitializations = initializeLeaderAndIsrForPartitions(uninitializedPartitions)</span><br><span class="line">        successfulInitializations.foreach &#123; partition =&gt;</span><br><span class="line">          stateChangeLog.trace(s<span class="string">"Changed partition $partition from $&#123;partitionState(partition)&#125; to $targetState with state "</span> +</span><br><span class="line">            s<span class="string">"$&#123;controllerContext.partitionLeadershipInfo(partition).leaderAndIsr&#125;"</span>)</span><br><span class="line">          partitionState.put(partition, OnlinePartition)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// OfflinePartition,OnlinePartition副本中开始选举</span></span><br><span class="line">      <span class="keyword">if</span> (partitionsToElectLeader.nonEmpty) &#123;</span><br><span class="line">        <span class="comment">// 根据选举策略(Strategy)选举leader副本</span></span><br><span class="line">        val successfulElections = electLeaderForPartitions(partitionsToElectLeader, partitionLeaderElectionStrategyOpt.get)</span><br><span class="line">        successfulElections.foreach &#123; partition =&gt;</span><br><span class="line">          stateChangeLog.trace(s<span class="string">"Changed partition $partition from $&#123;partitionState(partition)&#125; to $targetState with state "</span> +</span><br><span class="line">            s<span class="string">"$&#123;controllerContext.partitionLeadershipInfo(partition).leaderAndIsr&#125;"</span>)</span><br><span class="line">          <span class="comment">// 更新分区状态为OnlinePartition</span></span><br><span class="line">          partitionState.put(partition, OnlinePartition)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面说说这两类分区leader副本选举方式</p>
<h3 id="NewPartition状态的分区选举leader副本"><a href="#NewPartition状态的分区选举leader副本" class="headerlink" title="NewPartition状态的分区选举leader副本"></a>NewPartition状态的分区选举leader副本</h3><p>initializeLeaderAndIsrForPartitions方法是在为NewPartition状态的分区选举leader副本<br>代码看上去很长，但是一句话就可以概括：取存活副本的列表的第一个副本作为leader，写回到zk的state节点，更新本地缓存，并发送LeaderAndIsr请求同步给其他broker</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">initializeLeaderAndIsrForPartitions</span><span class="params">(partitions: Seq[TopicPartition])</span>: Seq[TopicPartition] </span>= &#123;</span><br><span class="line">    val successfulInitializations = mutable.Buffer.empty[TopicPartition]</span><br><span class="line">    <span class="comment">// 获取分区副本</span></span><br><span class="line">    val replicasPerPartition = partitions.map(partition =&gt; partition -&gt; controllerContext.partitionReplicaAssignment(partition))</span><br><span class="line">    <span class="comment">// 只要在线的副本</span></span><br><span class="line">    val liveReplicasPerPartition = replicasPerPartition.map &#123; <span class="keyword">case</span> (partition, replicas) =&gt;</span><br><span class="line">        val liveReplicasForPartition = replicas.filter(replica =&gt; controllerContext.isReplicaOnline(replica, partition))</span><br><span class="line">        partition -&gt; liveReplicasForPartition</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分区按照是否有在线的副本</span></span><br><span class="line">    val (partitionsWithoutLiveReplicas, partitionsWithLiveReplicas) = liveReplicasPerPartition.partition &#123; <span class="keyword">case</span> (_, liveReplicas) =&gt; liveReplicas.isEmpty &#125;</span><br><span class="line">    <span class="comment">// 没有在线副本的分区处理：打日志</span></span><br><span class="line">    partitionsWithoutLiveReplicas.foreach &#123; <span class="keyword">case</span> (partition, replicas) =&gt;</span><br><span class="line">      val failMsg = s<span class="string">"Controller $controllerId epoch $&#123;controllerContext.epoch&#125; encountered error during state change of "</span> +</span><br><span class="line">        s<span class="string">"partition $partition from New to Online, assigned replicas are "</span> +</span><br><span class="line">        s<span class="string">"[$&#123;replicas.mkString("</span>,<span class="string">")&#125;], live brokers are [$&#123;controllerContext.liveBrokerIds&#125;]. No assigned "</span> +</span><br><span class="line">        <span class="string">"replica is alive."</span></span><br><span class="line">      logFailedStateChange(partition, NewPartition, OnlinePartition, <span class="keyword">new</span> StateChangeFailedException(failMsg))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有在线副本的分区，将在线副本的第一个leader副本，并初始化ISR列表</span></span><br><span class="line">    <span class="comment">// Map[TopicPartition, LeaderIsrAndControllerEpoch]</span></span><br><span class="line">    val leaderIsrAndControllerEpochs = partitionsWithLiveReplicas.map &#123; <span class="keyword">case</span> (partition, liveReplicas) =&gt;</span><br><span class="line">      <span class="comment">// 这里就在初始化分区的leader(在线副本的第一个)，ISR</span></span><br><span class="line">      val leaderAndIsr = LeaderAndIsr(liveReplicas.head, liveReplicas.toList)</span><br><span class="line">      val leaderIsrAndControllerEpoch = LeaderIsrAndControllerEpoch(leaderAndIsr, controllerContext.epoch) <span class="comment">// 加上Controller epoch</span></span><br><span class="line">      partition -&gt; leaderIsrAndControllerEpoch</span><br><span class="line">    &#125;.toMap</span><br><span class="line">    val createResponses = <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建 /topics/topic名称/partitions/分区名称/state，包含中间节点</span></span><br><span class="line">      zkClient.createTopicPartitionStatesRaw(leaderIsrAndControllerEpochs)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: Exception =&gt;</span><br><span class="line">        partitionsWithLiveReplicas.foreach &#123; <span class="keyword">case</span> (partition,_) =&gt; logFailedStateChange(partition, partitionState(partition), NewPartition, e) &#125;</span><br><span class="line">        Seq.empty</span><br><span class="line">    &#125;</span><br><span class="line">    createResponses.foreach &#123; createResponse =&gt;</span><br><span class="line">      val code = createResponse.resultCode</span><br><span class="line">      val partition = createResponse.ctx.get.asInstanceOf[TopicPartition]</span><br><span class="line">      val leaderIsrAndControllerEpoch = leaderIsrAndControllerEpochs(partition)</span><br><span class="line">      <span class="keyword">if</span> (code == Code.OK) &#123;</span><br><span class="line">        <span class="comment">// 缓存起来分区的leader和ISR数据</span></span><br><span class="line">        controllerContext.partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// isr是在线副本所在的brokerId，这里向这些broker发送LeaderAndIsr请求</span></span><br><span class="line">        controllerBrokerRequestBatch.addLeaderAndIsrRequestForBrokers(leaderIsrAndControllerEpoch.leaderAndIsr.isr,</span><br><span class="line">          partition, leaderIsrAndControllerEpoch, controllerContext.partitionReplicaAssignment(partition), isNew = <span class="keyword">true</span>)</span><br><span class="line">        <span class="comment">// 作为成功初始化的分区返回</span></span><br><span class="line">        successfulInitializations += partition</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logFailedStateChange(partition, NewPartition, OnlinePartition, code)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    successfulInitializations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OfflinePartition-OnlinePartition状态的分区选举leader副本"><a href="#OfflinePartition-OnlinePartition状态的分区选举leader副本" class="headerlink" title="OfflinePartition/OnlinePartition状态的分区选举leader副本"></a>OfflinePartition/OnlinePartition状态的分区选举leader副本</h3><p>electLeaderForPartitions方法用于OfflinePartition/OnlinePartition状态的所有分区选举leader副本<br>而每一个分区的的leader副本选举在doElectLeaderForPartitions方法实现，虽然代码很多，但核心还是选举leader副本，写回zk，更新本地缓存，并发送LeaderAndIsr请求同步给其他broker</p>
<p>分区leader会在不同情况下选举leader副本，因此有4种选举策略，此时根据前面传递过来的参数，选举策略为OfflinePartitionLeaderElectionStrategy<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">doElectLeaderForPartitions</span><span class="params">(partitions: Seq[TopicPartition], partitionLeaderElectionStrategy: PartitionLeaderElectionStrategy)</span>:</span></span><br><span class="line"><span class="function">  <span class="params">(Seq[TopicPartition], Seq[TopicPartition], Map[TopicPartition, Exception])</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// 先批量获取zk中.../partitions/xxx/state，即每个分区的state 数据</span></span><br><span class="line">    <span class="comment">// 样例： &#123;"controller_epoch":19,"leader":0,"version":1,"leader_epoch":57,"isr":[0,1,2]&#125;</span></span><br><span class="line">    val getDataResponses = <span class="keyword">try</span> &#123;</span><br><span class="line">      zkClient.getTopicPartitionStatesRaw(partitions)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: Exception =&gt;</span><br><span class="line">        <span class="keyword">return</span> (Seq.empty, Seq.empty, partitions.map(_ -&gt; e).toMap)</span><br><span class="line">    &#125;</span><br><span class="line">    val failedElections = mutable.Map.empty[TopicPartition, Exception]</span><br><span class="line">    val leaderIsrAndControllerEpochPerPartition = mutable.Buffer.empty[(TopicPartition, LeaderIsrAndControllerEpoch)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是初始化leaderIsrAndControllerEpochPerPartition</span></span><br><span class="line">    getDataResponses.foreach &#123; getDataResponse =&gt;</span><br><span class="line">      <span class="comment">// context 就是请求参数里的分区</span></span><br><span class="line">      val partition = getDataResponse.ctx.get.asInstanceOf[TopicPartition]</span><br><span class="line">      val currState = partitionState(partition) <span class="comment">// 获取缓存中该分区的状态</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getDataResponse.resultCode == Code.OK) &#123;</span><br><span class="line">        <span class="comment">// 解析成LeaderIsrAndControllerEpoch</span></span><br><span class="line">        val leaderIsrAndControllerEpochOpt = TopicPartitionStateZNode.decode(getDataResponse.data, getDataResponse.stat)</span><br><span class="line">        <span class="comment">// 没获取到leaderIsrAndControllerEpoch，添加到failedElections集合里</span></span><br><span class="line">        <span class="keyword">if</span> (leaderIsrAndControllerEpochOpt.isEmpty) &#123;</span><br><span class="line">          val exception = <span class="keyword">new</span> StateChangeFailedException(s<span class="string">"LeaderAndIsr information doesn't exist for partition $partition in $currState state"</span>)</span><br><span class="line">          failedElections.put(partition, exception)</span><br><span class="line">        &#125;</span><br><span class="line">        leaderIsrAndControllerEpochPerPartition += partition -&gt; leaderIsrAndControllerEpochOpt.get <span class="comment">// 加个括号好看些 (partition -&gt; leaderIsrAndControllerEpochOpt.get)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getDataResponse.resultCode == Code.NONODE) &#123;</span><br><span class="line">        <span class="comment">// 节点不存在</span></span><br><span class="line">        val exception = <span class="keyword">new</span> StateChangeFailedException(s<span class="string">"LeaderAndIsr information doesn't exist for partition $partition in $currState state"</span>)</span><br><span class="line">        failedElections.put(partition, exception)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他zk异常</span></span><br><span class="line">        failedElections.put(partition, getDataResponse.resultException.get)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zk里的controllerEpoch是否比 本地缓存里的controllerEpoch大，大就说明有其他Controller已经被选举了，写到了zk的partition/state里</span></span><br><span class="line">    val (invalidPartitionsForElection, validPartitionsForElection) = leaderIsrAndControllerEpochPerPartition.partition &#123; <span class="keyword">case</span> (_, leaderIsrAndControllerEpoch) =&gt;</span><br><span class="line">      leaderIsrAndControllerEpoch.controllerEpoch &gt; controllerContext.epoch</span><br><span class="line">    &#125;</span><br><span class="line">    invalidPartitionsForElection.foreach &#123; <span class="keyword">case</span> (partition, leaderIsrAndControllerEpoch) =&gt;</span><br><span class="line">      val failMsg = s<span class="string">"aborted leader election for partition $partition since the LeaderAndIsr path was "</span> +</span><br><span class="line">        s<span class="string">"already written by another controller. This probably means that the current controller $controllerId went through "</span> +</span><br><span class="line">        s<span class="string">"a soft failure and another controller was elected with epoch $&#123;leaderIsrAndControllerEpoch.controllerEpoch&#125;."</span></span><br><span class="line">      failedElections.put(partition, <span class="keyword">new</span> StateChangeFailedException(failMsg))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部分区都被新Controller更新了state，直接返回failedElections</span></span><br><span class="line">    <span class="keyword">if</span> (validPartitionsForElection.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Seq.empty, Seq.empty, failedElections.toMap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val shuttingDownBrokers  = controllerContext.shuttingDownBrokerIds.toSet</span><br><span class="line"></span><br><span class="line">    val (partitionsWithoutLeaders, partitionsWithLeaders) = partitionLeaderElectionStrategy match &#123;</span><br><span class="line">      <span class="keyword">case</span> OfflinePartitionLeaderElectionStrategy =&gt; <span class="comment">// 初始化是用的是OfflinePartitionLeaderElectionStrategy(追参数传递)</span></span><br><span class="line">        <span class="comment">// 注意这里的scala语法，partition是布尔分组器，并返回结果给外边的val变量</span></span><br><span class="line">        leaderForOffline(validPartitionsForElection).partition &#123; <span class="keyword">case</span> (_, newLeaderAndIsrOpt, _) =&gt; newLeaderAndIsrOpt.isEmpty &#125;</span><br><span class="line">      <span class="keyword">case</span> ReassignPartitionLeaderElectionStrategy =&gt; <span class="comment">// 分区重分配时的选举算法</span></span><br><span class="line">        leaderForReassign(validPartitionsForElection).partition &#123; <span class="keyword">case</span> (_, newLeaderAndIsrOpt, _) =&gt; newLeaderAndIsrOpt.isEmpty &#125;</span><br><span class="line">      <span class="keyword">case</span> PreferredReplicaPartitionLeaderElectionStrategy =&gt;</span><br><span class="line">        leaderForPreferredReplica(validPartitionsForElection).partition &#123; <span class="keyword">case</span> (_, newLeaderAndIsrOpt, _) =&gt; newLeaderAndIsrOpt.isEmpty &#125;</span><br><span class="line">      <span class="keyword">case</span> ControlledShutdownPartitionLeaderElectionStrategy =&gt;</span><br><span class="line">        leaderForControlledShutdown(validPartitionsForElection, shuttingDownBrokers).partition &#123; <span class="keyword">case</span> (_, newLeaderAndIsrOpt, _) =&gt; newLeaderAndIsrOpt.isEmpty &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没选举出leader的分区</span></span><br><span class="line">    partitionsWithoutLeaders.foreach &#123; <span class="keyword">case</span> (partition, _, _) =&gt;</span><br><span class="line">      val failMsg = s<span class="string">"Failed to elect leader for partition $partition under strategy $partitionLeaderElectionStrategy"</span></span><br><span class="line">      failedElections.put(partition, <span class="keyword">new</span> StateChangeFailedException(failMsg))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区和存活的副本形成一个集合</span></span><br><span class="line">    val recipientsPerPartition = partitionsWithLeaders.map &#123; <span class="keyword">case</span> (partition, _, recipients) =&gt; partition -&gt; recipients &#125;.toMap</span><br><span class="line">    <span class="comment">// 分区和选举后的isr形成一个集合</span></span><br><span class="line">    val adjustedLeaderAndIsrs = partitionsWithLeaders.map &#123; <span class="keyword">case</span> (partition, leaderAndIsrOpt, _) =&gt; partition -&gt; leaderAndIsrOpt.get &#125;.toMap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新每个选举成功的分区，更新leaderAndIsr，controller epoch</span></span><br><span class="line">    <span class="function">val <span class="title">UpdateLeaderAndIsrResult</span><span class="params">(successfulUpdates, updatesToRetry, failedUpdates)</span> </span>= zkClient.updateLeaderAndIsr(</span><br><span class="line">      adjustedLeaderAndIsrs, controllerContext.epoch)</span><br><span class="line">    <span class="comment">// updatesToRetry是版本冲突而更新失败的分区</span></span><br><span class="line"></span><br><span class="line">    successfulUpdates.foreach &#123; <span class="keyword">case</span> (partition, leaderAndIsr) =&gt;</span><br><span class="line">      val replicas = controllerContext.partitionReplicaAssignment(partition)</span><br><span class="line">      val leaderIsrAndControllerEpoch = LeaderIsrAndControllerEpoch(leaderAndIsr, controllerContext.epoch)</span><br><span class="line">      <span class="comment">// zk更新成功，放入本地缓存</span></span><br><span class="line">      controllerContext.partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)</span><br><span class="line">      <span class="comment">// 发送LeaderAndIsr请求</span></span><br><span class="line">      controllerBrokerRequestBatch.addLeaderAndIsrRequestForBrokers(recipientsPerPartition(partition), partition,</span><br><span class="line">        leaderIsrAndControllerEpoch, replicas, isNew = <span class="keyword">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    (successfulUpdates.keys.toSeq, updatesToRetry, failedElections.toMap ++ failedUpdates) <span class="comment">// 这里是选举失败和更新zk失败的合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OfflinePartitionLeaderElectionStrategy策略的选举算法在leaderForOffline方法中实现</p>
<h3 id="leaderForOffline选举"><a href="#leaderForOffline选举" class="headerlink" title="leaderForOffline选举"></a>leaderForOffline选举</h3><p>在选举过程中，受unclean.leader.election.enable配置的约束，该配置可以是topic级别，线上环境一般设置为false，否则会在非isr的副本中选举leader，造成数据不一致问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">leaderForOffline</span><span class="params">(leaderIsrAndControllerEpochs: Seq[(TopicPartition, LeaderIsrAndControllerEpoch)</span>]):</span></span><br><span class="line"><span class="function">  Seq[<span class="params">(TopicPartition, Option[LeaderAndIsr], Seq[Int])</span>] </span>= &#123;</span><br><span class="line">    <span class="comment">// 又是布尔分区器</span></span><br><span class="line">    val (partitionsWithNoLiveInSyncReplicas, partitionsWithLiveInSyncReplicas) = leaderIsrAndControllerEpochs.partition &#123; <span class="keyword">case</span> (partition, leaderIsrAndControllerEpoch) =&gt;</span><br><span class="line">      <span class="comment">// 这是在查看zk中的ISR列表，broker本地缓存中是否存活</span></span><br><span class="line">      val liveInSyncReplicas = leaderIsrAndControllerEpoch.leaderAndIsr.isr.filter(replica =&gt; controllerContext.isReplicaOnline(replica, partition))</span><br><span class="line">      liveInSyncReplicas.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// partitionsWithNoLiveInSyncReplicas的含义：partition.isr.filter(replica =&gt; controllerContext.isReplicaOnline(replica, partition)).isEmpty</span></span><br><span class="line">    <span class="comment">// config.originals()就是server.properties里的配置</span></span><br><span class="line">    <span class="comment">// 获取topic的LogConfig配置对象，LogConfig(originals+overrides, overrides.keys)</span></span><br><span class="line">    val (logConfigs, failed) = zkClient.getLogConfigs(partitionsWithNoLiveInSyncReplicas.map &#123; <span class="keyword">case</span> (partition, _) =&gt; partition.topic &#125;, config.originals())</span><br><span class="line"></span><br><span class="line">    val partitionsWithUncleanLeaderElectionState = partitionsWithNoLiveInSyncReplicas.map &#123; <span class="keyword">case</span> (partition, leaderIsrAndControllerEpoch) =&gt;</span><br><span class="line">      <span class="comment">// failed: 从zk获取配置信息失败的topic</span></span><br><span class="line">      <span class="keyword">if</span> (failed.contains(partition.topic)) &#123;</span><br><span class="line">        <span class="comment">// 打日志</span></span><br><span class="line">        logFailedStateChange(partition, partitionState(partition), OnlinePartition, failed(partition.topic))</span><br><span class="line">        (partition, None, <span class="keyword">false</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回的是一个三元组(TopicPartition, Option(LeaderIsrAndControllerEpoch, 该topic"unclean.leader.election.enable"的配置),</span></span><br><span class="line">        (partition, Option(leaderIsrAndControllerEpoch), logConfigs(partition.topic).uncleanLeaderElectionEnable.booleanValue())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; ++ partitionsWithLiveInSyncReplicas.map &#123; <span class="keyword">case</span> (partition, leaderIsrAndControllerEpoch) =&gt; (partition, Option(leaderIsrAndControllerEpoch), <span class="keyword">false</span>) &#125;</span><br><span class="line">    <span class="comment">// partitionsWithLiveInSyncReplicas uncleanLeaderElectionEnabled默认为false，说明有isr副本有存活的，就一定从isr里选，哪怕只有1个</span></span><br><span class="line"></span><br><span class="line">    partitionsWithUncleanLeaderElectionState.map &#123; <span class="keyword">case</span> (partition, leaderIsrAndControllerEpochOpt, uncleanLeaderElectionEnabled) =&gt;</span><br><span class="line">      <span class="comment">// 获取副本集合</span></span><br><span class="line">      val assignment = controllerContext.partitionReplicaAssignment(partition)</span><br><span class="line">      <span class="comment">// 再检查本地缓存里的副本是否在线</span></span><br><span class="line">      val liveReplicas = assignment.filter(replica =&gt; controllerContext.isReplicaOnline(replica, partition))</span><br><span class="line">      <span class="keyword">if</span> (leaderIsrAndControllerEpochOpt.nonEmpty) &#123;</span><br><span class="line">        val leaderIsrAndControllerEpoch = leaderIsrAndControllerEpochOpt.get</span><br><span class="line">        val isr = leaderIsrAndControllerEpoch.leaderAndIsr.isr</span><br><span class="line">        <span class="comment">// 选举分区leader的算法</span></span><br><span class="line">        val leaderOpt = PartitionLeaderElectionAlgorithms.offlinePartitionLeaderElection(assignment, isr, liveReplicas.toSet, uncleanLeaderElectionEnabled, controllerContext)</span><br><span class="line"></span><br><span class="line">        val newLeaderAndIsrOpt = leaderOpt.map &#123; leader =&gt;</span><br><span class="line">          <span class="comment">// 如果副本是从isr里选出来的，就再过滤检查一遍isr里的副本是否在线</span></span><br><span class="line">          val newIsr = <span class="keyword">if</span> (isr.contains(leader)) isr.filter(replica =&gt; controllerContext.isReplicaOnline(replica, partition))</span><br><span class="line">          <span class="keyword">else</span> List(leader)</span><br><span class="line">          <span class="comment">// leader epoch+1,返回新的LeaderAndIsr</span></span><br><span class="line">          leaderIsrAndControllerEpoch.leaderAndIsr.newLeaderAndIsr(leader, newIsr)</span><br><span class="line">        &#125;</span><br><span class="line">        (partition, newLeaderAndIsrOpt, liveReplicas)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (partition, None, liveReplicas)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而最终的leader选举算法在PartitionLeaderElectionAlgorithms.offlinePartitionLeaderElection方法内实现</p>
<h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><p>该选举算法也比较简单，找到第一个在isr列表，并且是存活的副本作为leader<br>如果没有，并且unclean.leader.election.enable=true，从所有副本中取第一个存活的副本作为leader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> assignment 分区分配的副本</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> isr zk中的ISR</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> liveReplicas assignment中在线的副本</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> uncleanLeaderElectionEnabled</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> controllerContext</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function">def <span class="title">offlinePartitionLeaderElection</span><span class="params">(assignment: Seq[Int], isr: Seq[Int], liveReplicas: Set[Int], uncleanLeaderElectionEnabled: Boolean, controllerContext: ControllerContext)</span>: Option[Int] </span>= &#123;</span><br><span class="line">  <span class="comment">// 从assignment中找第一个liveReplicas和isr都有的replica id</span></span><br><span class="line">  <span class="comment">// 找不到执行orElse逻辑</span></span><br><span class="line">  assignment.find(id =&gt; liveReplicas.contains(id) &amp;&amp; isr.contains(id)).orElse &#123;</span><br><span class="line">    <span class="keyword">if</span> (uncleanLeaderElectionEnabled) &#123; <span class="comment">// unclean elect</span></span><br><span class="line">      <span class="comment">// 从assignment找第一个Online的Replica作为leader</span></span><br><span class="line">      <span class="comment">// 也就是说不在isr里的副本也可以参与选举（uncleanLeaderElect）</span></span><br><span class="line">      val leaderOpt = assignment.find(liveReplicas.contains)</span><br><span class="line">      <span class="keyword">if</span> (!leaderOpt.isEmpty)</span><br><span class="line">        <span class="comment">// metrics</span></span><br><span class="line">        controllerContext.stats.uncleanLeaderElectionRate.mark()</span><br><span class="line">      leaderOpt</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 所有的副本都不在线</span></span><br><span class="line">      None</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此副本状态机和分区状态机的启动就算完成了，副本状态机与分区状态机的启动操作，都是先初始化了状态缓存，进行初始化的状态转换，里面做了更新ControllerContext，zk中的数据的操作，而分区状态机还需要为每个分区选举leader副本</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">紫夜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://greedypirate.github.io/2020/03/04/KafkaController源码分析之副本状态机与分区状态机的启动/">https://greedypirate.github.io/2020/03/04/KafkaController源码分析之副本状态机与分区状态机的启动/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kafka/">kafka</a><a class="post-meta__tags" href="/tags/中间件/">中间件</a><a class="post-meta__tags" href="/tags/消息/">消息</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ae01.alicdn.com/kf/H50b5d4d79e454447974210dae2d054435.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ae01.alicdn.com/kf/H45f5b133580045879faaa5fcbe9b598fu.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b6532776de86c85" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/05/KafkaController源码分析之分区重分配-PartitionReassignment与Preferred leader副本选举/"><i class="fa fa-chevron-left">  </i><span>KafkaController源码分析之分区副本重分配(PartitionReassignment)与Preferred leader副本选举</span></a></div><div class="next-post pull-right"><a href="/2020/02/12/KafkaController源码分析之Controller选举与初始化/"><span>KafkaController源码分析之Controller选举与初始化</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '0349a7a18b86f2a653e3',
  clientSecret: '567ba8cefbe2ecffbbc04e676652ae4b43e7f952',
  repo: 'GreedyPirate.github.io',
  owner: 'GreedyPirate',
  admin: 'GreedyPirate',
  id: md5(decodeURI(location.pathname)),
  language: ''
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 紫夜</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://GreedyPirate.github.io">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>