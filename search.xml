<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Kafka生产者源码浅析(三)</title>
      <link href="/2019/01/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%89)/"/>
      <url>/2019/01/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h1 id="Kafka生产者源码浅析-三"><a href="#Kafka生产者源码浅析-三" class="headerlink" title="Kafka生产者源码浅析(三)"></a>Kafka生产者源码浅析(三)</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在doSend方法中，最后几行代码是在消息添加进内存缓冲区之后，判断是否有可发送的消息，并唤醒了Sender线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">    log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</span><br><span class="line">    <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么sender线程又是如何发送的呢</p><p>猜想：</p><ol><li>先拿到缓冲区中待发送的所有消息，找到每个partitions leader所在的broker</li><li>然后按broker的地址分组</li><li>和broker建立连接，发送消息</li></ol><h2 id="sender发送消息"><a href="#sender发送消息" class="headerlink" title="sender发送消息"></a>sender发送消息</h2><p>Sender类实现了Runnable接口，那么主逻辑就应该在run方法中了，关于一些判断，事务先不用关系，来到Sender重载的run(long)方法，其中的两行关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pollTimeout = sendProducerData(now);</span><br><span class="line">    client.poll(pollTimeout, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendProducerData方法有点长，分段分析</p><h3 id="part-one"><a href="#part-one" class="headerlink" title="part one"></a>part one</h3><ol><li>获取集群信息</li><li>从RecordAccumulator获取可以发送消息的kafka broker节点</li><li>如果有partitions还没有leader，请求更新metadata</li><li>检查网络是否符合发送条件，不符合则移除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Cluster cluster = metadata.fetch();</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the list of partitions with data ready to send</span></span><br><span class="line">RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if there are any partitions whose leaders are not known yet, force metadata update</span></span><br><span class="line"><span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// The set of topics with unknown leader contains topics with leader election pending as well as</span></span><br><span class="line">    <span class="comment">// topics which may have expired. Add the topic again to metadata to ensure it is included</span></span><br><span class="line">    <span class="comment">// and request metadata update, since there are messages to send to the topic.</span></span><br><span class="line">    <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">        <span class="keyword">this</span>.metadata.add(topic);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"Requesting metadata update due to unknown leader topics from the batched records: &#123;&#125;"</span>, result.unknownLeaderTopics);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// remove any nodes we aren't ready to send to</span></span><br><span class="line">Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line"><span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Node node = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">        notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.pollDelayMs(node, now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka生产者源码浅析(二)</title>
      <link href="/2019/01/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%BA%8C)/"/>
      <url>/2019/01/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h1 id="Kafka生产者源码浅析-二"><a href="#Kafka生产者源码浅析-二" class="headerlink" title="Kafka生产者源码浅析(二)"></a>Kafka生产者源码浅析(二)</h1><blockquote><p>上篇文章中对Spring-kafka源码做了追踪，也对原生的KafkaProducer做了部门解析，对关键类事先说明，帮助读者理解源码，克服对源码的恐惧心理，一起品尝Kafka的饕餮盛宴</p></blockquote><p>doSend的方法很长，我们分部拆解</p><h2 id="Part-one"><a href="#Part-one" class="headerlink" title="Part one"></a>Part one</h2><p>首先吐槽下这个tp变量，定义在外边没什么卵用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    throwIfProducerClosed();</span><br><span class="line">    <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">    ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (metadata.isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>throwIfProducerClosed做的很简单，看看Sender线程是否活着</p></li><li><p>waitOnMetadata返回一个ClusterAndWaitTime对象，里面是broker集群的元信息和获取信息的耗时，它不能大于max.block.ms，对该方法做个简单的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metadata.add(topic);</span><br><span class="line">Cluster cluster = metadata.fetch();</span><br><span class="line">Integer partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line"><span class="keyword">if</span> (partitionsCount != <span class="keyword">null</span> &amp;&amp; (partition == <span class="keyword">null</span> || partition &lt; partitionsCount))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>将topic放入一个map中，value是topic的过期时间(如果开启topic过期功能)，从Cluster中获取topic的分区数，如果消息手动指定了分区，且小于分区数，就直接返回(说明手动指定的分区是有效的)</p></li></ol><h2 id="Part-two"><a href="#Part-two" class="headerlink" title="Part two"></a>Part two</h2><p>这一部分比较简单，计算了下maxBlockTimeMs还剩多少时间，同时对key和value序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line"><span class="keyword">byte</span>[] serializedKey;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">   <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] serializedValue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>接下来关注kafka是如何根据key为消息计算分区的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br></pre></td></tr></table></figure><p>第二行代码是将topic和分区包装成一个TopicPartition类，重点关注第一行代码</p><p>partition方法会尝试获取消息中的partition，如果用户指定了分区，此时就不用计算了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="keyword">byte</span>[] serializedKey, <span class="keyword">byte</span>[] serializedValue, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    Integer partition = record.partition();</span><br><span class="line">    <span class="keyword">return</span> partition != <span class="keyword">null</span> ?</span><br><span class="line">            partition :</span><br><span class="line">            partitioner.partition(</span><br><span class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultPartitioner"><a href="#DefaultPartitioner" class="headerlink" title="DefaultPartitioner"></a>DefaultPartitioner</h4><p>partitioner.partition的具体实现在DefaultPartitioner#partition，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">        <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">            List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">            <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">                <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">                <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回顾上一篇文章，Cluster封装了broker的很多信息，其中就用一个Map封装了topic的partition信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic</span><br></pre></td></tr></table></figure><p>此时要分区，首先要获取这个topic的PartitionInfo，第一行代码的作用就是这个，map.get(topic)，很简单</p><p>接下分两种情况：用户指定了key，和未指定key，我们知道旧版本的kafka在用户未指定key的情况下会默认将消息分配到某一个分区，但这样会造成数据倾斜，官方后来对此作了优化，采用随机的方式，简单提一下这块的代码</p><h4 id="随机分配"><a href="#随机分配" class="headerlink" title="随机分配"></a>随机分配</h4><p>kafka会初始化一个很大的伪随机数放在AtomicInteger中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="keyword">new</span> AtomicInteger(ThreadLocalRandom.current().nextInt())</span><br></pre></td></tr></table></figure></p><p>以topic为key保存在一个ConcurrentHashMap中，每次用完counter自增并返回，这就是nextValue方法的作用</p><p>接下来从Cluster中获取可用的分区信息，获取分区数，使用counter对其取模，然后从可用分区列表中获取一个分区，由于counter的自增，达到了轮询(round-robin)的效果。但如果没有可用的分区，则从所有分区中挑选</p><p>Utils.toPositive用于取绝对值，kafka选择了一个cheap way: 与运算</p><p>以上是对消息中没有key的情况下如何分配分区的分析，至于有key的情况就比较简单了：对key做<a href="https://sites.google.com/site/murmurhash/" target="_blank" rel="noopener">murmur2 hash</a>运算，然后对分区数取模</p><h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><p>实现Partitioner接口即可，配置方式参考拦截器，二者同理，参数名称为: partitioner.class</p><h2 id="Part-three"><a href="#Part-three" class="headerlink" title="Part three"></a>Part three</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setReadOnly(record.headers());</span><br><span class="line">Header[] headers = record.headers().toArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                    compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">ensureValidRecordSize(serializedSize);</span><br><span class="line"><span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">log.trace(<span class="string">"Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;"</span>, record, callback, record.topic(), partition);</span><br><span class="line">Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br></pre></td></tr></table></figure><p>先把不重要的说了，这几行代码的可读性很好，设置消息头只读，然后<strong>估算</strong>消息的总大小，确保不会超出max.request.size和buffer.memory的大小，获取消息的时间戳，用户指定的优先，最后构建一个InterceptorCallback回调对象，它会先指定拦截器的onAcknowledgement回调，然后执行用户指定的Callback#onCompletion</p><h3 id="追加至缓存并发送"><a href="#追加至缓存并发送" class="headerlink" title="追加至缓存并发送"></a>追加至缓存并发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line"><span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">    log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</span><br><span class="line">    <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.future;</span><br></pre></td></tr></table></figure><p>首先思考下缓存区的数据结构是什么：它应该有个先来后到的顺序，即先进先出(FIFO)，用一个队列实现即可</p><p>而kafka真正使用的是一个双端队列，基于”工作密取”模式减少队列竞争，提高效率</p><p>RecordAccumulator为topic的每一个分区都创建了一个ArrayDeque(thread unsafe)，里面存放的元素是ProducerBatch，它就是待批量发送的消息。<br>kafka使用一个CopyOnWriteMap保存分区和队列的关系，即只有在修改该map时把内容Copy出去形成一个新的内容然后再改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches = <span class="keyword">new</span> CopyOnWriteMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>该map的模型如下<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzmdhav2ifj311q0gsgmu.jpg" alt="模型"></p><p>append方法返回一个RecordAppendResult，它是消息在添加进内存缓冲区后的结果：Deque队列中是否有元素，是否有新的ProducerBatch创建，两个条件都可以去通知sender线程发送消息</p><p>append方法的具体实现过程还是很复杂的，这里说下笔者对这个过程的理解：</p><ol><li>尝试获取该TopicPartition下的队列，如果没有则创建</li><li>获取队列的最后一个ProducerBatch元素，将消息添加至该ProducerBatch，该过程会对Deque加锁</li><li>如果队列里没有ProducerBatch，或是最后一个ProducerBatch已经满了，就需要新建一个ProducerBatch</li><li>分配一个ByteBuffer空间，该空间大小在batch.size和消息大小中取较大值</li><li>再重新尝试步骤2一次，万一这时候刚好又有了呢(这时候Deque已经释放锁了)</li><li>创建好ProducerBatch之后，继续尝试append，添加成功之后将future和callback放入一个Thunk对象中，并且添加到一个List<thunk>集合，这是因为一批消息需要发送之后才有回调，所以先把回调统一放入一个集合中</thunk></li><li>添加成功之后，返回future对象，将ProducerBatch添加至Deque队列，同时用一个集合IncompleteBatches持有住了ProducerBatch</li><li>清理buffer空间，封装RecordAppendResult结果：Deque队列大小，新建的ProducerBatch对象是否已满</li></ol><p>完整的源码如下，其中的调用栈还可以深入，有兴趣的同学可以顺着我的思路继续看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Header[] headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// We keep track of the number of appending thread to make sure we do not miss batches in</span></span><br><span class="line">    <span class="comment">// abortIncompleteBatches().</span></span><br><span class="line">    appendsInProgress.incrementAndGet();</span><br><span class="line">    ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (headers == <span class="keyword">null</span>) headers = Record.EMPTY_HEADERS;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check if we have an in-progress batch</span></span><br><span class="line">        Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we don't have an in-progress record batch try to allocate a new batch</span></span><br><span class="line">        <span class="keyword">byte</span> maxUsableMagic = apiVersions.maxUsableProduceMagic();</span><br><span class="line">        <span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));</span><br><span class="line">        log.trace(<span class="string">"Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;"</span>, size, tp.topic(), tp.partition());</span><br><span class="line">        buffer = free.allocate(size, maxTimeToBlock);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="comment">// Need to check if producer is closed again after grabbing the dequeue lock.</span></span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line"></span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 万一这个时候又有了可用的ProducerBatch呢，我们就不用新建了呀，唉~这就很舒服</span></span><br><span class="line">                <span class="comment">// Somebody else found us a batch, return the one we waited for! Hopefully this doesn't happen often...</span></span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">            ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">            FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">            dq.addLast(batch);</span><br><span class="line">            incomplete.add(batch);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't deallocate this buffer in the finally block as it's being used in the record batch</span></span><br><span class="line">            buffer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer != <span class="keyword">null</span>)</span><br><span class="line">            free.deallocate(buffer);</span><br><span class="line">        appendsInProgress.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProducerBatch#tryAppend方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Long checksum = <span class="keyword">this</span>.recordsBuilder.append(timestamp, key, value, headers);</span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(),</span><br><span class="line">                recordsBuilder.compressionType(), key, value, headers));</span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;</span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                               timestamp, checksum,</span><br><span class="line">                                                               key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                               value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length);</span><br><span class="line">        <span class="comment">// we have to keep every future returned to the users in case the batch needs to be</span></span><br><span class="line">        <span class="comment">// split to several new batches and resent.</span></span><br><span class="line">        thunks.add(<span class="keyword">new</span> Thunk(callback, future));</span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka生产者源码浅析(一)</title>
      <link href="/2019/01/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%80)/"/>
      <url>/2019/01/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h1 id="Kafka生产者源码浅析-一"><a href="#Kafka生产者源码浅析-一" class="headerlink" title="Kafka生产者源码浅析(一)"></a>Kafka生产者源码浅析(一)</h1><blockquote><p>本文并没有直接使用原生的kafka-client，而是spring-kafka，版本为2.2.3.RELEASE。在当前以Spring-boot为首的潮流中，有必要学习Spring是如何集成kafka客户端的</p></blockquote><h1 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h1><p>以KafkaTemplate#send方法为入口，使用debug方式跟进源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, K key, <span class="meta">@Nullable</span> V data) &#123;</span><br><span class="line">  ProducerRecord&lt;K, V&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, key, data);</span><br><span class="line">  <span class="keyword">return</span> doSend(producerRecord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将消息封装为ProducerRecord对象，这是kafka-client原生对象，接下来进行发送操作<br>在doSend方法中，有很多事务相关，日志相关的代码，我们的目的是理清楚主流程，因此省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; doSend(<span class="keyword">final</span> ProducerRecord&lt;K, V&gt; producerRecord) &#123;</span><br><span class="line">  <span class="keyword">final</span> Producer&lt;K, V&gt; producer = getTheProducer();</span><br><span class="line">  <span class="keyword">final</span> SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future = <span class="keyword">new</span> SettableListenableFuture&lt;&gt;();</span><br><span class="line">  producer.send(producerRecord, buildCallback(producerRecord, producer, future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先通过getTheProducer获取生产者对象，那么Spring-kafka是如何创建该对象的呢？</p><h2 id="构建生产者"><a href="#构建生产者" class="headerlink" title="构建生产者"></a>构建生产者</h2><p>代码只有一行，通过DefaultKafkaProducerFactory创建生产者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.producerFactory.createProducer();</span><br></pre></td></tr></table></figure></p><p>进入到DefaultKafkaProducerFactory#createProducer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Producer&lt;K, V&gt; <span class="title">createProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.producer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.producer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.producer = <span class="keyword">new</span> CloseSafeProducer&lt;K, V&gt;(createKafkaProducer());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道kafka生产者是单例并且线程安全的，这里spring使用double-check构建了一个CloseSafeProducer对象，而它被volatile修饰，经典的懒汉单例模式<br>平常我们使用的都是KafkaProducer，这个CloseSafeProducer又是什么呢？<br>该类实现了Producer接口，这也是KafkaProducer的父接口，细心的同学发现了CloseSafeProducer在创建是调用了createKafkaProducer方法，该方法源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Producer&lt;K, V&gt; <span class="title">createKafkaProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> KafkaProducer&lt;K, V&gt;(<span class="keyword">this</span>.configs, <span class="keyword">this</span>.keySerializer, <span class="keyword">this</span>.valueSerializer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坑爹呢这是，这个不还是KafkaProducer对象吗，那么传入一个KafkaProducer是要干吗，对装饰者模式和代理模式熟悉的同学已经明白是怎么回事，spring也确实这样做的：具体功能实现都委托给KafkaProducer对象实现，spring对记录事务id等日志信息做了增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseSafeProducer</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Producer</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Producer&lt;K, V&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;CloseSafeProducer&lt;K, V&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;CloseSafeProducer&lt;K, V&gt;&gt; removeConsumerProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String txId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> txFailed;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>CloseSafeProducer的分析至此结束，在获取到包装后的KafkaProducer后，便是发送流程了</p><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>回到doSend方法，发送的代码只有两行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future = </span><br><span class="line"><span class="keyword">new</span> SettableListenableFuture&lt;&gt;();</span><br><span class="line">producer.send(producerRecord, buildCallback(producerRecord, producer, future));</span><br></pre></td></tr></table></figure></p><p>SettableListenableFuture是一个可设置，可监听的Future对象，用它构建异步发送消息后的Callback对象，读者可以认为Spring使用SettableListenableFuture对象对返回结果和异常进行了封装，Callback的作用在下文揭晓。</p><p>接着send方法由CloseSafeProducer委托给KafkaProducer执行，KafkaProducer的send方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);</span><br><span class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的官方文档翻译如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">异步发送一条消息到一个topic，并且在应答之后立即调用已提供的回调</span><br><span class="line">发送是异步的，一旦消息存储到了等待发送的缓冲区，该方法会立即返回。这样就不用阻塞在等待每一次发送消息的响应，允许并行的发送大量消息。</span><br><span class="line">发送后的结果对象RecordMetadata具体说明了消息被发送到了哪个分区，被分配的位移和时间戳。</span><br><span class="line">如果topic使用了TimestampType#CREATE_TIME，那么使用用户指定的时间，如果未指定，则使用发送时间。</span><br><span class="line">如果使用了TimestampType#LOG_APPEND_TIME，则使用消息在broker端追加到日志的时间</span><br><span class="line">send方法会为RecordMetadata对象返回一个Future对象，调用Future#get将会阻塞到请求完成，返回消息的元数据，或者返回在发送请求期间的任何异常</span><br><span class="line">如果你想模拟一下，你可以send之后立即调用get</span><br><span class="line">producer.send(record).get()</span><br><span class="line">完全非阻塞的用法是用Callback参数来提供一个回调，它将在请求结束之后被调用</span><br><span class="line">producer.send(myRecord, <span class="keyword">new</span> Callback()&#123;...&#125;)</span><br><span class="line"></span><br><span class="line">Callback将在producer的I/O线程中触发，所以它必须轻量，快速，否则其他线程的消息会延迟发送。如果你在Callback中有耗时的逻辑处理，建议使用你自己的Executor，在Callback体中并发的执行</span><br></pre></td></tr></table></figure></p><p>Spring同样支持同步和异步，将结果和异常都保存在了SettableListenableFuture中<br>这里再提一下Callback和Producerinterceptor的使用</p><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>这里提一下Callback类，这是一个函数式接口，仅有一个onCompletion方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span></span>;</span><br></pre></td></tr></table></figure></p><p>两个参数分别为成功之后的消息元数据对象，和失败之后的异常对象，两者总是只有一个不为空(要么成功，要么失败)，而Exception分为两类异常：可重试异常，不可重试异常<br>可重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CorruptRecordException</span><br><span class="line">InvalidMetadataException</span><br><span class="line">NotEnoughReplicasAfterAppendException</span><br><span class="line">NotEnoughReplicasException</span><br><span class="line">OffsetOutOfRangeException</span><br><span class="line">TimeoutException</span><br><span class="line">UnknownTopicOrPartitionException</span><br></pre></td></tr></table></figure><p>不可重试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvalidTopicException</span><br><span class="line">OffsetMetadataTooLargeException</span><br><span class="line">RecordBatchTooLargeException</span><br><span class="line">RecordTooLargeException</span><br><span class="line">UnknownServerException</span><br></pre></td></tr></table></figure></p><p>可重试异常都继承自RetriableException，常见的判断方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> RetriableException)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在发送消息之前，开发者都可以自定义拦截器，实现Producerinterceptor即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每条消息发送之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProducerRecord&lt;K, V&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span>;</span><br><span class="line"><span class="comment">//发送请求应答之后调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="添加拦截器"><a href="#添加拦截器" class="headerlink" title="添加拦截器"></a>添加拦截器</h4><p>kafka原生配置方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">interceptors.add(<span class="string">"your class"</span>); </span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br></pre></td></tr></table></figure><p>在spring-kafka中配置更加简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.producer.properties.interceptor.classes=your class</span><br></pre></td></tr></table></figure></p><h3 id="消息发送-doSend"><a href="#消息发送-doSend" class="headerlink" title="消息发送(doSend)"></a>消息发送(doSend)</h3><p>经过拦截器拦截后，发送消息的流程又是如何呢</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzk5dhhii8j31dq0iogqw.jpg" alt="发送流程"></p><p>上图摘自胡夕老师的《Apache kafka实战》，十分形象的描绘了消息发送流程，正如上图所示，doSend方法只有有一个入参ProducerRecord，用于封装消息，一个出参RecordMetadata，它是broker应答之后的返回信息。二者的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key长度，value长度可计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordMetadata</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedKeySize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedValueSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TopicPartition topicPartition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Long checksum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>为了便于理解接下来的流程，有几个类需要为大家介绍清楚</p><p>在KafkaProducer的构造函数中初始化了以下几个关键类，有兴趣的读者可自行研究，可省略JMX和事务相关的内容</p><ul><li><p>Partitioner：分区选择器，你要发送的这条消息应该分配到哪个分区？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.partitioner = </span><br><span class="line">        config.getConfiguredInstance(ProducerConfig.PARTITIONER_CLASS_CONFIG,Partitioner.class);</span><br></pre></td></tr></table></figure></li><li><p>KafkaClient：用于和broker做网络交互的客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KafkaClient client = kafkaClient != null ? kafkaClient : new NetworkClient(...);</span><br></pre></td></tr></table></figure></li><li><p>Sender：用于批量发送消息的I/O线程，也称sender线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sender = <span class="keyword">new</span> Sender(...);</span><br></pre></td></tr></table></figure><p>sender.wakeup()的作用是：消息达到了batch.size了，起来干活</p></li><li><p>KafkaThread：继承了Thread，构造函数可以传入线程名，和设置守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ioThread = <span class="keyword">new</span> KafkaThread(ioThreadName, <span class="keyword">this</span>.sender, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">this</span>.ioThread.start();</span><br></pre></td></tr></table></figure></li><li><p>RecordAccumulator：消息累加器，其实也就是常说的消息的内存缓冲区</p></li></ul><p>在前期基本工作做好后，kafka便可以开始发送了，发送过程比较复杂，首先要获取broker端集群信息，broker到底是个什么情况，地址是什么，有几台服务器，里面已有的topic，topic已有的分区，分区在broker的分布，ISR列表，OLR列表等等信息，这些都是发送之前要关心的</p><ul><li>Metadata：这些元信息都封装在了Metadata类中，Metadata还负责这些元信息的缓存及刷新</li><li><p>Cluster: Metadata中持有一个Cluster对象，kafka每一个broker都保存了topic的leader副本分区信息，producer只需要随机向一个broker发送请求就可以获取获取到，同时该对象还有每一个kafka broker节点的元信息，如ip端口等</p></li><li><p>TopicPartition：将topic和计算好的分区封装到一起</p></li><li>InterceptorCallback：如果没有拦截器，它就是Callback回调</li></ul><p>本文至此结束，接下来发送的具体源码将在下文揭晓</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[译]Kafka Consumer介绍:使用新的0.9版本kafka消费者</title>
      <link href="/2019/01/21/%E8%AF%91-Kafka-Consumer%E4%BB%8B%E7%BB%8D-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%840-9%E7%89%88%E6%9C%ACkafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2019/01/21/%E8%AF%91-Kafka-Consumer%E4%BB%8B%E7%BB%8D-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%840-9%E7%89%88%E6%9C%ACkafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0-9-consumer-client/" target="_blank" rel="noopener">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a></p></blockquote><p>Kafka创建之初，自带了用Scala编写的生产者和消费者客户端，随着时间的推移，我们开始认识到这些API的许多局限性。例如，我们有一个”high-level”消费者API，它支持消费者组和故障转移，但却不支持更多更复杂的使用场景。我们还有一个”简版”消费者API，它提供了完全的控制，但需要用户自己处理故障转移和错误。因此我们开始重新设计这些客户端，以开启许多旧客户端难以支持甚至不可能支持的用例，并建立一组我们能够长期支持的API</p><p>第一阶段是在0.8.1版本重写了的生产者API，最近发布的0.9版本完成了第二阶段，引入了新版消费者API，建立在一个kafka自身提供的新的组协调者协议之上，新的消费者带来了以下优势：</p><ul><li>新的消费者结合了”简版”和”高级”API的功能，同时提供了组协调者和低级别访问，以构建你自己的消费策略</li><li>减少依赖：新版消费者API使用原生java，不依赖Scala运行时环境或者Zookeeper，这使得它以一个轻量库包含在你的项目中</li><li>更安全：kafka 0.9中的安全扩展只支持新版消费者</li><li>新的消费者还增加了一组用于管理消费者进程组容错的协议。以前这个功能在java客户端中的实现很笨重(有许多和ZooKeeper的重量交互)，这种复杂的逻辑使得用其他语言构建时变得十分困难，随着新协议的引进，这变得容易的多，实际上我们已经将C client迁移到新协议上了</li></ul><p>即使消费者使用了重新设计的API和组协调者协议，这些概念并没有变，因此熟悉老消费者的用户理解它应该没有太多问题。但是，在组管理和线程模型方面有一些细微的细节需要特别注意。这篇教程的目的是覆盖new consumer的基本用法，并解释这些细节</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>深入代码之前，我们回顾一下基本概念。在kafka中，topic以partition为维度划分为一组日志，producer追加写入这些日志的尾部，消费者按自己的速度读取日志，kafka在消费者组间通过分布式分区扩展消息消费，消费者组是一组消费者共享的组标识，下图展示了一个topic，它有三个分区，还有一个消费者组，它有两个消费者成员，topic里的每一个分区只分配给组内的一个成员<br><img src="https://www.confluent.io/wp-content/uploads/2016/08/New_Consumer_figure_1.png" alt=""></p><p>老的消费者依赖Zookeeper管理组，新消费者用一个建立在kafka本身之上的组协调者协议。对每一个消费者组，一个kafka broker被选为组协调者。该协调者负责管理消费者组的状态，它主要的工作是在新消费者加入组时，原有消费者离开时，和topic元信息发生改变时调节分区分配，重新分配分区的行为称之为重平衡组</p><p>当组首次初始化，消费者通常会从分区的最早或最近位移开始读取消息，然后按顺序读取每个分区。随着消费者的运行，它会提交它已经成功处理的消息的位移，如下图，消费者消费的位置在6，它上一次提交的位移是1<br><img src="https://www.confluent.io/wp-content/uploads/2016/08/New_Consumer_Figure_2.png" alt=""></p><p>当一个分区重新分配给了组内的另一个消费者，初始的位移被设置到上一次提交的位移。如果上图中的消费者突然挂了，消费者组成员接管这个分区，位移从1开始消费。这种情况下，必须重新处理崩溃消费者分区的第6个位置</p><p>这张图里还展示了日志里的2个重点，日志末端位移(LEO)表示最后一条被写入日志的消息的位移，high watermark是最后一条被成功复制到副本的消息的位移。从消费者的角度来看，最重要的事情是你只能从high watermark的位置处开始读取，防止了消费者读取副本未同步完成，有可能丢失的消息</p><h1 id="配置与初始化"><a href="#配置与初始化" class="headerlink" title="配置与初始化"></a>配置与初始化</h1><p>在开始消费者学习之前，添加kafka-client依赖到你的项目，maven片段如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0-cp1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>和其它kafka-client一样，使用properties文件构造consumer，在下面的例子中，我们提供了一个使用消费者组的最小配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span><br><span class="line">props.put(&quot;group.id&quot;, &quot;consumer-tutorial&quot;);</span><br><span class="line">props.put(&quot;key.deserializer&quot;, StringDeserializer.class.getName());</span><br><span class="line">props.put(&quot;value.deserializer&quot;, StringDeserializer.class.getName());</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);</span><br></pre></td></tr></table></figure></p><p>和原来的消费者，生产者一样，我们需要为consumer配置一个broker初始化列表，让consumer发现集群的其余部分, 不需要提供集群里的所有server地址，消费者会从给定列表的broker中确定所有存活的broker集合，这里我们假设broker运行在本地。consumer还需要知道如何反序列化key和value。最终为了加入一个消费者组，我们需要指定gruop id。在接下来的学习中，我们将介绍更多的配置</p><h1 id="topic-订阅"><a href="#topic-订阅" class="headerlink" title="topic 订阅"></a>topic 订阅</h1><p>开始消费之前，你必须首先订阅你的应用要读取的topic，在下面的例子中，我们订阅了主题”foo”和”bar”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(“foo”, “bar”));</span><br></pre></td></tr></table></figure></p><p>订阅之后，消费者可以和组内其它成员协调以获取分区分配，这些都是在你消费数据之后自动处理的，之后我们会展示如何通过assign API手动分配，但要记住不能自动和手动混合分配。</p><p>订阅方法是不可增加的：你必须在列表中包含所有的你想消费的topic。你可以随时改变你已经订阅过的topic，以前订阅的topic都会在你重新调用subscribe方法之后覆盖</p><h1 id="基本的轮询"><a href="#基本的轮询" class="headerlink" title="基本的轮询"></a>基本的轮询</h1><p>消费者需要能够并行的获取数据，可能来自多个broker上的多个topic的多个分区。consumer使用类似unix poll或select风格的API来做这件事：一旦topic被注册，所有以后的协调，重平衡和数据获取都由一个基于在事件循环调用的poll方法来驱动的，这是一个能够用单线程处理IO的简单，高效的实现。</p><p>订阅topic之后，你需要开始时间循环，以分配到一个分区并开始获取数据，这听起来很复杂，但你只需要在循环里调用poll方法，然后consumer处理剩下的事情。每次调用poll方法，它会返回一组来自分配的分区里的消息(可能为空)，下面的例子展示了poll循环的基本用法，打印了offset和vlaue：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll方法基于当前位置获取数据，当消费者组首次创建，会根据reset策略设置位置(通常为每个分区设置成earliest或latest位移)。一旦消费者开始提交位移，然后每次rebalance会重置到上次提交的位置。poll方法的参数控制了当前位置的消息消费者需要阻塞的最大时间，一旦有消息可用，消费者立即返回，但如果没有任何消息，则会等待到给定的超时时间后返回</p><p>consumer对象被设计成在自己的线程中允许，这在内部没有同步机制的情况下对于多线程是不安全的，这也不是个好主意，在这个例子中，我们使用一个标志位，当应用关闭时终止poll循环。当标志位在另一个线程中被设置为false时，一旦poll返回就会终止，不管返回了什么消息，应用也会停止处理。</p><p>你应该在完成消费后关闭它，不仅仅是清理它使用的socket连接，它还提醒了消费者组它要从组中离开了</p><p>这里例子使用了一个相对较小的超时时间，来保证关闭consumer时没有太多的延迟。可选的，你可以使用一个很大的超时时间，并用wakeup方法结束循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) </span><br><span class="line">            System.out.println(record.offset() + <span class="string">": "</span>+record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;   </span><br><span class="line">    <span class="comment">// ignore for shutdown</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">consumer.close(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br></pre></td></tr></table></figure><p>我们将超时时间改为Long.MAX_VALUE，这基本意味着consumer无限的阻塞，直到返回下一批消息。不像前面的例子设置一个标志位那样，线程可以通过consumer.wakeup()触发一个shutdown事件来中断运行中的poll，并抛出WakeupException，这个方法是线程安全的。注意如果当前没有运行中的poll，这个异常将会延续到下次请求，在这个例子中我们捕获了这个异常防止它传播</p><h1 id="汇总到一起"><a href="#汇总到一起" class="headerlink" title="汇总到一起"></a>汇总到一起</h1><p>接下来的例子，我们将所有东西都放在一起构建一个简单的Runnable任务，该任务初始化消费者，订阅一组topic，无限循环地执行poll，直到在外面关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; topics;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConsumerLoop</span><span class="params">(<span class="keyword">int</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String groupId, </span></span></span><br><span class="line"><span class="function"><span class="params">                      List&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.topics = topics;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    props.put(“group.id”, groupId);</span><br><span class="line">    props.put(“key.deserializer”, StringDeserializer.class.getName());</span><br><span class="line">    props.put(“value.deserializer”, StringDeserializer.class.getName());</span><br><span class="line">    <span class="keyword">this</span>.consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      consumer.subscribe(topics);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">          Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          data.put(<span class="string">"partition"</span>, record.partition());</span><br><span class="line">          data.put(<span class="string">"offset"</span>, record.offset());</span><br><span class="line">          data.put(<span class="string">"value"</span>, record.value());</span><br><span class="line">          System.out.println(<span class="keyword">this</span>.id + <span class="string">": "</span> + data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">      <span class="comment">// ignore for shutdown </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    consumer.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试这个用例，你要运行release 0.9.0.0版本的kafka，和一个用字符串数据的topic，最简单的方式使用kafka-verifiable-producer.sh监本写一批数据到一个topic。为了更有意思，我们应该确保topic有多个分区，这样一个消费者就不需要做所有事（？？）。例如，一个broker和Zookeeper都运行在本地，你可能会做以下的事：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-topics.sh --create --topic consumer-tutorial --replication-factor 1 --partitions 3 --zookeeper localhost:2181</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-verifiable-producer.sh --topic consumer-tutorial --max-messages 200000 --broker-list localhost:9092</span></span><br></pre></td></tr></table></figure><p>然后我们创建一个小的驱动来创建一个含有三个消费者的消费者组，都订阅了我们刚刚创建的topic<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> numConsumers = <span class="number">3</span>;</span><br><span class="line">  String groupId = <span class="string">"consumer-tutorial-group"</span></span><br><span class="line">  List&lt;String&gt; topics = Arrays.asList(<span class="string">"consumer-tutorial"</span>);</span><br><span class="line">  ExecutorService executor = Executors.newFixedThreadPool(numConsumers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;ConsumerLoop&gt; consumers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numConsumers; i++) &#123;</span><br><span class="line">    ConsumerLoop consumer = <span class="keyword">new</span> ConsumerLoop(i, groupId, topics);</span><br><span class="line">    consumers.add(consumer);</span><br><span class="line">    executor.submit(consumer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (ConsumerLoop consumer : consumers) &#123;</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">      &#125; </span><br><span class="line">      executor.shutdown();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.awaitTermination(<span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子向线程池提交了3个consumer线程，每个线程都分配了一个id，这样你可以观察到是哪个线程在接收数据，当你关闭应用时，将会执行shutdown hook，它会用wakeup暂停三个线程，并等待它们关闭。运行之后，你讲看到许多来自线程中的数据，下面是一个样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">928</span>, value=<span class="number">2786</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">929</span>, value=<span class="number">2789</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">297</span>, value=<span class="number">891</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">930</span>, value=<span class="number">2792</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">298</span>, value=<span class="number">894</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">931</span>, value=<span class="number">2795</span>&#125;</span><br><span class="line"><span class="number">0</span>: &#123;partition=<span class="number">1</span>, offset=<span class="number">278</span>, value=<span class="number">835</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">932</span>, value=<span class="number">2798</span>&#125;</span><br><span class="line"><span class="number">0</span>: &#123;partition=<span class="number">1</span>, offset=<span class="number">279</span>, value=<span class="number">838</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">299</span>, value=<span class="number">897</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">300</span>, value=<span class="number">900</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">301</span>, value=<span class="number">903</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">302</span>, value=<span class="number">906</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">303</span>, value=<span class="number">909</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">304</span>, value=<span class="number">912</span>&#125;</span><br><span class="line"><span class="number">0</span>: &#123;partition=<span class="number">1</span>, offset=<span class="number">280</span>, value=<span class="number">841</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">933</span>, value=<span class="number">2801</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这些展示了三个分区交叉消费情况，每个分区分配给了一个消费者线程，在每个分区里，正如预期的显示了offset的增加，你可以用Ctrl+C或者通过你的IDE来终止进程。</p><h1 id="消费者活力-求生欲"><a href="#消费者活力-求生欲" class="headerlink" title="消费者活力(求生欲?)"></a>消费者活力(求生欲?)</h1><p>当作为消费者组的一部分时，每个消费者都会从其订阅的主题中分配分区的一个子集。通常是分区上的一组锁，只要持有锁，就没有其他消费者读取它们。当你的消费者是健康的，这就是你想要的结果。这是你避免重复消费的唯一方式。但如果消费者由于机器或应用死亡，你需要锁被释放，以便分配给其它的健康消费者</p><p>笔者解读：对于一个消费者组来说，一个分区只能被一个消费者消费，作者想表达的是读取时加锁，防止别的消费者读取，实现了消费者之间避免重复消费</p><p>kafka的组协调者协议使用心跳机制来解决这个问题，每次rebalance之后，当代所有的消费者开始发送周期性的心跳给组协调者，只要协调者继续接收心跳，它就会假定消费者是健康的，每收到一次心跳，协调者就会开启或重置一个计时器，如果计时器过期了还没有心跳，协调者就会标记这个消费者死亡了，给组内其余成员发送重新入组的信号，以便分区被重新分配，这个计时器的间隔被称为session timeOut，在客户端通过以下方式配置：session.timeout.ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(“session.timeout.ms”, “<span class="number">60000</span>”);</span><br></pre></td></tr></table></figure></p><p>会话过期保证在机器，应用崩溃，或消费者与协调者之间的网络被隔离的情况下释放锁，但是应用失败有点棘手，因为消费者仍在发送心跳给协调者，并不表明应用时健康的</p><p>consumer的poll方法旨在解决这个问题，当你调用poll或者其它阻塞API时，所有的网络IO都在前台完成(？？)。consumer从不使用后台线程，这表示在你调用poll时只有心跳发送给了协调者，当你的应用停止poll(抛出异常或是下有系统挂了)时，就不再发送心跳，会话就会过期，组内开始rebalance。<br>唯一的问题是如果消费者处理消息的时间超过了会话过期时间就会触发一次假的rebalance，你应该因此将session timeout设置的足够大，来使这不太可能发送，默认是30秒，但设置成几分钟也是没道理的。更大的session timeout的缺点是，协调者将会更多的时间检测到消费者真的挂了的情况</p><h1 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h1><p>当消费者组首次创建，根据auto.offset.reset设置的值来初始化位移，一旦消费者开始执行，它会根据应用需要定期的提交位移。在每个后来的rebalance之后，分区的位移会被设置到上一次组提交的位置上，如果consumer在成功处理消息，却又在提交之前崩溃了，结果是另一个consumer会重复复工作。你提交的越频繁，你在崩溃期间看到的重复消费就越少。</p><p>在目前为止的例子中，我们假设自动提交是开启的。当前enable.auto.commit为true(默认值),consumer会根据auto.commit.interval.ms设置的值，周期性的自动提交位移。通过较少提交间隔的方式，你可以限制在consumer崩溃时的重复消费数量。</p><p>为了使用提交的API，首先你应该禁止位移自动提交，设置enable.auto.commit为false</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 8日期类学习</title>
      <link href="/2019/01/18/java-8%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/01/18/java-8%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<blockquote><p>最近开发过程中遇到了很多时间类处理，由于对Calender类不熟悉，我说这个类设计的烂，谁赞成，谁反对？也被推荐过joda-time类库，鉴于项目用的都是java 8了，是时候了解一下java.time包下的类了</p></blockquote><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><h2 id="java-8-日期类的优势"><a href="#java-8-日期类的优势" class="headerlink" title="java 8 日期类的优势"></a>java 8 日期类的优势</h2><p>用完java 8的API之后，只有一个感觉，爽，没有啰嗦的方法，很多静态工厂方法，of，from见名知意，用到后面，一些api自己都可以猜出来了，同时api更人性化，例如对比之前的获取月份方法，是从0开始，机械化的思维，反观java 8，我能通过getMonthValue直接获取，无须+1</p><p>对于joda-time，从个人角度讲，实在不想再去记忆一套api，同时从项目角度来说，我能用jdk实现的，为什么要依赖第三方jar包，这点对于实际开发来说更重要。但对于还在使用java 8以下版本的同学joda-time还是值得推荐的</p><h2 id="API的记忆方法"><a href="#API的记忆方法" class="headerlink" title="API的记忆方法"></a>API的记忆方法</h2><p>在Effective java读书笔记一文中，静态方法相较构造方法有更多的优势，尤其是在提供给开发者使用时。java 8这方面做得很好，of，from，parse，format，minus，plus等等方法，一眼就知道作者的意图</p><h2 id="时间分类"><a href="#时间分类" class="headerlink" title="时间分类"></a>时间分类</h2><p>java 8提供了3个基础时间类：LocalDate, LocalDateTime, LocalTime，分别代表日期，日期+时间，时间(时分秒)</p><p>同时三者之间可以部分转换，之所以称之为部分，很简单的例子是日期无法直接转换为具体的日期+时间，因为它缺少时分秒，这可以理解为一种精度损失，当然你可以通过默认值来补全</p><p>Instant表示瞬时时间，精确到毫秒，可用于记录时间戳</p><p>java 8支持通过时区id，时区偏移量来获取时间</p><p>在实际开发中我们关注的有以下几个方面的时间：</p><ol><li>时间戳，既有毫秒，也有秒，秒主要是PHP等服务返回的标准时间戳</li><li>Date，不要忘了数据库对应的实体中，使用的时间对象仍是Date</li><li>待格式化的字符串，很常见的需求，将字符串解析为时间，或是将时间格式化为文本<br>这几个方面时间的互相转换也需要关注</li></ol><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="now"><a href="#now" class="headerlink" title="now"></a>now</h3><p>now方法用于获取日期类的当前值，例如LocalDate获取当前日期，LocalTime获取当前时间的时分秒等信息</p><h3 id="获取年月日"><a href="#获取年月日" class="headerlink" title="获取年月日"></a>获取年月日</h3><p>根据常识，仅LocalDate, LocalDateTime可以获取年月日，分别由getYear,getMonthValue,getDayOfMonth获取，时分秒的获取方式同理LocalDateTime</p><h3 id="获取自1970-01-01T00-00-00的毫秒数，秒数，天数"><a href="#获取自1970-01-01T00-00-00的毫秒数，秒数，天数" class="headerlink" title="获取自1970-01-01T00:00:00的毫秒数，秒数，天数"></a>获取自1970-01-01T00:00:00的毫秒数，秒数，天数</h3><p>不用死记硬背，只要想清楚这几个类分别代表了什么类型的时间即可推断出api<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant.now().toEpochMilli();</span><br><span class="line">LocalDateTime.now().toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">LocalDate.now().toEpochDay();</span><br></pre></td></tr></table></figure></p><p>ZoneOffset.ofHours(8)可以理解为北京时间位于东八区</p><h3 id="获取前一天，一个月，一年等等"><a href="#获取前一天，一个月，一年等等" class="headerlink" title="获取前一天，一个月，一年等等"></a>获取前一天，一个月，一年等等</h3><p>记住两个单词即可，minus表示减，plus表示加<br>至于你想加减些什么，首先要确定要加减的单位是什么，比如分钟，那肯定是在LocalDateTime，LocalTime里找，加年，加月同理，剩下的api就不啰嗦了，授人以鱼不如授人以渔，读者有兴趣自己探索。</p><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="文本转时间"><a href="#文本转时间" class="headerlink" title="文本转时间"></a>文本转时间</h3><p>parse用于处理从文本到日期的转换，根据DateTimeFormatter的格式解析成日期<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate.parse(<span class="string">"2019-01-11"</span>, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>))</span><br></pre></td></tr></table></figure></p><p>yyyy-MM-dd是默认的格式，可以省略第二个参数，类似的HH:mm:ss在转换为时分秒时也可以省略</p><h3 id="毫秒时间戳转时间"><a href="#毫秒时间戳转时间" class="headerlink" title="毫秒时间戳转时间"></a>毫秒时间戳转时间</h3><p>注意两点：</p><ol><li><p>Instant用于表示瞬时值，它和秒，毫秒是相关联的，再将Instant转换为LocalDateTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = <span class="number">1548154964271L</span>;</span><br><span class="line">Instant instant = Instant.ofEpochMilli(time);</span><br><span class="line">LocalDateTime dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());</span><br></pre></td></tr></table></figure></li><li><p>需要判断时间戳是毫秒还是秒，PHP等语言只能精确到秒，请求这类接口时需注意<br>给出一个转换方法示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_TIME_STAMP = <span class="number">10000_000_000L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MIN_TIME_STAMP = <span class="number">1000_000_000L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Instant <span class="title">transToInstant</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; MAX_TIME_STAMP &amp;&amp; time &gt; MIN_TIME_STAMP) &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochSecond(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; MAX_TIME_STAMP * <span class="number">1000</span> &amp;&amp; time &gt; MIN_TIME_STAMP * <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal time value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="与Date类的转换"><a href="#与Date类的转换" class="headerlink" title="与Date类的转换"></a>与Date类的转换</h3><p>记住一点，旧版的Date与java 8中的日期类的转换桥梁是Instant<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date date = Date.from(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br></pre></td></tr></table></figure></p><h2 id="获取时间段"><a href="#获取时间段" class="headerlink" title="获取时间段"></a>获取时间段</h2><p>Period和ChronoUnit都可以做到计算时间段，下面以计算两个时间时间的天数为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.between(LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">19</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">long</span> days = ChronoUnit.DAYS.between(LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">19</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>java 8时间类的使用写到这里告一段落，关于时区的使用，也见缝插针的介绍了下，写这篇文章对笔者最大的挑战是表达能力，api很多，我想表达的是有规律的使用api，而不是死记硬背，最后分享一个自己写的DateUtils</p><h1 id="DateUtils"><a href="#DateUtils" class="headerlink" title="DateUtils"></a>DateUtils</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 舍弃对Calendar，joda-time的依赖，用java 8重写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangjie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERAL_PATTERN = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERAL_DATE_PATTERN = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_TIME_STAMP = <span class="number">10000_000_000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MIN_TIME_STAMP = <span class="number">1000_000_000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 分别获取年月日的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;L, M, R&gt; <span class="function">Triple&lt;Integer, Integer, Integer&gt; <span class="title">getYearMonthDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableTriple.of(today.getYear(), today.getMonthValue(), today.getDayOfMonth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取日期文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> today.format(DateTimeFormatter.ofPattern(GENERAL_DATE_PATTERN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取时间本文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateTimeText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.format(DateTimeFormatter.ofPattern(GENERAL_PATTERN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据毫秒数获取时间文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateTimeText</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.format(DateTimeFormatter.ofPattern(GENERAL_PATTERN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定日期是否是今日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(String time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(time).isEqual(today);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前时间戳是否是今天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        LocalDate date = LocalDateTime.ofInstant(transToInstant(time), ZoneId.systemDefault()).toLocalDate();</span><br><span class="line">        <span class="keyword">return</span> date.isEqual(today);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取n天之前至今的时间段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;Long, Long&gt; <span class="title">getDaysAgoTime</span><span class="params">(Integer days)</span> </span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.now().minusDays(days);</span><br><span class="line">        <span class="keyword">long</span> begin = localDate.atTime(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">long</span> end = localDate.atTime(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">return</span> ImmutablePair.of(begin, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段区间 00:00:00 - 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;Long, Long&gt; <span class="title">getDurationPair</span><span class="params">(String beginStr, String endStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = LocalDate.parse(beginStr, DateTimeFormatter.ofPattern(GENERAL_DATE_PATTERN)).atTime(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">long</span> end = LocalDate.parse(endStr, DateTimeFormatter.ofPattern(GENERAL_DATE_PATTERN)).atTime(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">return</span> ImmutablePair.of(begin, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段之间的天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getBetweenDays</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChronoUnit</span><br><span class="line">                .DAYS</span><br><span class="line">                .between(</span><br><span class="line">                        LocalDateTime.ofInstant(transToInstant(start), ZoneId.systemDefault()),</span><br><span class="line">                        LocalDateTime.ofInstant(transToInstant(end), ZoneId.systemDefault())</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段之间的天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getBetweenDays</span><span class="params">(String start, String end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChronoUnit.DAYS.between(LocalDate.parse(start), LocalDate.parse(end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段之间的所有日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getBetweenDates</span><span class="params">(String start, String end)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LocalDate startDate = LocalDate.parse(start);</span><br><span class="line">        LocalDate endDate = LocalDate.parse(end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> distance = ChronoUnit.DAYS.between(startDate, endDate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (distance &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (distance == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(start);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream.iterate(startDate, d -&gt; d.plusDays(<span class="number">1</span>)).limit(distance + <span class="number">1</span>).forEach(f -&gt; &#123;</span><br><span class="line">            list.add(f.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Guava实现大数据量sql分段批量插入</title>
      <link href="/2019/01/18/Guava%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8Fsql%E5%88%86%E6%AE%B5%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"/>
      <url>/2019/01/18/Guava%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8Fsql%E5%88%86%E6%AE%B5%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>最近做一个数据拉取的需求，由于有上万的数据量，想到分段批量插入数据库，经同事推荐，Guava有好的工具类，特此记录并分享给大家</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>一开始在网上搜索，基本用到的都是List接口的sublist方法，第一版自己实现了一遍，功能没问题，但很啰嗦，下面介绍guava的partition方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分段批量插入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticketLists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batchSegmentInsertList</span><span class="params">(List&lt;TicketList&gt; ticketLists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(ticketLists))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;TicketList&gt;&gt; lists = Lists.partition(ticketLists,<span class="number">1000</span>);</span><br><span class="line">    lists.forEach(tickets -&gt;&#123;</span><br><span class="line">        ticketListDao.batchInsert(tickets);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是笔者实际开发中的代码，首先需要自己在mybatis中实现批量插入，然后使用Lists.partition方法对原有的集合做分段，1000代表分段大小</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>进入partition源码，省略中间多余过程，最终发现一个静态类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Partition</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>其实现了AbstractList，有趣的是泛型参数是List<t>，结合ArrayList类的实现，该泛型参数代表集合的一个元素，说明Partition本身是一个集合，里面的元素是一个个的小集合，结合我们要实现的功能，说明这就是我们要的对大集合切割之后的每一个小集合，而下面的get方法也佐证了我们的猜想</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index, size());</span><br><span class="line">  <span class="keyword">int</span> start = index * size;</span><br><span class="line">  <span class="keyword">int</span> end = Math.min(start + size, list.size());</span><br><span class="line">  <span class="keyword">return</span> list.subList(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还可以看出Partition底层还是用的sublist方法，不过最后我想说的还是那句老话，不要重复造轮子，遇到这种大批量sql分段插入，你肯定不是第一个人遇到，多用大牛写好的轮子，同时去看看他们是如何实现的，解放生产力的同时，也提升自己的技术</p>]]></content>
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之自定义starter</title>
      <link href="/2019/01/16/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
      <url>/2019/01/16/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
      <content type="html"><![CDATA[<blockquote><p>为何要自定义starter，使用场景是什么，又该如何去自定义呢？本文围绕这几个方面展示自定义starter的过程</p></blockquote><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在Spring-Boot实践系列文章中，对日常开发中的许多功能做了统一封装，那么在分布式开发的组织架构下，开发组内个人单独使用是没有意义的，应该将其封装成一个SDK，发布到maven私服，供大家使用，分享精神先放一边，这样做的好处是统一标准，提升开发效率，同时又需要投入部分人力维护这个项目，不断更新和修复。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>项目是一个多模块结构，不同的公共模块封装各自的公用功能，例如可以把统一的接口请求，返回，日志等放到web模块，对监控有要求的可以抽取一个监控模块，依赖了中间件时，对该中间的公用配置抽取一个模块。</p><p>项目名称可参考spring-cloud组件，例如叫base-starter-web, base-start-logger等</p><h1 id="封装starter"><a href="#封装starter" class="headerlink" title="封装starter"></a>封装starter</h1>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之多数据源最佳实践</title>
      <link href="/2019/01/05/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/01/05/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<blockquote><p>多数据源主要用于mysql主从，多库等场景，笔者初始接触时也在网上找了很多资料如何配置，但做法百花齐放，有很多用到了ThreadLocal，注解，数据源路由等技术，最终选择了一个简单，易用，易理解的方式：每一个数据源只扫描自己的mapper</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基于以上思想，只需要以下步骤：</p><ol><li>配置文件中采用不同的前缀配置各个数据源</li><li>为每个数据源初始化DataSource，SqlSessionFactory，TransactionManager</li><li>每个数据源都有自己的配置，扫描自己的mapper.xml，DAO接口</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p>注意，笔者遇到的情况是多库，以订单库和用户库举例，如果是主从，可以起名master，slave<br>配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#db1</span><br><span class="line">spring.datasource.default.url = jdbc:mysql://localhost:3306/order?characterEncoding=utf-8&amp;connectTimeout=2000&amp;socketTimeout=2000&amp;zeroDateTimeBehavior=convertToNull</span><br><span class="line">spring.datasource.default.username = root</span><br><span class="line">spring.datasource.default.password = 123</span><br><span class="line"></span><br><span class="line">#db2</span><br><span class="line">spring.datasource.user.url = jdbc:mysql://localhost:3306/user?characterEncoding=utf-8&amp;connectTimeout=2000&amp;socketTimeout=2000&amp;zeroDateTimeBehavior=convertToNull</span><br><span class="line">spring.datasource.user.username = root</span><br><span class="line">spring.datasource.user.password = 123</span><br></pre></td></tr></table></figure><h3 id="配置数据源相关对象"><a href="#配置数据源相关对象" class="headerlink" title="配置数据源相关对象"></a>配置数据源相关对象</h3><h4 id="抽取公共类"><a href="#抽取公共类" class="headerlink" title="抽取公共类"></a>抽取公共类</h4><p>如果数据源很多，建议抽取公共类，封装一些公共方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource 数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location mapper.xml位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">(DataSource dataSource, String location)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setConfiguration(configuration());</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver()</span><br><span class="line">                .getResources(location));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置下划线转驼峰</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Configuration <span class="title">configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置主数据源"><a href="#配置主数据源" class="headerlink" title="配置主数据源"></a>配置主数据源</h4><p>将order库作为项目的主数据源,@MapperScan用于扫描DAO接口，MAPPER_LOCATION传入父类指定mapper.xml位置<br>同时@Primary标注这是我们项目的主数据源<br><code>@ConfigurationProperties(&quot;spring.datasource.default&quot;)</code> 表示数据源配置采用的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.ttyc.dao.order"</span>, sqlSessionFactoryRef = <span class="string">"defaultSqlSessionFactory"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataSourceConfig</span> <span class="keyword">extends</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_LOCATION = <span class="string">"classpath:mapper/order/*.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.default"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">defaultDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"defaultSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">defaultSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"defaultDataSource"</span>)</span> DataSource defaultDataSource)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSessionFactory(defaultDataSource, MAPPER_LOCATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"defaultTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">defaultTransactionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"defaultDataSource"</span>)</span> DataSource defaultDataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(defaultDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理配置user库数据源，只不过去除@Primary注解，至此配置结束</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>正常编程即可，因为数据源已经按路径扫描了DAO接口和mapper.xml文件</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>以微服务的思想，多库是不应该存在的， 每个服务应该数据自治，职责单一，对于user库应该调用用户微服务接口，而不应该访问用户DB，造成耦合，目前笔者遇到的需求属于临时需求，并且将来会废弃该接口，所以从成本考虑，采用直接访问DB的形式，希望大家引以为戒！</p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-boot实践之请求日志切面</title>
      <link href="/2019/01/02/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97%E5%88%87%E9%9D%A2/"/>
      <url>/2019/01/02/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97%E5%88%87%E9%9D%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>记录请求日志切面的写法，和别人写的相比并无特殊之处</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h2><p>将controller中方法参数作为请求参数，返回值作为响应，这样做的前提是请求参数和返回值都已使用javabean封装，不一定适合每个人</p><h2 id="耗时统计"><a href="#耗时统计" class="headerlink" title="耗时统计"></a>耗时统计</h2><p>tomcat为每个请求分配一个线程，自然想到使用ThreadLocal保存计时器，最后不要忘了remove</p><h2 id="HttpServletRequest对象的获取"><a href="#HttpServletRequest对象的获取" class="headerlink" title="HttpServletRequest对象的获取"></a>HttpServletRequest对象的获取</h2><p>直接注入即可，Spring底层也是用ThreadLocal实现的，具体实现参考RequestContextHolder</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;StopWatch&gt; timer = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程安全，可直接注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.ttyc..controller.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeRequest</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        timer.get().start(<span class="string">"requestTimeKeeperTask"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"request url: &#123;&#125;, \nparams are &#123;&#125;"</span>, request.getRequestURI(), JSON.toJSONString(joinPoint.getArgs()[<span class="number">0</span>]));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"转换请求参数时异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"controller()"</span>, returning = <span class="string">"response"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterResponse</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> latency = timer.get().getTotalTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"response &#123;&#125;\nlatency is &#123;&#125;ms"</span>, JSON.toJSONString(response), latency);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"转换结果时异常"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            timer.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"controller()"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrows</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> latency = timer.get().getTotalTimeMillis();</span><br><span class="line"></span><br><span class="line">        log.warn(<span class="string">"请求异常，错误信息为：&#123;&#125;\n 耗时&#123;&#125;ms"</span>, ex.getMessage(), latency);</span><br><span class="line"></span><br><span class="line">        timer.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective-java读书笔记(三)：类和接口</title>
      <link href="/2018/11/28/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/11/28/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="使类和接口的可访问性最小化"><a href="#使类和接口的可访问性最小化" class="headerlink" title="使类和接口的可访问性最小化"></a>使类和接口的可访问性最小化</h1><p>模块设计原则：对外隐藏内部数据和实现细节，把api和他的实现隔离开来，模块之间通过api通信，一个模块不需要知道其它模块的内部细节，这称之为封装。</p><p>封装有效地让各模块直接解耦，解耦之后模块可以独立的开发，测试，优化，使用及修改。</p><ol><li>尽可能地使每个类或者成员不被外界访问<ol><li>类或接口尽可能的做成包级私有的，在以后的版本中，可以对他修改</li><li>如果你把类做成公有的，你就有责任永远对它负责，保证后续版本的兼任性</li><li>如果一个类只在某个类中使用，则考虑使用嵌套类(nested-class)</li></ol></li></ol><p>如果</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective java读书笔记(二)：对象通用方法</title>
      <link href="/2018/11/26/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/26/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="对象通用方法"><a href="#对象通用方法" class="headerlink" title="对象通用方法"></a>对象通用方法</h1><h2 id="覆盖equals时的约定"><a href="#覆盖equals时的约定" class="headerlink" title="覆盖equals时的约定"></a>覆盖equals时的约定</h2><p>当类具有特有的”逻辑相等”概念时，必须覆盖equals方法，这样也可以使这个类作为map的key，或者set中的元素</p><p>当对象非null时，equals方法满足以下四个特性：</p><ol><li>自反性：<code>x.equals(x)=true</code></li><li>对称性：<code>x.equals(y)=true</code>时，<code>y.equals(x)</code>必须为true</li><li>传递性：x=y，y=z，则x=z</li><li>一致性：<code>x.equals(y)</code>在多次调用后返回相同的值</li></ol><p>理解即可，不必要记忆</p><h3 id="高效的编写equals方法"><a href="#高效的编写equals方法" class="headerlink" title="高效的编写equals方法"></a>高效的编写equals方法</h3><p>首先了解一个小知识点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span> <span class="keyword">instanceof</span> Object = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>null不属于任何一个类型，所以对equals方法传入的对象不必做空指针判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> MyClass) &#123;</span><br><span class="line">        MyClass castObj = (MyClass)anObject;</span><br><span class="line">    <span class="comment">// 自己的判断逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写步骤"><a href="#编写步骤" class="headerlink" title="编写步骤"></a>编写步骤</h4><ol><li>首先用==检查参数是否是当前对象</li><li>判断参数是否是要判断的类型，</li><li>将对象强转成要比较的对象类型</li><li>根据类中的字段编写自己的判断逻辑，返回相应的true或false</li></ol><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h3><p>相信很多新手同学分不清这二者的区别，以及使用场景，二者区别如下：</p><ol><li><p>先说基本类型的==判断：值相等就返回true</p></li><li><p>再说引用类型的==：指向同一个对象才返回true</p></li><li><p>最后是equals：在Object里，它和==时一样的，但是类可以有自己的判断依据，比如String类</p></li></ol><h4 id="包装类的比较"><a href="#包装类的比较" class="headerlink" title="包装类的比较"></a>包装类的比较</h4><p>问题：<code>Integer i = 1, Integer j = 1</code>,如何比较二者是否相等?</p><p>答案是<code>i.equals(j)</code>,切不可写成<code>i==j,因为Integer内部采用了缓存，-128至127之间的数字被视为同一个对象，此时是可以通过==判断两个数字是否相等，但这只是假象，超过这个区间的数字就会返回</code>false</p><h2 id="覆盖equals是同时覆盖hashcode"><a href="#覆盖equals是同时覆盖hashcode" class="headerlink" title="覆盖equals是同时覆盖hashcode"></a>覆盖equals是同时覆盖hashcode</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>Java规范中包含以下约定：</p><ol><li>只要equals中用来判断两个对象是否相等的字段没有发生改变，那么调用多少次返回的结果都应该相同</li><li>如果通过equals判断出两个对象相等，那么它们的hashcode方法的返回值一定相等；如果不相等，那么hashcode方法的返回值不一定不等，但这必然降低了散列表的性能</li></ol><h3 id="编写hashcode方法"><a href="#编写hashcode方法" class="headerlink" title="编写hashcode方法"></a>编写hashcode方法</h3><p>hashcode方法编写的好坏，直接影响对象能否在集合中均匀分布，具体的编写方法见书41页，这里记下注意的几点：</p><ol><li>冗余字段不参与计算与比较，例如单价，数量，总价三者的关系，很明显总价可以通过另外二者计算出来，那么总价不必参与计算hashcode的过程，同时必须也不能参数equals的比较过程</li></ol><h2 id="覆盖toString方法"><a href="#覆盖toString方法" class="headerlink" title="覆盖toString方法"></a>覆盖toString方法</h2><p>toString方法的作用显而易见，如果不覆盖Object中的toString方法，返回<code>类名@对象hashcode十六进制值</code>的表现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><p>在实际开发中，toString用于记录日志是必不可少，例如打印用户信息，如果输出原始形式，则毫无价值，我们更关系的是用户id，用户名等关键信息</p><h2 id="谨慎覆盖clone方法"><a href="#谨慎覆盖clone方法" class="headerlink" title="谨慎覆盖clone方法"></a>谨慎覆盖clone方法</h2><h2 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h2>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective java读书笔记(一)：对象的创建与销毁篇</title>
      <link href="/2018/11/23/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%AF%87/"/>
      <url>/2018/11/23/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="对象的创建与销毁篇"><a href="#对象的创建与销毁篇" class="headerlink" title="对象的创建与销毁篇"></a>对象的创建与销毁篇</h1><h2 id="使用静态工厂创建对象"><a href="#使用静态工厂创建对象" class="headerlink" title="使用静态工厂创建对象"></a>使用静态工厂创建对象</h2><p>创建一个对象最常用的方式是构造方法，但有时也要考虑使用静态工厂创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"tom"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态工厂的好处有三:</p><ol><li>有名称，不同于构造方法，静态工厂作为一个普通的静态方法，可以使用名称更清晰的表达作者的想法，对比多个构造方法的情况，往往读者看见多个不同参数类型，不同顺序的构造方法时，不知道它们是干什么的，静态工厂使用方法名提高了代码可读性，私以为在企业开发中，多人合作时，面对复杂的业务逻辑，可读性尤为重要</li><li>不必每次都创建一个对象，或者说对象可以被重复利用，例如初始化一个数据库连接对象，不必每次设置用户名密码创建这个对象</li><li>可以使用多态，返回子类类型的对象，例如通过参数来判断应该返回哪种子类型</li></ol><p>同时它也是有缺点的，在看到构造方法时，我们能一眼看出是用于创建对象，但是静态工厂则不一定，因此静态工厂的方法名遵从一些惯用名称：valueOf，getInstance，newInstance等等</p><h2 id="构造方法参数过多时，使用Builder"><a href="#构造方法参数过多时，使用Builder" class="headerlink" title="构造方法参数过多时，使用Builder"></a>构造方法参数过多时，使用Builder</h2><h3 id="Builder是什么"><a href="#Builder是什么" class="headerlink" title="Builder是什么"></a>Builder是什么</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User tom = User.builder().name(<span class="string">"tom"</span>).age(<span class="number">18</span>).build();</span><br></pre></td></tr></table></figure><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>静态工厂和构造方法都不能很好的解决参数过多时，参数是否必传问题，通常先写一个大而全的参数方法，然后提供多个部分参数方法。</p><p>以静态工厂为例，比如：有三个参数，其中address，age可不传，先写出一个三参数的，然后下面的方法传null来调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, Integer age, String address)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createUser(name,age, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createUser(name, <span class="keyword">null</span>,address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的弊端很明显，参数多了不利于扩展，不扩展又会导致调用者必须传一些无用的参数，并且代码难以阅读，调用方还容易出错</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-JavaBean"><a href="#1-JavaBean" class="headerlink" title="1.JavaBean"></a>1.JavaBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setXxx();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>通过setter可以很好的避免上述问题，但书中所说JavaBean本身时可变类，无法成为不可变类，在这set的过程中有可能会产生线程安全问题，笔者认为实际业务开发中JavaBean多用于方法形参，属于线程私有，除非定义在成员变量位置，否则线程安全问题极低</p><h4 id="2-Builder模式"><a href="#2-Builder模式" class="headerlink" title="2.Builder模式"></a>2.Builder模式</h4><p>由于Builder模式代码编写很多，我们在实际开发中使用lombok可以更快的达到目的，事先引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaBean类上加入<code>@Builder</code>注解，即可像开头那样调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果类的构造方法或者静态工厂有多个参数时，优先考虑Builder模式，特别是某些参数可选时</p><h2 id="使用枚举来创建单例模式"><a href="#使用枚举来创建单例模式" class="headerlink" title="使用枚举来创建单例模式"></a>使用枚举来创建单例模式</h2><p>使用工厂模式创建单例模式分为：懒汉式，饿汉式。使用枚举作为替代主要有以下两个原因</p><ol><li>懒汉式通常需要与double-check配合使用来保证线程安全，而枚举本身就是线程安全的</li><li>工厂模式在对象反序列化无法保证单例，需要重写readResolve，而枚举自动实现了反序列化</li></ol><h3 id="使用枚举创建User单例"><a href="#使用枚举创建User单例" class="headerlink" title="使用枚举创建User单例"></a>使用枚举创建User单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    UserSingleton() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的线程安全性"><a href="#枚举的线程安全性" class="headerlink" title="枚举的线程安全性"></a>枚举的线程安全性</h3><p>枚举类在反编译之后，是一个不可变类，因此它是线程安全的</p><h3 id="测试饿汉式的反序列化失效情况"><a href="#测试饿汉式的反序列化失效情况" class="headerlink" title="测试饿汉式的反序列化失效情况"></a>测试饿汉式的反序列化失效情况</h3><p>使用饿汉式创建User单例模式类,并为<code>User</code>类实现<code>Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserSingletonFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    User instance = UserSingletonFactory.getInstance();</span><br><span class="line">    User other = UserSingletonFactory.getInstance();</span><br><span class="line">    <span class="comment">// 此时单例模式的结果返回true</span></span><br><span class="line">    System.out.println(instance == other);</span><br><span class="line">    </span><br><span class="line">    ObjectOutputStream oos =</span><br><span class="line">            <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"obj.txt"</span>)));</span><br><span class="line">    oos.writeObject(instance);</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois =</span><br><span class="line">            <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"obj.txt"</span>)));</span><br><span class="line">    User user = (User) ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line"></span><br><span class="line">    System.out.println(instance == user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果最后的输出为false</p><h2 id="通过私有的构造方法让类不可实例化"><a href="#通过私有的构造方法让类不可实例化" class="headerlink" title="通过私有的构造方法让类不可实例化"></a>通过私有的构造方法让类不可实例化</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li>私有的构造方法，指用private修饰构造方法</li><li>不可实例化，通过私有的构造方法，让类无法产生对象</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>作为一些工具类，例如JDK中的<code>Math</code>类，只希望使用它的静态成员变量和静态方法，所以我们可以看到源码中的Math类构造方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Don't let anyone instantiate this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Math</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>原则：尽量重用对象，如果是不可变类产生的对象，那它始终可以被重用</p><p>典型的不可变类如<code>String</code>,只要是相同的字符串，内存中只有一个String对象</p><p>同时有静态工厂和构造器的不可变类，优先使用静态工厂创建对象，静态工厂不会重复创建对象，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean.valueOf(<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>优先于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Boolean(<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>除了不可变对象，还可以重用那些被认为不会被修改的可变对象，书中用一个日期类举例，将只需要初始化一次的对象放在静态代码块中，在实际开发中，诸如数据库连接池，http client请求线程池等重量级的对象，为了提高性能，必须重用</p><h2 id="清理过期的对象引用"><a href="#清理过期的对象引用" class="headerlink" title="清理过期的对象引用"></a>清理过期的对象引用</h2><p>为了防止内存泄漏，需要将不再使用的对象，解除引用，即obj = null，将引用指向空，让GC回收对象</p><p>例如List的remove方法中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br></pre></td></tr></table></figure><p>需要注意的是清除对象引用是在特殊情况下的处理，并不是一种规范，我们在实际开发中并不需要小心翼翼的处理</p><h3 id="何时清除对象引用"><a href="#何时清除对象引用" class="headerlink" title="何时清除对象引用"></a>何时清除对象引用</h3><p>如果类自己管理内存空间，如<code>ArrayList</code>内部使用<code>Object</code>数组存储，一旦其中的元素被删除，则需要清空对象引用</p><h3 id="避免使用finalize方法"><a href="#避免使用finalize方法" class="headerlink" title="避免使用finalize方法"></a>避免使用finalize方法</h3><p>老生常谈的<code>finalize</code>方法问题，不要尝试调用它，GC并不会立即回收对象，甚至不保证执行。经过测试，调用finalize还会降低性能，花费更多的时间销毁对象，书中后面讲解的内容实用性太低，不做记录</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>11.22日映客架构师讲座</title>
      <link href="/2018/11/22/11.22%E6%97%A5%E6%98%A0%E5%AE%A2%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%B2%E5%BA%A7/"/>
      <url>/2018/11/22/11.22%E6%97%A5%E6%98%A0%E5%AE%A2%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%B2%E5%BA%A7/</url>
      <content type="html"><![CDATA[<ol><li>不要把每一个单独的服务优化到极致，心中要有一个架构的演进方向，根据这个方向优化分散的点，如存储，mq，服务等，最终达到一个我们心中理想的架构。同时要融入到公司，理解业务，要有将产品带向好的方向的心态，不是完成上级的任务，产品的需求，常年下来没有进步</li><li>业务服务不要直连DB，应该抽取成基础服务，业务服务都是用基础服务拼接而成的，这样做利于基础服务的扩展</li><li>作为基础服务一定要考虑限流，服务的熔断和降级</li><li>要保证业务的关键路径高可用，其他服务挂了，不能影响它，例如淘宝，下单流程，确认收货流程一定是可用的，提高用户体验</li><li>服务的取舍，比如手机直播，100w用户在一个直播间，当前用户只关心自己送出的礼物，发出的评论有没有显示，这是我们一定要保证的<br>同时，别的用户评论，一秒只显示几百条都是没问题的，丢弃其余的消息，做到流量削峰，保证良好的用户体验</li><li>分布式事务：预占型和给予型。 预占型可以记录日志，重新请求时看有没有日志来判断上一次是否执行成功了；给予型具有延时特性，比如手机转账，总是过几秒才转过来</li><li>分库分表：如何从主从切换到分库分表，先用mysql binlog同步到分库分表中，并进行比对，一直到没有差异为止，ABA问题在多次比对后出现的几率已经很低了，此时线上业务可以将读操作切换到分库分表，因为读是不会产生脏数据的</li><li>云服务的好处：按流量计费，比如某天有秒杀活动，用户量激增，如果是自己的机房，需要增加服务器，等过了这个时间后，流量又下来了，而云服务是按流量计费的，增加缩减机器都十分方便。云服务的不足之处是要和别的企业共享资源，因为稳定性不高，还会有资源限制，如带宽限制，mysql连接数限制</li><li>对恶意用户的思考，比如刷金币，刷粉丝，刷广告等等，是否有必要赶尽杀绝，如果涉黄涉政，必然是要屏蔽的，而例如微博，用户是否也有刷粉丝的实际需要<br>如何防止恶意用户呢，可以用工具，例如内容识别，账号防刷等，但是有效期不长，建议用大数据进行行为特征分析</li><li>需求和开发：施行2周制，第一周产品和开发都是ready状态，产品准备好需求，开发人员开始开发，测试，直到第二周结束上线，同时从第一周开始并行地，开始准备下一轮新的需求，到第二周结束准备好下一轮新需求，以此往复</li><li>定期梳理自己的代码，线上服务正常运行很近，突然出现问题，说”我没动代码啊”，这样做是不对的，没动过并不代表没有隐患，可以每天上下班看一眼自己的业务指标监控(open-falcon)</li><li>线上出现问题的正确做法，立即采取一切手段修复故障，保障用户体验，及时止损，而不是在保护故障现场，排查问题。事后要对故障复盘，并且组内开会讨论，不要抱有职责，内疚的情绪，让组员都从这次问题中成长</li><li>语言和技术栈一定要统一，降低成本</li><li>抽取通用服务，如鉴权，不要每个服务都开发一套</li></ol>]]></content>
      
      <categories>
          
          <category> 架构随笔录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之Spring Cloud Consul项目接入</title>
      <link href="/2018/11/19/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8BSpring-Cloud-Consul%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5/"/>
      <url>/2018/11/19/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8BSpring-Cloud-Consul%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>本文主要介绍Spring Cloud对consul的支持，分为消费者和生产者两个客户端</p></blockquote><h2 id="应用详情"><a href="#应用详情" class="headerlink" title="应用详情"></a>应用详情</h2><p>分别新建两个spring-boot项目</p><table><thead><tr><th>应用名称</th><th>端口</th><th>consul注册地址</th></tr></thead><tbody><tr><td>consumer-service</td><td>8301</td><td>10.9.181.34:8500</td></tr><tr><td>producer-service</td><td>8302</td><td>10.9.117.128:8500</td></tr></tbody></table><h2 id="consul接入"><a href="#consul接入" class="headerlink" title="consul接入"></a>consul接入</h2><h3 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h3><p>除了通用的web模块，主要需要consul-discovery与actuator，前者用于consul客户端接入，后者提供健康检查接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulConsumerApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ConsulConsumerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8301</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer-service</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost #consul客户端地址</span><br><span class="line">      port: 8500</span><br><span class="line">      retry:</span><br><span class="line">        max-attempts: 3</span><br><span class="line">        initial-interval: 1000</span><br><span class="line">        max-interval: 2000</span><br><span class="line">        multiplier: 1.1</span><br><span class="line">      discovery:</span><br><span class="line">        health-check-interval: 10s #健康检查默认时间间隔</span><br><span class="line">        health-check-path: /actuator/health #健康检查默认请求路径</span><br><span class="line">        health-check-timeout: 5s #超时时间</span><br><span class="line">        #为服务生成一个32位随机字符作为实例名，并非最佳实践</span><br><span class="line">        #instance-id: $&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;</span><br><span class="line">        health-check-tls-skip-verify: true #跳过https校验</span><br><span class="line">        service-name: consumer-service</span><br><span class="line">        heartbeat: </span><br><span class="line">          enabled: true</span><br><span class="line">          ttl-value: 5</span><br><span class="line">          ttl-unit: s</span><br><span class="line">        prefer-ip-address: true #显示真实ip，而不是主机名</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之集群部署</title>
      <link href="/2018/11/18/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/11/18/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h1 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h1><p>根据上一章中的架构图，进行分布式部署</p><p>首先从<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">Consul官网</a>下载最新的安装包, 本文采用1.3.0版本</p><h2 id="服务器列表"><a href="#服务器列表" class="headerlink" title="服务器列表"></a>服务器列表</h2><table><thead><tr><th>节点类型</th><th>名称</th><th>ip</th></tr></thead><tbody><tr><td>server</td><td>server-01</td><td>10.9.188.187</td></tr><tr><td>server</td><td>server-02</td><td>10.9.171.147</td></tr><tr><td>server</td><td>server-03</td><td>10.9.39.37</td></tr><tr><td>client</td><td>client-01</td><td>10.9.181.34</td></tr><tr><td>client</td><td>client-02</td><td>10.9.117.128</td></tr></tbody></table><p>通过wget命令下载Consul到每台服务器中，可以在网页中右键”复制链接”获取下载地址</p><p>下载完成后，通过<code>unzip</code>命令解压</p><h2 id="启动server节点"><a href="#启动server节点" class="headerlink" title="启动server节点"></a>启动server节点</h2><p>启动的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span>=10.9.188.187 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=./data -datacenter=dc1 -node=server-01 &amp;</span><br></pre></td></tr></table></figure><p>新建<code>start.sh</code>，将以上命令拷贝进来，通过<code>sh start.sh</code>命令启动，接下来说明各个参数的含义</p><ol><li>-server：表示以server的身份启动agent</li><li>-bind：集群内部的通信地址，填写本机ip即可</li><li>-client：可以接受通信的客户端地址，<code>0.0.0.0</code>表示接收来自任意ip的客户端</li><li>-bootstrap-expect：预期的server节点数，只有达到了这个数目，才会形成server集群。注意所有server都应该配置一样的值</li><li>-data-dir：保存数据的目录，建议事先新建，server用它持久化集群状态</li><li>-datacenter：所在的数据中心，默认dc1</li><li>-node：节点名称，最终会显示在界面中</li></ol><h2 id="组建集群"><a href="#组建集群" class="headerlink" title="组建集群"></a>组建集群</h2><p>启动3个server节点之后，只是3个孤立的节点，需要用gossip协议互相告知，在Consul中，使用<code>join</code>命令加入集群</p><p>启动第二台server节点之后，就可以join到第一台server，第三台server节点加入任意一个即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul join 第一台的ip</span><br></pre></td></tr></table></figure><p>接着使用<code>members</code>检查集群成员</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul members</span><br></pre></td></tr></table></figure><p>显示3个Type为server的节点集群，同时3台服务的status为alive</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxjdws5ixuj326w050abp.jpg" alt=""></p><p>查看Server集群信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul operator raft list-peers</span><br></pre></td></tr></table></figure></p><p>可以看到Leader节点的信息<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyvjjfcknrj312c04swge.jpg" alt=""></p><h2 id="启动client节点"><a href="#启动client节点" class="headerlink" title="启动client节点"></a>启动client节点</h2><p>启动client的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -<span class="built_in">bind</span>=10.9.181.34 -data-dir=./data -client=0.0.0.0 -node=client-01 -ui &amp;</span><br></pre></td></tr></table></figure><p>参数说明</p><ol><li>-ui：启动ui界面，只需要有一个client加入这个参数即可</li><li>其他参数同 server，</li></ol><p>同样的使用join命令加入agent集群</p><h2 id="ui界面"><a href="#ui界面" class="headerlink" title="ui界面"></a>ui界面</h2><p>打开浏览器，输入10.9.181.34:8500，注意ip是添加了<code>-ui</code>参数的client地址</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxlfnff3vmj32780h2mze.jpg" alt="Consul控制台首页"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>Service显示我们的应用服务，其中默认显示了3个Server节点的Consul服务</li><li>Nodes显示所有的agent节点，包括server和client</li><li>K\V是一个key-vlaue存储，可用于分布式锁的实现</li><li>Consul提供了ACL功能，基于ip和port控制请求的畅通</li><li>Intention基于ACL，可以添加服务之间的通信规则，允许或者是禁止通信</li></ol><p>Services中Node Health的含义有些绕，指的是服务所在的agent节点中，通过检查(checks)的个数，check有三个状态：passing(通过), warning(警告),critical(危险)</p><p>节点中的checks包含且不限于健康检查，checks分为节点自身的健康状态检查，注册在节点上的服务的健康状态检查，以及自定义的健康状态检查</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Consul中的启动参数是非常多的，大多数参数都有默认值，完整的参数列表可在<a href="https://www.consul.io/docs/agent/options.html#command-line-options" target="_blank" rel="noopener">Consul 配置</a>中查到。</p><p>Consul按以下3个优先级接收参数：</p><ol><li>命令行参数</li><li>环境变量</li><li>配置文件</li></ol><p>Consul支持json和hcl格式的配置文件，同时也支持指定文件夹的方式，这将按照文件名的词法顺序加载配置文件，例如basic.json先于extra.json加载。后出现的配置项会覆盖前面的配置项</p><p>命令行参数的名称不一定完全和配置文件中的参数名称一样，例如：-node对应node_name</p><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><p>以下是一份配置文件的示例，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"datacenter"</span>: <span class="string">"dc1"</span>,</span><br><span class="line">    <span class="attr">"server"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"bootstrap_expect"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"node_name"</span>: <span class="string">"server-01"</span>,</span><br><span class="line">    <span class="attr">"bind_addr"</span>: <span class="string">"10.9.188.187"</span>,</span><br><span class="line">    <span class="attr">"client_addr"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"data_dir"</span>: <span class="string">"./data"</span>,</span><br><span class="line">    <span class="attr">"log_level"</span>: <span class="string">"INFO"</span>,</span><br><span class="line">    <span class="attr">"ports"</span>: &#123;</span><br><span class="line">        <span class="attr">"dns"</span>: <span class="number">8600</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="number">8500</span>,</span><br><span class="line">        <span class="attr">"server"</span>: <span class="number">8300</span>,</span><br><span class="line">        <span class="attr">"serf_lan"</span>: <span class="number">8301</span>,</span><br><span class="line">        <span class="attr">"serf_wan"</span>: <span class="number">8302</span>,</span><br><span class="line">        <span class="attr">"https"</span>: <span class="number">-1</span>,</span><br><span class="line">        <span class="attr">"grpc"</span>: <span class="number">-1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"start_join"</span>: [<span class="string">"10.9.181.34"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -config-dir=./config &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之初识</title>
      <link href="/2018/11/16/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%9D%E8%AF%86/"/>
      <url>/2018/11/16/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%9D%E8%AF%86/</url>
      <content type="html"><![CDATA[<blockquote><p>Consul是HashiCorp公司推出的开源工具，提供服务发现，健康检查，K/V存储，多数据中心，ACL等功能，同时也是Service Mesh解决方案。</p></blockquote><h1 id="与其它注册中心的对比"><a href="#与其它注册中心的对比" class="headerlink" title="与其它注册中心的对比"></a>与其它注册中心的对比</h1><p>参考博主纯洁的微笑的文章：<a href="http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html" target="_blank" rel="noopener">springcloud(十三)：注册中心 Consul 使用详解</a></p><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>为什么有这一小节呢，本人刚接触到Consul时，对代理(agent)，client, server三者之间的关系没有搞清楚，以下对这几个概念做梳理，帮助新人快速理解</p><ul><li>代理：从Consul官网下载的zip包中，解压后只有一个启动文件，启动之后会运行一个Consul服务，你可以把这个服务理解为agent。agent分为两种，server和client，在启动agent的时候，可以通过参数指定是server还是client</li><li>agent集群：所有server和client节点形成的集群</li><li>server：server主要维护应用服务信息，响应查询，参与一致性选举，与别的数据中心交换信息。</li><li>server集群：server集群中的节点包括一个leader和多个follower，通过raft算法选举leader，保证一致性。server官方推荐的个数是一个数据中心有3或5个节点，一是为了高可用，二是奇数个方便选举，同时要保证server节点的存活数不低于（N/2）+1个，如3个server组成的集群，必须保证2个server存活，5个保证3个存活，否则server集群处于不可用状态</li><li>client：agent的另一种，主要用于转发RPC请求，本身是无状态的，运行在后台维护gossip协议池</li><li>datacenter：笔者对数据中心的理解还十分简陋，大概是机房的意思吧，将Consul部署到多个dc中，增加了可用性</li><li>gossip协议：翻译为流言协议，取自人类社会中的谣言传播，在Consul中用于管理agent和广播消息，在一个agent集群中新加入一个节点，或离开一个节点时，会通过gossip协议告诉集群中的所有节点，Consul的这些gossip协议功能是通过自家的另一个开源产品Serf实现的，这里对Serf要有个印象</li><li>LAN gossip与WAN gossip：分别代表一个数据中心中agent集群之间的的gossip协议，和多个数据中心之间的gossip协议</li></ul><h1 id="Consul的架构"><a href="#Consul的架构" class="headerlink" title="Consul的架构"></a>Consul的架构</h1><p>官网给出了两个数据中心的<a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="noopener">俯视图</a>，为了方便理解，笔者自己画了一个单数据中心的架构图，帮助大家理解</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxlh3wc72cj30mh0glwf0.jpg" alt="Consul架构"></p><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><ol><li>用3台服务器，部署3个server节点，形成server集群</li><li>每一台应用服务器上部署一个client节点，同时可以部署应用服务，可以是一个，可以是多个，视运维部署规则而定，一般生产环境每台服务器只部署一个应用</li><li>应用服务注册到本机的Consul client，通过它与server集群交互</li></ol><h1 id="Consul原理"><a href="#Consul原理" class="headerlink" title="Consul原理"></a>Consul原理</h1><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在写这一系列的文章时，笔者并不想一开始就实操，而是挈领提纲地介绍了Consul的原理，希望读者有个模糊的印象，在接下来的一步步操作中加深理解。</p>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之请求参数校验</title>
      <link href="/2018/10/14/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2018/10/14/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之请求参数校验"><a href="#Spring-boot实践之请求参数校验" class="headerlink" title="Spring boot实践之请求参数校验"></a>Spring boot实践之请求参数校验</h1><blockquote><p>本文讲述的是后端参数校验，在实际开发中，参数校验是前后端都要做的工作，因为请求接口的人除了普通用户，还有有各路神仙。</p></blockquote><h2 id="常规校验的痛楚"><a href="#常规校验的痛楚" class="headerlink" title="常规校验的痛楚"></a>常规校验的痛楚</h2><p>通常的校验代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入用户名"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还有n个接口需要校验username，你可能会抽取<code>if</code>语句到一个方法中，过段时间你又会发现，不光要校验username，还要password，adress等等一堆字段，总结起来</p><ol><li>重复劳动</li><li>代码冗长，不利于阅读业务逻辑</li><li>出现问题要去不同的接口中查看校验逻辑</li></ol><p>这无疑是件让人崩溃的事情，此时作为一个开发人员，你已经意识到需要一个小而美的工具来解决这个问题，你可以去google，去github搜索这类项目，而不是毫无作为，抑或者是自己去造轮子</p><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><p>JSR303规范应运而生，其中比较出名的实现就是Hibernate Validator，已包含在<code>spring-boot-starter-web</code>其中,不需要重新引入，<code>javax.validation.constraints</code>包下常用的注解有</p><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">@NotNUll</td><td style="text-align:left">值不能为空</td></tr><tr><td style="text-align:left">@Null</td><td style="text-align:left">值必须为空</td></tr><tr><td style="text-align:left">@Pattern(regex=)</td><td style="text-align:left">值必须匹配正则表达式</td></tr><tr><td style="text-align:left">@Size(min=,max=)</td><td style="text-align:left">集合的大小必须在min~max之间，如List，数组</td></tr><tr><td style="text-align:left">@Length(min=,max=)</td><td style="text-align:left">字符串长度</td></tr><tr><td style="text-align:left">@Range(min,max)</td><td style="text-align:left">数字的区间范围</td></tr><tr><td style="text-align:left">@NotBlank</td><td style="text-align:left">字符串必须有字符</td></tr><tr><td style="text-align:left">@NotEmpty</td><td style="text-align:left">集合必须有元素，字符串</td></tr><tr><td style="text-align:left">@Email</td><td style="text-align:left">字符串必须是邮箱</td></tr><tr><td style="text-align:left">@URL</td><td style="text-align:left">字符串必须是url</td></tr><tr><td style="text-align:left">@AssertFalse</td><td style="text-align:left">值必须是false</td></tr><tr><td style="text-align:left">@AssertTrue</td><td style="text-align:left">值必须是true</td></tr><tr><td style="text-align:left">@DecimalMax(value=,inclusive=)</td><td style="text-align:left">值必须小于等于(inclusive=true)/小于(inclusive=false) value属性指定的值。可以注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@DecimalMin(value=,inclusive=)</td><td style="text-align:left">值必须大于等于(inclusive=true)/大f (inclusive=false) value属性指定的值。可以注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@Digits(integer-,fraction=)</td><td style="text-align:left">数字格式检查。integer指定整 数部分的最大长度，fraction指定小数部分的最大长度</td></tr><tr><td style="text-align:left">@Future</td><td style="text-align:left">值必须是未来的日期</td></tr><tr><td style="text-align:left">@Past</td><td style="text-align:left">值必须是过去的日期</td></tr><tr><td style="text-align:left">@Max(value=)</td><td style="text-align:left">值必须小于等于value指定的值。不能注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@Min(value=)</td><td style="text-align:left">值必须大于等于value指定的值。不能注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><h2 id="校验实战"><a href="#校验实战" class="headerlink" title="校验实战"></a>校验实战</h2><p>接下来我们尝试一个入门例子,有一个User java bean, 为username字段加入@NotBlank注解，注意@NotBlank的包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"请输入用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表明将对username字段做非null，非空字符串校验，并为user参数添加@Valid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@RequestBody @Valid User user)</span></span></span><br></pre></td></tr></table></figure><p>按照<a href="">Spring boot实践之编写接口测试用例</a>编写一个测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBlankName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String params = <span class="string">"&#123;\"id\": 101,\"username\": \"\",\"password\": \"1234\"&#125;"</span>;</span><br><span class="line">    mockMvc.perform(post(<span class="string">"/user/login"</span>)</span><br><span class="line">    .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">    .content(params))</span><br><span class="line">    .andExpect(status().isBadRequest());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于参数为空，将返回BadRequest—400响应码，但是此时我们获取不到错误信息，由于spring的拦截，甚至你会发现不进方法断点，仅仅得到一个400响应码，对前端提示错误信息帮助不大，因此我们需要获取错误信息</p><h2 id="获取错误信息"><a href="#获取错误信息" class="headerlink" title="获取错误信息"></a>获取错误信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@Valid @RequestBody User user, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">        result.getFieldErrors().stream().forEach(error -&gt; &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们发现已经进入方法断点</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwdk366fb4j30s002eglr.jpg" alt="进入断点"></p><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>继续优化，想必大家也发现了，难道每个方法都要写<code>if</code>? 当然不用，ControllerAdvice不就是专门封装错误信息的吗，仿照<a href="">异常处理</a>中的处理方式，我们很容易写出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;MethodArgumentNotValidException.class&#125;)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseModel <span class="title">exception</span><span class="params">(MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">    ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">    model.setCode(HttpStatus.BAD_REQUEST.value());</span><br><span class="line">    model.setMsg(buildErrorMessage(ex));</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildErrorMessage</span><span class="params">(MethodArgumentNotValidException ex)</span></span>&#123;</span><br><span class="line">    List&lt;ObjectError&gt; objectErrors = ex.getBindingResult().getAllErrors();</span><br><span class="line">    StringBuilder messageBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    objectErrors.stream().forEach(error -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(error <span class="keyword">instanceof</span> FieldError)&#123;</span><br><span class="line">            FieldError fieldError = (FieldError) error;</span><br><span class="line">            messageBuilder.append(fieldError.getDefaultMessage()).append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    String message  = messageBuilder.deleteCharAt(messageBuilder.length() - <span class="number">1</span>).toString();</span><br><span class="line">    log.error(message);</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>除了使用<code>@ExceptionHandler</code>来捕获<code>MethodArgumentNotValidException</code>以外，还可以覆盖<code>ResponseEntityExceptionHandler</code>抽象类的handleMethodArgumentNotValid方法，但是二者不可以混用</p><h2 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h2><p>由于JSR303提供的注解有限，实际开发过程中校验往往需要结合实际需求，JSR303提供了自定义校验扩展接口</p><p>典型的一个请求场景是枚举类型参数，假设用户分为3类: 普通用户，VIP玩家，氪金玩家，分别用1，2，3表示，此时如何校验前端传入的值在范围内，抖机灵的朋友可能会想到@Range，万一是离散的不连续数呢？</p><p>自定义注解类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 指定校验类</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = InValidator.class)</span><br><span class="line"><span class="meta">@Target</span>( &#123; ElementType.METHOD, ElementType.FIELD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> In &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "必须在允许的数值内"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] values();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于分组校验</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的校验器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">In</span>, <span class="title">Number</span>&gt; </span>&#123;<span class="comment">// 校验Number类型 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; inValues;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(In in)</span> </span>&#123; </span><br><span class="line">    inValues = Sets.newHashSet();</span><br><span class="line">    <span class="keyword">int</span>[] arr = in.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">       inValues.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Number propertyValue, ConstraintValidatorContext cxt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyValue==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> inValues.contains(propertyValue.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，生产级别的参数校验基本完成</p><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>在不同接口中，指定不同的校验规则，如：</p><ol><li>不同的接口，校验不同的字段</li><li>同一个字段，在不同的接口中有不同的校验规则</li></ol><p>以下实现第一种情况</p><p>首先定义两个空接口，代表不同的分组，也就是不同的业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewUser</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RMBUser</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在指定校验规则时，指定分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(groups = &#123;NewUser.class&#125;, message = <span class="string">"请输入密码"</span>)   </span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@In</span>(groups = &#123;RMBUser.class&#125;, values = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, message = <span class="string">"非法的用户类型"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同的接口指定不同的校验分组"><a href="#不同的接口指定不同的校验分组" class="headerlink" title="不同的接口指定不同的校验分组"></a>不同的接口指定不同的校验分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略类定义...</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"normal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">normal</span><span class="params">(@Validated(&#123;NewUser.class&#125;)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"rmb"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">rmb</span><span class="params">(@Validated(&#123;RMBUser.class&#125;)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试用例</p><p>只检验密码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String params = <span class="string">"&#123;\"id\": 101,\"username\": \"tom\",\"password\": \"\",\"type\": \"5\"&#125;"</span>;</span><br><span class="line">       String result = mockMvc.perform(post(<span class="string">"/user/normal"</span>)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">               .content(params))</span><br><span class="line">               .andExpect(status().isBadRequest())</span><br><span class="line">               .andReturn().getResponse().getContentAsString();</span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：<code>{&quot;data&quot;:null,&quot;code&quot;:400,&quot;msg&quot;:&quot;请输入密码&quot;}</code><br>只检验用户类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRMB</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String params = <span class="string">"&#123;\"id\": 101,\"username\": \"tom\",\"password\": \"\",\"type\": \"5\"&#125;"</span>;</span><br><span class="line">       String result = mockMvc.perform(post(<span class="string">"/user/rmb"</span>)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">               .content(params))</span><br><span class="line">               .andExpect(status().isBadRequest())</span><br><span class="line">               .andReturn().getResponse().getContentAsString();</span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：<code>{&quot;data&quot;:null,&quot;code&quot;:400,&quot;msg&quot;:&quot;非法的用户类型&quot;}</code></p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之异常处理</title>
      <link href="/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之异常处理"><a href="#Spring-boot实践之异常处理" class="headerlink" title="Spring boot实践之异常处理"></a>Spring boot实践之异常处理</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一章<a href="">封装返回体</a>中，已经对请求成功的情况进行了封装，接下来便是处理异常，服务的生产者需要通过状态码此次请求是否成功，出现异常时，错误信息是什么，形如:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"FAILED"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常接口"><a href="#异常接口" class="headerlink" title="异常接口"></a>异常接口</h2><p>可以看出只需要<code>code</code>与<code>msg</code>, 参考 <code>org.springframework.http.HttpStatus</code>的实现，我们可以定义一个枚举来封装错误信息，对外暴露<code>getCode</code>，<code>getMsg</code>方法即可。由于异常属于一个基础模块，将这两个方法抽象到一个接口中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExceptionEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Integer <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常枚举"><a href="#异常枚举" class="headerlink" title="异常枚举"></a>异常枚举</h3><p>以用户模块为例，所有用户相关的业务异常信息封装到<code>UserError</code>中，例如用户不存在，密码错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserError implements ExceptionEntity &#123;</span><br><span class="line"></span><br><span class="line">    NO_SUCH_USER(<span class="number">1</span>, <span class="string">"用户不存在"</span>),</span><br><span class="line">    ERROR_PASSWORD(<span class="number">2</span>, <span class="string">"密码错误"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer MODULE = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    UserError(Integer code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MODULE + <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h4><p>需要注意的地方是笔者定义了一个<code>MODULE</code>字段，10000代表用户微服务，这样在拿到错误信息之后，可以很快定位报错的应用</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// lombok自动生成构造方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    ExceptionEntity error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是错误接口与自定义异常属于公共模块，而<code>UserError</code>属于用户服务</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>之后，便可以抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(UserError.ERROR_PASSWORD);</span><br></pre></td></tr></table></figure><p>目前来看，我们只是较为优雅的封装了异常，此时请求接口返回的仍然是Spring boot默认的错误体，没有错误信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="string">"2018-10-18T12:28:59.150+0000"</span>,</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"No message available"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/user/error"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>接下来的异常拦截方式，各路神仙都有自己的方法，笔者只说Spring boot项目中比较通用的<code>@ControllerAdvice</code>，由于是Restful接口，这里使用<code>@RestControllerAdvice</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这属于基础模块，扫描路径不要包含具体的模块，用..代替</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>(basePackages=<span class="string">"com.ttyc..controller"</span>,annotations=&#123;RestController.class&#125;)</span><br><span class="line"><span class="comment">// lombok的日志简写</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionAdvisor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;ServiceException.class&#125;)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseModel <span class="title">handleServiceException</span><span class="params">(ServiceException ex)</span></span>&#123;</span><br><span class="line">        Integer code = ex.getError().getCode();</span><br><span class="line">        String msg = ex.getError().getMsg();</span><br><span class="line">        log.error(msg);</span><br><span class="line"></span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(code);</span><br><span class="line">        model.setMsg(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其他错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;Exception.class&#125;)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseModel <span class="title">exception</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> code = HttpStatus.INTERNAL_SERVER_ERROR.value();</span><br><span class="line">        String msg = HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase();</span><br><span class="line">        log.error(msg);</span><br><span class="line"></span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(code);</span><br><span class="line">        model.setMsg(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具有争议的一点是捕获<code>ServiceExcption</code>之后，应该返回200还是500的响应码，有的公司返回200，使用<code>code</code>字段判断成功失败，这完全没有问题，但是按照Restful的开发风格，这里的<code>@ResponseStatus</code>笔者返回了500，请读者根据自身情况返回响应码</p><h3 id="测试接口与测试用例"><a href="#测试接口与测试用例" class="headerlink" title="测试接口与测试用例"></a>测试接口与测试用例</h3><h4 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抛出业务异常示例</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(UserError.NO_SUCH_USER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testError</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String result =</span><br><span class="line">            mockMvc.perform(get(<span class="string">"/user/error"</span>))</span><br><span class="line">                    .andExpect(status().isInternalServerError())</span><br><span class="line">                    .andReturn().getResponse().getContentAsString();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"code"</span>: <span class="number">10001</span>,</span><br><span class="line"><span class="attr">"msg"</span>: <span class="string">"用户不存在"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之编写接口测试用例</title>
      <link href="/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
      <url>/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之编写接口测试用例"><a href="#Spring-boot实践之编写接口测试用例" class="headerlink" title="Spring boot实践之编写接口测试用例"></a>Spring boot实践之编写接口测试用例</h1><blockquote><p> 测试用例对开发者降低bug率,方便测试人员回归测试有十分重要的意义。</p></blockquote><p>本文介绍如何使用<code>MockMvc</code>编写测试用例. </p><p>在Spring boot项目中编写测试用例十分简单，通常建立一个Spring boot项目都会test目录下生成一个Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以用户查询为例，通常有一个用户实体，以及<code>UserController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Data注解来自lombok</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getInfo方法是一个restful接口，模拟查询用户详情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"info"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getInfo</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>, required = <span class="keyword">true</span>)</span> String username)</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(username + <span class="string">"s"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下通过MockMvc对象，测试<code>/user/info}</code>请求是否成功，并符合预期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入上下文对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化mockMvc对象</span></span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result =</span><br><span class="line">                <span class="comment">//执行get请求，这里有个小坑，第一个/必须有</span></span><br><span class="line">                mockMvc.perform(get(<span class="string">"/user/info"</span>)</span><br><span class="line">                        <span class="comment">//设置content-type请求头</span></span><br><span class="line">                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                        <span class="comment">//设置参数  </span></span><br><span class="line">                        .param(<span class="string">"name"</span>, <span class="string">"jay"</span>))</span><br><span class="line">                        <span class="comment">//预期的相应码是200-ok</span></span><br><span class="line">                        .andExpect(status().isOk())</span><br><span class="line">                        <span class="comment">//预测username的值为jays</span></span><br><span class="line">                        .andExpect(jsonPath(<span class="string">"$.username"</span>).value(<span class="string">"jays"</span>))</span><br><span class="line">                        <span class="comment">//获取响应体</span></span><br><span class="line">                        .andReturn().getResponse().getContentAsString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过测试，并输出响应体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">101</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"jays"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"1234"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>$.id</code>jsonpath的使用，参考<a href="https://github.com/json-path/JsonPath" target="_blank" rel="noopener">JsonPath</a></p><p>同时付一段使用json参数的post请求方式，大同小异，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String params = <span class="string">"&#123;\"id\": 101,\"username\": \"jason\",\"password\": \"1234\"&#125;"</span>;</span><br><span class="line">mockMvc.perform(post(<span class="string">"/user/login"</span>)</span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">        .content(params))</span><br><span class="line">        .andExpect(status().isOk());</span><br></pre></td></tr></table></figure><p>注意后端接受json格式参数的方式：<code>方法名(@RequestBody User user)</code> </p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之封装返回体</title>
      <link href="/2018/10/11/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BD%93/"/>
      <url>/2018/10/11/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BD%93/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之封装返回体"><a href="#Spring-boot实践之封装返回体" class="headerlink" title="Spring boot实践之封装返回体"></a>Spring boot实践之封装返回体</h1><p>在实际开发中，一个项目会形成一套统一的返回体接口规范，常见的结构如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"SUCCESS"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: 真正的数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以根据自己的实际情况封装一个java bean，刑如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseModel</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring boot中，会将返回的实体类，通过jackson自动转换成json</p><p>Spring提供了<code>ResponseBodyAdvice</code>接口拦截响应体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseAdvisor</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Class aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MethodParameter methodParameter, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  MediaType mediaType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class aClass, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpRequest serverHttpRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpResponse serverHttpResponse)</span> </span>&#123;</span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(<span class="number">0</span>);</span><br><span class="line">        model.setData(body);</span><br><span class="line">        model.setMsg(<span class="string">"SUCCESS"</span>);</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是一个最初的功能，值得优化的地方有很多，读者应根据自己的情况进行扩展</p><p>根据笔者遇到的情况，抛砖引玉一下</p><ol><li>是否需要对所有的响应拦截，可以在supports方法中判断</li><li>下载返回的是字节数据，再进行包装必然得不到正确的文件，不应该进行包装</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列:微服务注册中心——Eureka入门</title>
      <link href="/2018/09/10/Spring-Cloud%E7%B3%BB%E5%88%97-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%94%E2%80%94Eureka%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/10/Spring-Cloud%E7%B3%BB%E5%88%97-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%94%E2%80%94Eureka%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>作为一个没有经验的开发人员(捂脸），在了解Eureka之前，我更想让读者带着问题去思考</p><ol><li>什么是微服务注册中心，微服务为什么需要注册中心</li><li>注册中心都实现了哪些功能</li><li>开源的注册中心有哪些，为什么要选Eureka，优缺点有哪些</li><li>生产环境中的注册中心如何部署</li></ol><p>这些想法都是我敲完代码想要思考的，搭建一个注册中心几分钟的事，实在没什么技术含量，感觉收获到的东西太少，需要沉下来多思考</p><p>以下是Eureka server单机伪集群的配置方式：</p><p>1.首先Spring boot项目，加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>2.配置文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line">spring:</span><br><span class="line">  profiles: master</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-master</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer2:8001/eureka/</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">  server:</span><br><span class="line">    eviction-interval-timer-in-ms: 10000 # 每10s就去清理无效的实例</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">spring:</span><br><span class="line">  profiles: slave</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-slave</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer1:8000/eureka/</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">  server:</span><br><span class="line">    eviction-interval-timer-in-ms: 10000 # 每10s就去清理无效的实例</span><br><span class="line">    enable-self-preservation: false</span><br></pre></td></tr></table></figure></p><p>虽然复制粘贴到你的项目是件易事，不过有几个配置点笔者还是想要详细说一下：</p><ol><li>hostname配置了peer1、peer2，这是在模拟集群环境，需要读者自己在hosts文件中添加映射，<br><code>127.0.0.1     localhost peer1 peer2</code>.如果你的内存够大，也可以用两台虚拟机</li><li>对于Eureka来说，无效的实例是通过定时任务去清除的，默认是60s，这里我设置为了10s</li><li>IDEA中通过一个项目启动Eureka集群,通过spring.profiles.active区分配置<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw8r9iqvrgj30u0044my9.jpg" alt="点击Edit Configurations"><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw8rfa3p3ej31kw0asn18.jpg" alt="点击加号新增Spring boot"></li></ol>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列: Spring Boot Admin</title>
      <link href="/2018/09/07/Spring-Cloud%E7%B3%BB%E5%88%97-Spring-Boot-Admin/"/>
      <url>/2018/09/07/Spring-Cloud%E7%B3%BB%E5%88%97-Spring-Boot-Admin/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了Spring Boot Admin的使用，参考Spring Boot Admin 2.0.2版本(以下简称SBA，来自官方)官方文档，主要实现了其中案例，也包括一些自己的想法</p><p>文档地址：<a href="http://codecentric.github.io/spring-boot-admin/current/" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/current/</a></p><p>以下文章内容的例子都可以在我的<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack" target="_blank" rel="noopener">GitHub</a>找到</p><h1 id="Spring-Boot-Admin介绍"><a href="#Spring-Boot-Admin介绍" class="headerlink" title="Spring Boot Admin介绍"></a>Spring Boot Admin介绍</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>SBA是一个用于管理和监控Spring Boot项目的工具，包括线程，内存，Spring bean加载情况，日志等一系列可视化界面</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>熟悉Spring Boot的读者都知道Spring Boot actuator这款组件，它使用HTTP端点或JMX来管理和监控应用程序，但是没有提供图形化界面，仅仅提供了JSON格式的数据，同时无法做到集中管理应用，对运维十分不友好，SBA基于actuator不但解决了这些痛点，并且通过扩展实现了很多强大的功能，如日志级别动态更改，查看实时日志，查看URL映射等等，对管理微服务十分有意义</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>环境的搭建将配合注册中心Eureka，当然也可以不使用注册中心，参考<a href="http://codecentric.github.io/spring-boot-admin/current/#set-up-admin-server" target="_blank" rel="noopener">Spring Boot Admin Server</a>一节,或使用别的注册中心，如<a href="http://cloud.spring.io/spring-cloud-consul/" target="_blank" rel="noopener">Consul</a>，Zookeeper，这些官方都已经在github给出了<a href="https://github.com/codecentric/spring-boot-admin/tree/master/spring-boot-admin-samples" target="_blank" rel="noopener">案例</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>服务端和客户端均加入了spring-security组件，同时都配置了关闭请求拦截和跨域防范，详见笔者的GitHub<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack" target="_blank" rel="noopener">Spring-Cloud-Stack</a>项目，<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-server" target="_blank" rel="noopener">admin-server</a>和<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-client" target="_blank" rel="noopener">admin-client</a>模块<br><strong>注意：</strong> 按常理IDEA在勾选依赖生成项目之后，会加入bom版本管理，可是笔者也遇到了没有自动生成的情况，请读者注意pom文件是否有以下内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="SBA-服务端"><a href="#SBA-服务端" class="headerlink" title="SBA 服务端"></a>SBA 服务端</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注册Eureka并添加-EnableAdminServer注解"><a href="#注册Eureka并添加-EnableAdminServer注解" class="headerlink" title="注册Eureka并添加@EnableAdminServer注解"></a>注册Eureka并添加@EnableAdminServer注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminServerApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(AdminServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-security配置"><a href="#spring-security配置" class="headerlink" title="spring-security配置"></a>spring-security配置</h3><p><code>anyRequest.permitAll</code>表示允许所有请求通过校验<br><code>csrf.disable</code>表示关闭跨域防范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityPermitAllConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().permitAll()  </span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><p>简要说明: 主要配置端口，eureka，必须暴露所有web actuator断点，生产环境考虑到安全性，应当酌情开放，最后配置了spring-security的用户名和密码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8115</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8000/eureka/,http://localhost:8001/eureka/</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">  endpoint:</span></span><br><span class="line"><span class="attr">    health:</span></span><br><span class="line"><span class="attr">      show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    user:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><h2 id="SBA-客户端"><a href="#SBA-客户端" class="headerlink" title="SBA 客户端"></a>SBA 客户端</h2><h2 id="pom依赖-1"><a href="#pom依赖-1" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-Security配置"><a href="#Spring-Security配置" class="headerlink" title="Spring-Security配置"></a>Spring-Security配置</h2><p><a href="#spring-security配置">同服务端</a></p><h2 id="yml配置-1"><a href="#yml配置-1" class="headerlink" title="yml配置"></a>yml配置</h2><p>这里提一个小坑点, server的地址必须加<strong>http://</strong> 前缀，否则会在启动日志中看到WARN，注册失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8116</span><br><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8115</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: user</span><br><span class="line">      password: admin</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: ALWAYS</span><br></pre></td></tr></table></figure><h1 id="最初效果"><a href="#最初效果" class="headerlink" title="最初效果"></a>最初效果</h1><p>在启动注册中心，以及服务端，客户端之后，打开<a href="http://localhost:8115" target="_blank" rel="noopener">http://localhost:8115</a>，输入配置的用户名和密码即可登录</p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>java.io.IOException: Broken pipe, SBA 的issue中有回复：</p><p>This is a quite normal. The browser does some long polling and keeps the tcp connection open. If the browser window is closed the tcp connection is aborted and on the next write the exception is thrown. there is nothing to do about this, except changing the loglevel.<br>这是很正常的。浏览器执行一些长轮询并保持TCP连接打开。如果浏览器窗口关闭，则中止TCP连接，并在下一次写入时抛出异常。除了更改日志级别之外，这没有什么可做的。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="UI配置"><a href="#UI配置" class="headerlink" title="UI配置"></a>UI配置</h2><h3 id="如何显示项目的版本号"><a href="#如何显示项目的版本号" class="headerlink" title="如何显示项目的版本号"></a>如何显示项目的版本号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  version: @project.version@</span><br></pre></td></tr></table></figure><p>此处的project.version引用了maven中的变量</p><p>效果图如下</p><p><img src="https://ws4.sinaimg.cn/large/0069RVTdly1fv136xsz3yj31kw0b63zz.jpg" width="65%" align="left"></p><h2 id="查看实时滚动日志"><a href="#查看实时滚动日志" class="headerlink" title="查看实时滚动日志"></a>查看实时滚动日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  file: client.log</span><br></pre></td></tr></table></figure><p>配置日志文件位置即可，根据官方文档说明，SBA可以自动检测出url链接，同时支持日志颜色配置，但是项目启动时报错，遂放弃之<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.pattern.file=%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr(%5p) %clr($&#123;PID&#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n%wEx</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>日志效果如下图：<br><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fv13clxp0qj31kw0d9wts.jpg" width="65%" align="left"></p><p>可以看到提供了下载按钮，其实是打开了一个网页页签，可复制出来，中文日志会出现乱码</p><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>tag可以给每一个客户端标识，有两种途径加入tag:</p><h3 id="1-元数据"><a href="#1-元数据" class="headerlink" title="1. 元数据"></a>1. 元数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8115</span><br><span class="line">        instance:</span><br><span class="line">          metadata:</span><br><span class="line">            tags:</span><br><span class="line">              content: mesh</span><br></pre></td></tr></table></figure><h3 id="2-info端点"><a href="#2-info端点" class="headerlink" title="2. info端点"></a>2. info端点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  tags:</span><br><span class="line">    title: mosi</span><br></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fv13qitypfj30x80mkjt8.jpg" width="65%" align="left"></p><p><strong>值得注意的是，两种方式的k-v表现形式, 第一个是tags.content为key，第二个是tags为key</strong></p><h2 id="静态配置客户端"><a href="#静态配置客户端" class="headerlink" title="静态配置客户端"></a>静态配置客户端</h2><p>这一小节的内容单独用了两个项目，分别是<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-static-client" target="_blank" rel="noopener">admin-static-client</a>，<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-static-server" target="_blank" rel="noopener">admin-static-server</a></p><p>通过Spring Cloud提供的静态配置，SBA支持静态配置client，首先建立客户端项目，只需要web，actuator两个依赖即可，</p><p>server端将Eureka依赖改为如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>接下来配置客户端的地址等信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    discovery:</span><br><span class="line">      client:</span><br><span class="line">        simple:</span><br><span class="line">          instances:</span><br><span class="line">            admin-static-client:</span><br><span class="line">              - uri: http://localhost:8117</span><br><span class="line">                metadata:</span><br><span class="line">                  management.context-path: /actuator</span><br></pre></td></tr></table></figure></p><p>admin-static-client将是在界面上显示的客户端地址</p><h1 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h1><h2 id="邮件提醒"><a href="#邮件提醒" class="headerlink" title="邮件提醒"></a>邮件提醒</h2><p>当注册在SBA server上的应用出现DOWN/OFFLINE等情况时，需要通过告警的方式告知运维人员，而邮件告警是常用的方式之一，SBA支持邮件告警，使用了spring-boot-mail组件来完成这一功能，需要在server端做以下工作：</p><p><strong>注: </strong> 以下邮件有关内容,通常情况需要获取授权码，以qq邮箱为例，请参照<a href="http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256" target="_blank" rel="noopener">http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256</a>获取授权码</p><h3 id="pom中加入依赖"><a href="#pom中加入依赖" class="headerlink" title="pom中加入依赖"></a>pom中加入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="需要的配置如下"><a href="#需要的配置如下" class="headerlink" title="需要的配置如下"></a>需要的配置如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">boot:</span><br><span class="line">  admin:</span><br><span class="line">    ui:</span><br><span class="line">      title: &quot;Spring Boot Admin监控管理中心&quot;</span><br><span class="line">    notify:</span><br><span class="line">      mail:</span><br><span class="line">        from: 发送方</span><br><span class="line">        to: 收件方，多个逗号分隔</span><br><span class="line">        cc: 抄送，多个逗号分隔</span><br><span class="line">        template: classpath:/META-INF/spring-boot-admin-server/mail/status-changed.html # 定制邮件模板，请参考官方实现</span><br><span class="line">mail:</span><br><span class="line">  host: smtp.qq.com</span><br><span class="line">  port: 25</span><br><span class="line">  username: 发送方用户名</span><br><span class="line">  password: 授权码</span><br><span class="line">  protocol: smtp</span><br><span class="line">  test-connection: false</span><br><span class="line">  properties:</span><br><span class="line">    mail:</span><br><span class="line">      smtp:</span><br><span class="line">        auth: true</span><br><span class="line">        starttls:</span><br><span class="line">          enable: true</span><br><span class="line">          required: true</span><br></pre></td></tr></table></figure><h3 id="最终收到的邮件如图"><a href="#最终收到的邮件如图" class="headerlink" title="最终收到的邮件如图"></a>最终收到的邮件如图</h3><p>将客户端下线之后，收到的邮件如下<br><img src="https://ws4.sinaimg.cn/large/0069RVTdly1fv4hbx46zfj30we0lk41e.jpg" width="65%" align="left"></p><p>余下的第三方应用接入以及安全防护不再介绍，直接进入自定义通知</p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p>当应用(实例)宕机时，服务端应该主动通知运维人员，达到告警的作用，在SBA中提供了这样的扩展，可以继承<code>AbstractEventNotifier</code>或<code>AbstractStatusChangeNotifier</code>，由于二者属于继承关系，读者直接继承AbstractStatusChangeNotifier即可</p><p><strong>注: </strong>通知的方式有很多种，如钉钉，邮件，短信，大家按需扩展即可，以邮件举例，注入<code>JavaMailSender</code>对象即可实现邮件报警</p><p>下面给出一个告警样例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNotifier</span> <span class="keyword">extends</span> <span class="title">AbstractStatusChangeNotifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger LOGGER = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNotifier</span><span class="params">(InstanceRepository repositpry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(repositpry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">doNotify</span><span class="params">(InstanceEvent event, Instance instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> InstanceStatusChangedEvent) &#123;</span><br><span class="line">                StatusInfo statusInfo = ((InstanceStatusChangedEvent) event).getStatusInfo();</span><br><span class="line">                String status = statusInfo.getStatus();</span><br><span class="line">                Map&lt;String, Object&gt; details = statusInfo.getDetails();</span><br><span class="line">                String detailStr = details.toString();</span><br><span class="line">                <span class="keyword">boolean</span> isOffline = statusInfo.isOffline();</span><br><span class="line">                LOGGER.info(<span class="string">"status info are: status:&#123;&#125;, detail:&#123;&#125;, isOffline:&#123;&#125;"</span>, status, detailStr, isOffline);</span><br><span class="line"></span><br><span class="line">                String mavenVersion = instance.getBuildVersion().getValue();</span><br><span class="line">                String healthUrl = instance.getRegistration().getHealthUrl();</span><br><span class="line">                LOGGER.info(<span class="string">"instance build version is &#123;&#125;, health check url is &#123;&#125;"</span>, mavenVersion, healthUrl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取事件信息，instance(客户端)信息，包括前面说过的元信息，可用来发钉钉消息，短信等等的通知</span></span><br><span class="line">                LOGGER.info(<span class="string">"Instance &#123;&#125; (&#123;&#125;) is &#123;&#125;"</span>, instance.getRegistration().getName(), event.getInstance(),</span><br><span class="line">                        ((InstanceStatusChangedEvent) event).getStatusInfo().getStatus());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"Instance &#123;&#125; (&#123;&#125;) &#123;&#125;"</span>, instance.getRegistration().getName(), event.getInstance(),</span><br><span class="line">                        event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>最后聊聊一些细节内容，读者有需求的可深入了解</p><ol><li>对于监控的url请求，可以<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-headers" target="_blank" rel="noopener">添加header</a>，并对request，response<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-instance-filter" target="_blank" rel="noopener">拦截</a></li><li>使用2.0的服务端监控1.5版本的spring boot客户端，需要做一些<a href="http://codecentric.github.io/spring-boot-admin/current/#monitoring-spring-boot-1.5.x" target="_blank" rel="noopener">兼容处理</a></li><li>扩展UI，由于2.0使用了Vue.js重构，可以很方便的<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-custom-views" target="_blank" rel="noopener">扩展</a></li></ol><p>完结撒花</p>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 监控 </tag>
            
            <tag> 官方文档阅读 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud Sleuth 官方文档阅读</title>
      <link href="/2018/08/29/Spring-Cloud-Sleuth-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/"/>
      <url>/2018/08/29/Spring-Cloud-Sleuth-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>Spring Cloud Sleuth 版本 2.x</p><p>文档地址：<a href="http://cloud.spring.io/spring-cloud-sleuth/2.0.x/single/spring-cloud-sleuth.html" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-sleuth/2.0.x/single/spring-cloud-sleuth.html</a></p><h2 id="遇到的英文单词"><a href="#遇到的英文单词" class="headerlink" title="遇到的英文单词"></a>遇到的英文单词</h2><ul><li>reveals: 揭示</li><li>network latency: 网络延迟</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>一次请求中每个微服务的处理过程叫一个span，可以理解为一次请求链路中的最小单元，用一个64位的唯一ID标识，span中有若干描述信息，如：ID，产生的时间戳，IP地址，服务名等</p><p>如果是入口服务，那么span的id等于trace id</p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>一次请求经过若干个微服务，汇总每一个服务的span，最终形成一个树状的数据结构</p><h3 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h3><p>用来记录事件信息，表示请求的开始和结束，主要包含以下4个：</p><ol><li>cs:client send 客户端发起请求，标识一个span的开始</li><li><p>sr:server received 服务端接收请求，开始处理请求，此时产生的ts(时间戳，以下统称为ts)减去cs的ts，可以计算出网络传输时间</p></li><li><p>ss:server send 服务端处理结束，开始响应客户端，此时的ts减去sr的ts，就是服务端请求处理时间</p></li><li>cr:client received 客户端接收到服务端的响应，此时的ts减去cs的ts，就是一次请求所消耗的时间</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 监控 </tag>
            
            <tag> 官方文档阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux命令手记</title>
      <link href="/2018/08/27/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E8%AE%B0/"/>
      <url>/2018/08/27/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="从后往前查看日志"><a href="#从后往前查看日志" class="headerlink" title="从后往前查看日志"></a>从后往前查看日志</h2><ol><li>less 文件名</li><li>shift+g跳转到末尾，向上滑动</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>首先不推荐cat,vim等命令,大日志文件容易导致内存不足，线上排查问题时容易引起服务崩溃</p><p>有时想要查看最后五分钟内的日志，tail命令指定行数也可以大致做到，但是行数不好指定时，less会很方便</p><h2 id="查找进程命令如何排除自带的grep"><a href="#查找进程命令如何排除自带的grep" class="headerlink" title="查找进程命令如何排除自带的grep"></a>查找进程命令如何排除自带的grep</h2><p>这个技巧常用在编写shell脚本时，希望查找到某个进程的pid，但是grep命令本身也会产生一条数据，因此需要排除<br>例如查找xxx进程时<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep xxx |grep -v <span class="string">'grep'</span></span><br></pre></td></tr></table></figure></p><h2 id="查看前十个最占内存的应用"><a href="#查看前十个最占内存的应用" class="headerlink" title="查看前十个最占内存的应用"></a>查看前十个最占内存的应用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head</span><br></pre></td></tr></table></figure><h2 id="按端口终止进程"><a href="#按端口终止进程" class="headerlink" title="按端口终止进程"></a>按端口终止进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">PORT=2181</span><br><span class="line">PID=`lsof -i:<span class="variable">$&#123;PORT&#125;</span> |grep -v PID |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;PID&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"kill pid : <span class="variable">$&#123;PID&#125;</span>"</span></span><br><span class="line">        <span class="built_in">kill</span> <span class="variable">$&#123;PID&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"could not find process with port:<span class="variable">$&#123;PORT&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="生成UUID"><a href="#生成UUID" class="headerlink" title="生成UUID"></a>生成UUID</h2><p>uuidgen命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uuidgen</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d4586ba5-22da-42e5-9662-acad5942988d</span><br></pre></td></tr></table></figure><h2 id="启动shell脚本"><a href="#启动shell脚本" class="headerlink" title="启动shell脚本"></a>启动shell脚本</h2><p>编写shell脚本之后，可以通过<code>chmod +x</code>的方式，然后启动，不过用<code>sh 脚本名</code>的方式更加简洁，目前没有对比二者的优劣</p><h2 id="查找占用磁盘空间的文件"><a href="#查找占用磁盘空间的文件" class="headerlink" title="查找占用磁盘空间的文件"></a>查找占用磁盘空间的文件</h2><p>一层一层目录查找最占磁盘空间的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure><h2 id="top命令技巧"><a href="#top命令技巧" class="headerlink" title="top命令技巧"></a>top命令技巧</h2><p>shift+p: 按CPU使用率降序排序，用户查找CPU使用率最高的进程<br>shift+m: 按内存使用率降序排序</p><p>top -p <pid> -H ：查看进程中各线程详情</pid></p><h2 id="netstat命令技巧"><a href="#netstat命令技巧" class="headerlink" title="netstat命令技巧"></a>netstat命令技巧</h2><p>按pid统计连接数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -natp|awk <span class="string">'print $7'</span>|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure></p><p>持续积累中 ……</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列前言</title>
      <link href="/2018/08/10/Spring-Cloud%E7%B3%BB%E5%88%97%E5%89%8D%E8%A8%80/"/>
      <url>/2018/08/10/Spring-Cloud%E7%B3%BB%E5%88%97%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>笔者一些无聊的思考，也有一些对新手的建议</p><ol><li>了解一个新技术之前，它为什么出现，解决了什么问题，和现有的解决方案相比，它有什么优点，又有什么缺点(没有完美的方案)</li><li>DevOps，微服务dev易，ops难，有哪些技术可以实现ops，做到可持续交付，微服务的监控，管理怎么做，如何减少排查问题的复杂度</li><li>微服务如何根据业务拆分模块</li><li>Spring Cloud如何实现真正意义上的多语言，不要觉得公司只用java，同时用PHP，Go，Python太正常了，举个例子，阿里收购个公司，发现用的不是java就不收购了？收购之后要整合业务就让别人全改成java吗，现有的”老”系统重做吗</li><li>一口就吃个大胖子，一套框架解决公司所有业务？不可能的，架构应该遵循演进式原则</li><li>如何去学习Spring Cloud，由于Spring Boot 1.x版本和2.x版本的差别较大，往往因为一些教程的版本落后让人痛不欲生，所以自己摸索是一方面，比如找最新的教程，遇到问题多看官方文档也是个好习惯</li><li>关于看英文文档，只是一个适应的过程，下载一个有道翻译，只要有一些英语基础的人都能看懂，ps:本人四级考了2次飘过的学渣，:)逃，看多英文文档之后，甚至有种看不进去中文翻译的感觉，因为不好理解，还不如看英文，虽然浪费点时间，但是理解的快</li><li>关于遇到问题如何解决这件事，给新人一些建议，不要问leader一些很low的问题，我本人属于内向的人，习惯do my best之后再去问人，说下我的解决思路<ol><li>首先尽量看懂英文的错误提示</li><li>百度能帮你解决很多”常见”的问题</li><li>百度也不是个好东西，遇到难题，就会发现天下文章一大抄，抄来抄去就那么几篇</li><li>谷歌，多留意Stack Overflow的网站，同样需要你有耐心看懂英文</li><li>既然是开源项目，为什么不去github的issue搜一搜，笔者很喜欢这样做，不急的问题搜不到提个issue也比去某个论坛强</li><li>现在Github流行gitter在线聊天，可以更好和别人交流，尤其是项目作者。ps: 也可以看看别人的问题，毕竟都是坑</li><li>当然这些要看问题的具体情况，比如一个业务问题，你去github是没有意义的，最后多看官方文档，会避免很多问题，也会给你解决问题带来思路</li></ol></li><li>如何减少bug量，请正视测试用例，测试用例，测试用例</li></ol><p>咳咳，接下来说正题，<strong>Spring cloud</strong></p><p>在学习Spring cloud之后，我对它最直观的理解是: Spring cloud是用于构建分布式系统的一组通用工具集，秉承Spring的集成理念，Spring cloud并不会自己去开发一套工具，而是集成业界现有的优秀开源项目，这里的优秀必然是经得起生产环境验证，并且持续维护。Spring cloud自1.0开始就集成了Netflix OSS套件，通过Spring boot的autoconfigure简化配置，并且为其注入Spring运行环境，让开发者通过几个简单的注解就构建一个基于Netflix生产级别的分布式系统</p>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之事件监听</title>
      <link href="/2018/07/31/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
      <url>/2018/07/31/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
      <content type="html"><![CDATA[<p>在Spring Boot doc的<em>Application Events and Listeners</em>一章中提到，Spring Boot按以下顺序提供了6个事件，供开发者编写<code>ApplicationListener</code>监听相应的事件</p><pre><code>1.ApplicationStartingEvent：在开始运行时，监听器注册和初始化之后被触发2.ApplicationEnvironmentPreparedEvent：发现 Environment 被上下文使用时，上下文被创建之前触发3.ApplicationPreparedEvent：在启动刷新之前，bean定义被加载之后被触发4.ApplicationStartedEvent：上下文刷新之前，应用和命令行启动器运行之前触发5.ApplicationReadyEvent：在所有应用和命令行启动器调用之后，这表明应用已经准备好处理请求6.ApplicationFailedEvent：启动时出现异常触发</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>编写代码的难度不高，读者可根据自己的需求编写相应的listener，以ApplicationStartingEvent为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringBootListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationStartingEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;listening spring boot starting event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>根据文档中的提示，可以使用三种方式添加这6个事件的监听器</p><p>1.通过SpringApplication的addApplicationListener方法添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(SpringBootDocApplication.class,args).addApplicationListener(<span class="keyword">new</span> SpringBootListener());</span><br></pre></td></tr></table></figure><p>2.类似的用SpringApplicationBuilder实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(SpringBootDocApplication.class).listeners(<span class="keyword">new</span> SpringBootListener()).run(args);</span><br></pre></td></tr></table></figure><p>3.如果Listener很多，也可以写在配置文件中，在resources目录下新建META-INF/spring.factories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=com.ttyc.doc.extend.event.customer.SpringBootListener</span><br></pre></td></tr></table></figure><p>最终项目一启动便输出: listening spring boot starting event</p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一个对象的属性发生改变时，需要通知到依赖它的对象并自动更新</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>针对使用场景，如何用代码去实现这种效果，只要理解了观察者模式的基本原理，代码一目了然</p><ol><li>首先明确有两个对象: 观察者，被观察者，我更喜欢理解为监视器和目标</li><li>目标对象里维护一个注册列表，里面记录了注册过的监视器，对外提供注册列表的添加和移除api</li><li>目标发生改变时，遍历这个列表里的所有监视器，通过调用监视器的一个方法通知监视器</li></ol><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>原理并不难，可以说十分简单，两个类，注册列表用一个List集合表示，是否发生改变用一个布尔值表示，很容易手写出来。</p><p>首先是目标类，读者根据上述思路阅读代码应该没有什么障碍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要发生改变的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视器的注册列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Monitor&gt; monitors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否发生改变的标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registMonitor</span><span class="params">(Monitor monitor)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(monitor);</span><br><span class="line">        monitors.add(monitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注销监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregistMonitor</span><span class="params">(Monitor monitor)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(monitor);</span><br><span class="line">        monitors.remove(monitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.isChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.notifyMonitor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (monitors.size() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.isChanged)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Monitor monitor: monitors)&#123;</span><br><span class="line">                monitor.update(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通知结束后清除标志位</span></span><br><span class="line">            <span class="keyword">this</span>.isChanged = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是监视者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起个名字</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据目前对象发生的改变，做出反应</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前监视器为："</span> + getName() + <span class="string">",监视的对象已发生改变，目标名称为："</span> + target.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过测试类测试一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Monitor monitor1 = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor1.setName(<span class="string">"1号"</span>);</span><br><span class="line">        Monitor monitor2 = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor2.setName(<span class="string">"2号"</span>);</span><br><span class="line"></span><br><span class="line">        Target target = <span class="keyword">new</span> Target();</span><br><span class="line">        <span class="comment">// 测试两个监视器</span></span><br><span class="line">        target.registMonitor(monitor1);</span><br><span class="line">        target.registMonitor(monitor2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变属性</span></span><br><span class="line">        target.setName(<span class="string">"jim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注销其中一个</span></span><br><span class="line">        target.deregistMonitor(monitor1);</span><br><span class="line">        target.setName(<span class="string">"tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前监视器为：1号,监视的对象已发生改变，目标名称为：jim</span><br><span class="line">当前监视器为：2号,监视的对象已发生改变，目标名称为：jim</span><br><span class="line">当前监视器为：2号,监视的对象已发生改变，目标名称为：tom</span><br></pre></td></tr></table></figure><p>说明通知成功，并且注销监视器对象后，不再接收到通知</p><h2 id="JDK自带的观察者模式接口"><a href="#JDK自带的观察者模式接口" class="headerlink" title="JDK自带的观察者模式接口"></a>JDK自带的观察者模式接口</h2><p>为什么要用JDK自带的Observable(被观察者)，Observer(观察者)呢？</p><p>点开Observable的源码，since JDK1.0就有的一个类，十分古老，所以出现Vector也不足为奇了，再看里面的方法，关于修改Vector和changed的地方都被synchronized修饰，说明JDK对线程安全性考虑的很好</p><h2 id="JDK源码"><a href="#JDK源码" class="headerlink" title="JDK源码"></a>JDK源码</h2><p>Observable类中用于通知观察者的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自己翻译了下注释：我们不希望观察者在处理自己的监视器时，</span></span><br><span class="line"><span class="comment">         * 回调到所有的代码。我们从集合里取出每一个被观察者，并且</span></span><br><span class="line"><span class="comment">         * 存储观察者的需要同步的状态，但是不应该通知观察者们。</span></span><br><span class="line"><span class="comment">         * 任意竞争锁的最糟糕结果是</span></span><br><span class="line"><span class="comment">         *  1.一个新增的观察者可能错过通知</span></span><br><span class="line"><span class="comment">         *  2.一个最近注销的观察者在它不需要的时候被通知了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            ((Observer) arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现流程大致类似</p><h2 id="JDK方式代码实现"><a href="#JDK方式代码实现" class="headerlink" title="JDK方式代码实现"></a>JDK方式代码实现</h2><h3 id="Step-1-被观察者"><a href="#Step-1-被观察者" class="headerlink" title="Step 1: 被观察者"></a>Step 1: 被观察者</h3><p>继承Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(<span class="string">"name has been changed, now is "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-观察者"><a href="#Step-2-观察者" class="headerlink" title="Step 2: 观察者"></a>Step 2: 观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        Target target = (Target) o;</span><br><span class="line">        System.out.println(<span class="string">"I am be notified by "</span> + target.getName() + <span class="string">", message is "</span> + arg);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-验证"><a href="#Step-3-验证" class="headerlink" title="Step 3: 验证"></a>Step 3: 验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Target();</span><br><span class="line"></span><br><span class="line">        Watcher foo = <span class="keyword">new</span> Watcher();</span><br><span class="line">        Watcher bar = <span class="keyword">new</span> Watcher();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        target.addObserver(foo);</span><br><span class="line">        target.addObserver(bar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标发生改变, 自动通知监视器，并调用update方法</span></span><br><span class="line">        target.setName(<span class="string">"Jim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除监视器</span></span><br><span class="line">        target.deleteObserver(bar);</span><br><span class="line">        target.setName(<span class="string">"Kim"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>第一次setName通知了两个观察者，然后移除了bar观察者，下一次通知就只有一个观察者收到了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am be notified by Jim, message is name has been changed, now is Jim</span><br><span class="line">I am be notified by Jim, message is name has been changed, now is Jim</span><br><span class="line">I am be notified by Kim, message is name has been changed, now is Kim</span><br></pre></td></tr></table></figure><p>如果对JDK自带的线程安全实现方式不满意，可以自行实现这两个类</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring ContextRefreshedEvent事件</title>
      <link href="/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/"/>
      <url>/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">遇到的单词</span><br><span class="line">infrastructure ： 基础设施</span><br><span class="line">arbitrary : 任何的，所有的</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文主要在<a href="https://greedypirate.github.io/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a>的基础上研究Spring中的事件机制</p><p>ApplicationListener监听以下4个事件：ContextStartedEvent，ContextRefreshedEvent，ContextStartedEvent，ContextClosedEvent</p><p>实现对ApplicationContext刷新或初始化时的监听，测试中未出现加载两次的情况，如果需要加入<code>event.getApplicationContext().getParent()</code>判断</p><h2 id="监听ContextRefreshedEvent"><a href="#监听ContextRefreshedEvent" class="headerlink" title="监听ContextRefreshedEvent"></a>监听ContextRefreshedEvent</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextEnvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring Refreshed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自从Spring 4.2以后，可以使用@EventListener注解实现，相信用过Spring-Kafka的读者不会陌生这种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotateContextEvent</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRefresh</span><span class="params">(ContextRefreshedEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring Refreshed by annotated approach"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>实现起来很简单，接下来尝试下Spring中的自定义事件</p><p>自定义事件需要继承ApplicationEvent，这个类并没有什么深意，只是简单封装EventObject加入了时间戳</p><h3 id="Step-1-定义事件——被观察者"><a href="#Step-1-定义事件——被观察者" class="headerlink" title="Step 1 : 定义事件——被观察者"></a>Step 1 : 定义事件——被观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerEvent</span><span class="params">(Object source, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-定义监听器——观察者"><a href="#Step-2-定义监听器——观察者" class="headerlink" title="Step 2 : 定义监听器——观察者"></a>Step 2 : 定义监听器——观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomerEvent</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomerEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CustomerListener listening： CustomerEvent has been triggered, event name is "</span> + event.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-多了一步事件发布"><a href="#Step-3-多了一步事件发布" class="headerlink" title="Step 3 : 多了一步事件发布"></a>Step 3 : 多了一步事件发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CustomerEvent customerEvent = <span class="keyword">new</span> CustomerEvent(<span class="keyword">this</span>,<span class="string">"click"</span>);</span><br><span class="line">        publisher.publishEvent(customerEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDocApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(SpringBootDocApplication.class, args)</span><br><span class="line">                .getBean(CustomEventPublisher.class).publish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomerListener listening： CustomerEvent has been triggered, event name is click</span><br></pre></td></tr></table></figure><h3 id="如果再加入一个监听者呢？是否能通知到"><a href="#如果再加入一个监听者呢？是否能通知到" class="headerlink" title="如果再加入一个监听者呢？是否能通知到"></a>如果再加入一个监听者呢？是否能通知到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtraListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomerEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomerEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ExtraListener listening： CustomerEvent has been triggered, event name is "</span> + event.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CustomerListener listening： CustomerEvent has been triggered, event name is click</span><br><span class="line">ExtraListener listening： CustomerEvent has been triggered, event name is click</span><br></pre></td></tr></table></figure><hr><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftndnytxtsj30wa03maat.jpg" width="65%" align="left"></p><p>这里和观察者模式的遍历一样，调用所有的监听器<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftndouogerj312e0b2gok.jpg" width="65%" align="left"></p><p>进入getApplicationListeners方法，可以看到如何查找注册在event上的Listener<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftndn5aqzej30us0ion18.jpg" width="65%" align="left"></p><p>根据@Order注解对Listener排序，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareOrderComparator.sort(allListeners);</span><br></pre></td></tr></table></figure></p><p>对两个Listener加入@Order注解，果然值较小的ExtraListener先执行</p><p>注：@Order Lower values have higher priority</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><pre><code>对自己的猜想要多验证</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2" target="_blank" rel="noopener">https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2</a><br><a href="http://wiki.jikexueyuan.com/project/spring/custom-events-in-spring.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/spring/custom-events-in-spring.html</a><br><a href="https://blog.csdn.net/tuzongxun/article/details/53637159" target="_blank" rel="noopener">https://blog.csdn.net/tuzongxun/article/details/53637159</a><br><a href="https://blog.csdn.net/zhangningzql/article/details/52515890" target="_blank" rel="noopener">https://blog.csdn.net/zhangningzql/article/details/52515890</a></p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring 扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring InitializingBean接口</title>
      <link href="/2018/07/25/Spring-InitializingBean%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/07/25/Spring-InitializingBean%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h2 id="源文档"><a href="#源文档" class="headerlink" title="源文档"></a>源文档</h2><p>InitializingBean接口的doc文档解释如下，大意为：</p><p>实现这个接口的bean，可以在BeanFactory设置完所有的属性之后生效，例如，执行自定义的bean初始化，或者只是为了检查所有的属性被设置了</p><p>另一个选择是指定<code>init-method</code>，例如在XML中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface to be implemented by beans that need to react once all their</span><br><span class="line"> * properties have been set by a BeanFactory: for example, to perform custom</span><br><span class="line"> * initialization, or merely to check that all mandatory properties have been set.</span><br><span class="line"> *</span><br><span class="line"> * An alternative to implementing InitializingBean is specifying a custom</span><br><span class="line"> * init-method, for example in an XML bean definition.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>从接口描述上可以看出和指定<em>init-method</em>的作用应该是类似的,测试代码如下</p><h3 id="Step-1：实现InitializingBean接口"><a href="#Step-1：实现InitializingBean接口" class="headerlink" title="Step 1：实现InitializingBean接口"></a>Step 1：实现InitializingBean接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanExtend</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after properties set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bean inited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-使用java-config定义bean，指定init-method"><a href="#Step-2-使用java-config定义bean，指定init-method" class="headerlink" title="Step 2: 使用java config定义bean，指定init-method"></a>Step 2: 使用java config定义bean，指定init-method</h3><p>为了方便指定init-method,使用java config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InitBeanExtend <span class="title">initBeanExtend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InitBeanExtend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-编写测试用例"><a href="#Step-3-编写测试用例" class="headerlink" title="Step 3: 编写测试用例"></a>Step 3: 编写测试用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDocApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">InitBeanExtend initBeanExtend;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InitBeanExtend bean = InitBeanExtend.class.cast(initBeanExtend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">after properties <span class="built_in">set</span></span><br><span class="line">bean inited</span><br></pre></td></tr></table></figure><p>结果表明init-method是在afterPropertiesSet方法执行之后调用的</p><hr><p>查看<code>AbstractAutowireCapableBeanFactory</code>类源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeCustomInitMethod</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">...</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">final</span> Method initMethod = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">BeanUtils.findMethod(bean.getClass(), initMethodName) :</span><br><span class="line">ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者除了先后顺序的明显区别之外，可以看出init-method是通过反射达到目的的，而InitializingBean接口具有代码侵入性，有对Spring的依赖</p><p>注意: init-method方法不能有参数，否则将抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.BeanDefinitionValidationException: Couldn&apos;t find an init method named &apos;init&apos; on bean with name &apos;initBeanExtend&apos;</span><br></pre></td></tr></table></figure><p>在IDEA下会有编译警告<br><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftn30ruqgzj30lc03waas.jpg" width="65%" align="left"></p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>看过Spring源码的读者经常可以看到这个接口的使用，比如在bean初始化完属性之后，进行参数检查</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="DisposableBean接口"><a href="#DisposableBean接口" class="headerlink" title="DisposableBean接口"></a><code>DisposableBean</code>接口</h3><p>与初始化相对应的还有销毁，在Spring中提供DisposableBean接口，可用来优雅的退出Spring Boot程序，对前面的代码添加实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanExtend</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after properties set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bean inited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gracefully close applicationContext"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Java-EE5规范-PostConstruct和-PreDestroy"><a href="#Java-EE5规范-PostConstruct和-PreDestroy" class="headerlink" title="Java EE5规范@PostConstruct和@PreDestroy"></a>Java EE5规范<code>@PostConstruct</code>和<code>@PreDestroy</code></h3><p>Java EE5规范提出的两个影响Servlet声明周期的方法，添加在非静态方法上，分别会在Servlet实例初始化之后和被销毁之前执行一次</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring 扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot 官方文档阅读</title>
      <link href="/2018/07/24/Spring%20Boot%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/24/Spring%20Boot%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Spring Boot 版本 2.0.3.RELEASE</p><p>文档地址：<a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/</a></p><h2 id="遇到的英文单词"><a href="#遇到的英文单词" class="headerlink" title="遇到的英文单词"></a>遇到的英文单词</h2><ul><li>typical: 典型的</li><li>transitively: 可传递地</li><li>Several of : 几个</li><li>dives into : 深入</li><li>bootstrap : 引导</li><li>delegate : 委托</li><li>approach : 方法</li><li>perform : 执行</li><li>detect : 察觉，侦测，发现</li></ul><h2 id="Spring-CLI的使用"><a href="#Spring-CLI的使用" class="headerlink" title="Spring CLI的使用"></a>Spring CLI的使用</h2><p>step 1： sdkman安装spring-boot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install springboot</span><br></pre></td></tr></table></figure><p>step 2：运行groovy脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring run app.groovy</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisWillActuallyRun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从低版本的Spring-Boot升级到2-0"><a href="#从低版本的Spring-Boot升级到2-0" class="headerlink" title="从低版本的Spring Boot升级到2.0"></a>从低版本的Spring Boot升级到2.0</h2><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行一次后移除该依赖</p><h2 id="使用maven命令启动Spring-Boot"><a href="#使用maven命令启动Spring-Boot" class="headerlink" title="使用maven命令启动Spring Boot"></a>使用maven命令启动Spring Boot</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure><p>相应的gradle有:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle bootRun</span><br></pre></td></tr></table></figure></p><p>可以export系统变量(<strong>没有测试</strong>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_OPTS=-Xmx1024m</span><br></pre></td></tr></table></figure><h2 id="社区提供的Spring-Boot-starter"><a href="#社区提供的Spring-Boot-starter" class="headerlink" title="社区提供的Spring Boot starter"></a>社区提供的Spring Boot starter</h2><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters" target="_blank" rel="noopener">starters列表</a></p><h2 id="如何排除不想生效的Bean"><a href="#如何排除不想生效的Bean" class="headerlink" title="如何排除不想生效的Bean"></a>如何排除不想生效的Bean</h2><p>方式一：使用exclude属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration.class)</span><br></pre></td></tr></table></figure></p><p>方式二：如果classpath下没有这个类，使用类全名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(excludeName = <span class="string">"org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration"</span>)</span><br></pre></td></tr></table></figure></p><p>方式三：如果有多个，可以使用spring.autoconfigure.exclude属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.autoconfigure.exclude=DataSourceAutoConfiguration.class</span><br></pre></td></tr></table></figure></p><p>你可以同时在注解和属性上使用exclude</p><p>You can define exclusions both at the annotation level and by using the property.</p><h2 id="构造器注入可以省略-Autowired"><a href="#构造器注入可以省略-Autowired" class="headerlink" title="构造器注入可以省略@Autowired"></a>构造器注入可以省略@Autowired</h2><p><strong>If a bean has one constructor, you can omit the @Autowired</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Remote-Debug时的启动参数"><a href="#使用Remote-Debug时的启动参数" class="headerlink" title="使用Remote Debug时的启动参数"></a>使用Remote Debug时的启动参数</h2><p>仅供参考，自己还没有试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,<span class="built_in">suspend</span>=n </span><br><span class="line">-jar target/myapplication-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h2 id="IDEA中使用devtools的正确姿势"><a href="#IDEA中使用devtools的正确姿势" class="headerlink" title="IDEA中使用devtools的正确姿势"></a>IDEA中使用devtools的正确姿势</h2><p>修改代码后，需要点击: <strong>Build-&gt;Build Project</strong></p><h2 id="编程式的属性设置"><a href="#编程式的属性设置" class="headerlink" title="编程式的属性设置"></a>编程式的属性设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.setProperty(<span class="string">"spring.devtools.restart.enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line">SpringApplication.run(MyApp.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot提供的几个很有用的事件"><a href="#Spring-Boot提供的几个很有用的事件" class="headerlink" title="Spring Boot提供的几个很有用的事件"></a>Spring Boot提供的几个很有用的事件</h2><p>针对Spring boot提供的事件，编写自己的Listener,详见<strong><a href="https://greedypirate.github.io/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/">Spring-ContextRefreshedEvent事件</a></strong></p><ol><li>ApplicationStartingEvent：在开始运行时，监听器注册和初始化之后被触发</li><li>ApplicationEnvironmentPreparedEvent：发现 Environment 被上下文使用时，上下文被创建之前触发</li><li>ApplicationPreparedEvent：在启动刷新之前，bean定义被加载之后被触发</li><li>ApplicationStartedEvent：上下文刷新之前，应用和命令行启动器运行之前触发</li><li>ApplicationReadyEvent：在所有应用和命令行启动器调用之后，这表明应用已经准备好处理请求<br> 6.ApplicationFailedEvent：启动时出现异常触发</li></ol><h2 id="配置文件的名称和位置"><a href="#配置文件的名称和位置" class="headerlink" title="配置文件的名称和位置"></a>配置文件的名称和位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.config.name</span><br><span class="line">spring.config.location</span><br></pre></td></tr></table></figure><p><strong>注</strong>：这是两个需要很早初始化的属性，只能写在环境变量里(OS environment variable, a system property, or a command-line argument)</p><h2 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h2><ul><li>通过注入ApplicationArguments</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootstrapArgs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BootstrapArgs</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> myargs = args.containsOption(<span class="string">"myargs"</span>);</span><br><span class="line">        Assert.state(myargs, <span class="string">"无法获取自定义参数"</span>);</span><br><span class="line">        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();</span><br><span class="line">        System.out.println(<span class="string">"nonOptionArgs : "</span> + StringUtils.collectionToCommaDelimitedString(nonOptionArgs));</span><br><span class="line">        Set&lt;String&gt; optionNames = args.getOptionNames();</span><br><span class="line">        <span class="keyword">for</span> (String optionName : optionNames) &#123;</span><br><span class="line">            List&lt;String&gt; optionValues = args.getOptionValues(optionName);</span><br><span class="line">            System.out.println(optionValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现CommandLineRunner或ApplicationRunner接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnerBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志按环境生效"><a href="#日志按环境生效" class="headerlink" title="日志按环境生效"></a>日志按环境生效</h2><p>以下配置文件展示了多个环境，特定环境，非某个环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"test,dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.example.demo.controller"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产环境. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 非生产环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!production"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="日志使用Spring环境变量"><a href="#日志使用Spring环境变量" class="headerlink" title="日志使用Spring环境变量"></a>日志使用Spring环境变量</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"fluentHost"</span> <span class="attr">source</span>=<span class="string">"myapp.fluentd.host"</span></span></span><br><span class="line"><span class="tag"><span class="attr">defaultValue</span>=<span class="string">"localhost"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FLUENT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.more.appenders.DataFluentAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目首页查找规则"><a href="#项目首页查找规则" class="headerlink" title="项目首页查找规则"></a>项目首页查找规则</h2><p>支持html和模板引擎作为首页，首先会查找index.html，然后查找index template，还是没有时，会默认用一个欢迎页</p><h2 id="WebBindingInitializer"><a href="#WebBindingInitializer" class="headerlink" title="WebBindingInitializer"></a>WebBindingInitializer</h2><p>用于配置全局的类型转换器, 局部的可以在Controller中使用@InitBinder标记在方法上(<strong>百度所得</strong>)</p><h2 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h2><ol><li style="list-style: none"><input type="checkbox" checked> 搭建jenkins，配合git自动构建发布Spring Boot项目</li><li>研究编排系统Docker，K8s</li><li>研究项目里的Spring扩展</li><li>总结分布式链路追踪</li><li>mybatis官方文档, 源码, mybatis-plus, 通用mapper，代码生成</li><li>spring boot多数据源，分库分表，sharding-jdbc</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 官方文档阅读 </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈之链栈</title>
      <link href="/2017/07/19/%E6%A0%88%E4%B9%8B%E9%93%BE%E6%A0%88/"/>
      <url>/2017/07/19/%E6%A0%88%E4%B9%8B%E9%93%BE%E6%A0%88/</url>
      <content type="html"><![CDATA[<h1 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h1><p>链栈只是单链表的一个简单应用，只要理解单链表的头插法，链栈的出栈入栈很好理解。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>linkstack.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><p>LinkStack.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linkstack.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initLinkStack</span><span class="params">(LinkStack *&amp;ls)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(LinkStack *&amp;ls, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(LinkStack *&amp;ls, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">peek</span><span class="params">(LinkStack *ls, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(LinkStack *ls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkStack * ls;</span><br><span class="line">initLinkStack(ls);</span><br><span class="line"></span><br><span class="line">push(ls,<span class="number">10</span>);</span><br><span class="line">push(ls,<span class="number">20</span>);</span><br><span class="line">push(ls,<span class="number">30</span>);</span><br><span class="line">printStack(ls);</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line">pop(ls,e);</span><br><span class="line">printStack(ls);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initLinkStack</span><span class="params">(LinkStack *&amp;ls)</span></span>&#123;</span><br><span class="line">ls = (LinkStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(LinkStack *&amp;ls)</span></span>&#123;</span><br><span class="line">LinkStack *p = ls, *q;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(q != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈，就是一个头插法，很简单</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(LinkStack *&amp;ls, ElemType e)</span></span>&#123;</span><br><span class="line">LinkStack* node = (LinkStack*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">node-&gt;next = ls-&gt;next;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">ls-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(LinkStack *&amp;ls, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ls-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈空，无法出栈"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkStack *p = ls-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">ls-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">peek</span><span class="params">(LinkStack *ls, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ls-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = ls-&gt;next-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(LinkStack *ls)</span></span>&#123;</span><br><span class="line">LinkStack *q = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,q-&gt;data);</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">302010</span><br><span class="line">2010</span><br></pre></td></tr></table></figure><p>记录:二进制和十进制的转换<br>我们知道十进制转换为二进制采用余数倒转法，二进制转换为十进制使用2的指数与位数乘积之和</p><p>101000101<br>第一个1之和有8位，2^8为256，第二个1之和有6位，2^6为64，以此类推，相加为256+64+4+1=325</p><p>417<br>417位于256到512之间，256=2^8，则100000000，1后有8个0，<br>417减去256=161，位于128到256之间，1后有7个0，和之前的拼接，即110000000<br>以此类推，得出110100001</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈之顺序栈</title>
      <link href="/2017/07/14/%E6%A0%88%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2017/07/14/%E6%A0%88%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈也是线性表的一种，它描述了一种后入先出的操作，可以用顺序存储结构和链式存储结构实现<br>顺序栈的定义由两部分组成：</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MAX_SIZE]; <span class="comment">//存储数据的数组</span></span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">//栈顶指针，它一开始指向-1</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>sqstack.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MAX_SIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>SqStack.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqstack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>; <span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>; <span class="comment">//销毁栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//获取长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//输出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType e)</span></span>; <span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType &amp;e)</span></span>; <span class="comment">//出栈</span></span><br><span class="line"><span class="function">ElemType <span class="title">peek</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SqStack *<span class="built_in">stack</span>;</span><br><span class="line">initStack(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">push(<span class="built_in">stack</span>,<span class="number">10</span>);</span><br><span class="line">push(<span class="built_in">stack</span>,<span class="number">20</span>);</span><br><span class="line">push(<span class="built_in">stack</span>,<span class="number">30</span>);</span><br><span class="line">printStack(<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈长度为:%d\n"</span>,getLength(<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line">pop(<span class="built_in">stack</span>,e);</span><br><span class="line">printStack(<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈长度为:%d\n"</span>,getLength(<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">e = peek(<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈顶元素为:%d"</span>,e);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">stack</span> = (SqStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqStack));</span><br><span class="line"><span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">stack</span>-&gt;top + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;=<span class="built_in">stack</span>-&gt;top; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,<span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top+<span class="number">1</span> == MAX_SIZE)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈满，无法入栈\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>-&gt;top++;</span><br><span class="line"><span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈空，无可出栈元素"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line"><span class="built_in">stack</span>-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">peek</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">102030栈长度为:3</span><br><span class="line">1020栈长度为:2</span><br><span class="line">栈顶元素为:20</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性表之双链表</title>
      <link href="/2017/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/2017/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="双链表概述"><a href="#双链表概述" class="headerlink" title="双链表概述"></a>双链表概述</h1><p>双链表也是线性表的一种，它的全称是：线性双向链接表，它有以下特点：<br>在每个节点中除包含有数值域外,设置有两个指针域，分别用以指向其前驱节点和后继节点。<br>既可以依次向后访问每一个节点，也可以依次向前访问每一个节点。<br><img src="https://img.blog.csdn.net/20160724112429339" alt="这里写图片描述"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>dlinklist.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">prior</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;DLinkList;</span><br></pre></td></tr></table></figure><p>DLinkList.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dlinklist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubleLinkList</span><span class="params">(DLinkList * dll)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DLinkList * dll;</span><br><span class="line">ElemType arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">headInit(dll,arr,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"头插法:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line"></span><br><span class="line">tailInit(dll,arr,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"尾插法:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line"></span><br><span class="line">insertElement(dll,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"在第3个位置上插入6之后:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line">deleteElement(dll,<span class="number">3</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除第3个元素之后:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">dll = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line"><span class="comment">//头节点两个指针为NULL</span></span><br><span class="line">dll-&gt;next = dll-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">DLinkList * node;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">node = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">node-&gt;data = arr[i];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *插入,画图，依次赋值node-&gt;next，node-&gt;prior，dll-&gt;next(dll-&gt;prior永远为null)</span></span><br><span class="line"><span class="comment"> *可以发现除了第一次插入，以后插入的节点都要设置dll-&gt;next-&gt;prior = node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">node-&gt;next = dll-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(dll-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">dll-&gt;next-&gt;prior = node;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;prior = dll;</span><br><span class="line">dll-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">dll = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line"><span class="comment">//头节点两个指针为NULL</span></span><br><span class="line">dll-&gt;next = dll-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">DLinkList * node, *r;</span><br><span class="line">r = dll;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">node = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">node-&gt;data = arr[i];</span><br><span class="line"><span class="comment">//尾插,画图很简单</span></span><br><span class="line">node-&gt;prior = r;</span><br><span class="line">r-&gt;next = node;</span><br><span class="line">r=node;</span><br><span class="line">&#125;</span><br><span class="line">r=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点，找出前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DLinkList *p = dll, *node;</span><br><span class="line"><span class="keyword">while</span>(i&lt;pos<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入的位置不合法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//分配节点</span></span><br><span class="line">node = (DLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p-&gt;next;</span><br><span class="line">node-&gt;prior = p;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">p-&gt;next-&gt;prior = node;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DLinkList *p = dll, *node;</span><br><span class="line"><span class="keyword">while</span>(i&lt;pos<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">node = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;<span class="comment">//如果p是尾节点，要删除的是尾节点的下一个节点，错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = node-&gt;data;</span><br><span class="line">p-&gt;next = node-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)&#123; <span class="comment">//此时p-&gt;next已经改变，如果node-&gt;next为NULL.NULL不需要设置prior</span></span><br><span class="line">node-&gt;next-&gt;prior = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(node);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubleLinkList</span><span class="params">(DLinkList * dll)</span></span>&#123;</span><br><span class="line"><span class="comment">//不需要输出头节点的data</span></span><br><span class="line">DLinkList *p = dll-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">头插法:54321</span><br><span class="line">尾插法:12345</span><br><span class="line">在第3个位置上插入6之后:126345</span><br><span class="line">删除第3个元素之后:12345</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性表之单链表</title>
      <link href="/2017/07/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2017/07/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="单链表概述"><a href="#单链表概述" class="headerlink" title="单链表概述"></a>单链表概述</h1><p>一张图简单解释下单链表的结果，对头节点，头指针，首节点混肴的同学可以再看看<br><img src="https://img-blog.csdn.net/20160723154837259" alt="这里写图片描述"></p><p>以下是单链表的头文件和相关操作，这门课很抽象，我个人认为只在脑海中去理解很难做到，因为指针指来指去是个人都会晕，建议大家用笔在纸上画出来，更容易理解<br>比如单链表的尾插法， 在纸上一画瞬间理解了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>linklist.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br></pre></td></tr></table></figure><p>LinkList.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linklist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(LinkList * &amp;ls, <span class="keyword">int</span> msg[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(LinkList * &amp;ls, <span class="keyword">int</span> msg[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkList</span><span class="params">(LinkList *ls)</span></span>;<span class="comment">//输出链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(LinkList *&amp;ls)</span></span>;<span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkList *ls)</span></span>;<span class="comment">//获取长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getElementByIndex</span><span class="params">(LinkList *ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>;<span class="comment">//通过下标获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(LinkList *ls,ElemType e)</span></span>;<span class="comment">//获取元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(LinkList *&amp;ls,<span class="keyword">int</span> pos, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(LinkList *&amp;ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相比于顺序表，单链表不需要连续的空间，没有冗余的空间，而且不用扩容，插入和删除操作效率高</span></span><br><span class="line"><span class="comment"> * 但是其他操作复杂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList * ls;</span><br><span class="line"></span><br><span class="line">ElemType arr1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">headInit(ls,arr1,<span class="number">5</span>);</span><br><span class="line">printLinkList(ls);</span><br><span class="line"></span><br><span class="line">ElemType arr2[] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">tailInit(ls,arr2,<span class="number">5</span>);</span><br><span class="line">printLinkList(ls);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n单链表的长度是:%d\n"</span>,getLength(ls));</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">if</span>(getElementByIndex(ls,<span class="number">5</span>,e))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个元素的值是:%d\n"</span>,<span class="number">5</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = getElementIndex(ls,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(pos)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d的位置是:%d\n"</span>,<span class="number">10</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span>(insert(ls,<span class="number">6</span>,<span class="number">11</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d插入成功\n"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">printLinkList(ls);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(deleteElement(ls,<span class="number">5</span>,e))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n要删除的第%d个元素是%d,已删除成功\n"</span>,<span class="number">5</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">printLinkList(ls);</span><br><span class="line">destory(ls);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">头插法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(LinkList * &amp;ls, ElemType msg[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">LinkList *node;</span><br><span class="line">ls = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="comment">//产生一个新节点</span></span><br><span class="line">node = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">node-&gt;data = msg[i];</span><br><span class="line"><span class="comment">//把该节点插到头节点的后面，画图</span></span><br><span class="line">node-&gt;next = ls-&gt;next;</span><br><span class="line">ls-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">尾插法:定义一个尾指针指向尾节点，因为每次都在尾节点后面插，就把尾节点当作头节点去插</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(LinkList * &amp;ls, <span class="keyword">int</span> msg[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ls = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">LinkList *node,*tail = ls; <span class="comment">//尾指针最初也指向头节点</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">node = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">node-&gt;data = msg[i];</span><br><span class="line">tail-&gt;next = node;</span><br><span class="line">tail = node; <span class="comment">//尾指针指向新插入的节点，即尾节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一开始没加这句，导致tail-&gt;next成为野指针,导致一直输出</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkList</span><span class="params">(LinkList *ls)</span> </span>&#123;</span><br><span class="line">LinkList *p = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的消耗要把每一个节点都free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(LinkList *&amp;ls)</span></span>&#123;</span><br><span class="line">LinkList * head = ls, * p = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁最后一个</span></span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是空表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkList *ls)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ls-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkList *ls)</span></span>&#123;</span><br><span class="line">LinkList * p = ls;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第i个节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getElementByIndex</span><span class="params">(LinkList *ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">LinkList * p = ls;</span><br><span class="line"><span class="keyword">while</span>(i&lt;pos &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后要么i&lt;pos不成立，也就是找到了，要么ls==NULL，也就是到表尾了</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在第%d个元素\n"</span>,pos);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(LinkList *ls,ElemType e)</span></span>&#123;</span><br><span class="line"><span class="comment">//用pos记录下标</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">LinkList *p = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对循环结束后的条件进行判断</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的插入需要记录前一个节点,所以找到pos-1即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(LinkList *&amp;ls,<span class="keyword">int</span> pos, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">LinkList * p = ls; <span class="comment">//不要直接用ls</span></span><br><span class="line"><span class="comment">//pos-1,假如在第5个位置插入，就找出第四个节点，让它指向e</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; pos<span class="number">-1</span> &amp;&amp; p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//为插入的节点分配空间</span></span><br><span class="line">LinkList * node = (LinkList *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">node-&gt;data = e;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除同样也要找到pos-1个节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(LinkList *&amp;ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">LinkList * p = ls , *temp;</span><br><span class="line"><span class="keyword">while</span>(i &lt; pos<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//删除节点，记得先把地址用temp保存起来，用于free</span></span><br><span class="line">temp = p-&gt;next;</span><br><span class="line">e = temp-&gt;data;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">54321678910</span><br><span class="line">单链表的长度是:5</span><br><span class="line">第5个元素的值是:10</span><br><span class="line">10的位置是:5</span><br><span class="line">11插入成功</span><br><span class="line">67891011</span><br><span class="line">要删除的第5个元素是10,已删除成功</span><br><span class="line">678911</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性表之顺序表</title>
      <link href="/2017/07/07/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2017/07/07/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>作为一个计科大学生，没有学好数据结构一直是我的遗憾，博主主攻java web方向，为了不当一个低端码农，决心静下心来学习数据结构，但是和我当初自学java一样，都存在入门难的问题，严蔚敏的数据结构一直是我的噩梦，概念多且抽象，我希望通过敲代码这种实战的方式学习数据结构，也就放弃了课本。<br>后来在CSDN上看到贺利坚的课程(收费)，和很多人一样，并不想买，后来在贴吧看到免费的观看地址（百度锐聘），就慢慢地开始学，同时写博客记录我的学习过程。<br>在此十分感谢贺利坚老师，看了他的博客后不止教会了我数据结构，也为我解开了诸多学习上的疑惑</p></blockquote><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>数据结构系列文章时从博主的CSDN中迁移过来的，重新进行排版优化，切莫闹出举报博主自己抄袭自己的笑话(咳咳，我已经授权抄袭自己了)</p><h1 id="线性表概述"><a href="#线性表概述" class="headerlink" title="线性表概述"></a>线性表概述</h1><p>线性表描述了一种线性的逻辑结构，元素之间是一对一的关系，而在存储结构上分为顺序存储和链式存储，<br>分别简称为：顺序表和链表<br>以下是顺序表的定义方式以及操作，运行环境为Eclipse CDT，程序用到少部分C++特性，新建时选择C++ project，在运行main之前，先要右键项目，进行build project</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>sqlist.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INCREMENT_SIZE 10</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ElemType可以表示一个复杂的结构体</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">int age;</span></span><br><span class="line"><span class="comment">char name[32];</span></span><br><span class="line"><span class="comment">&#125;ElemType;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MAX_SIZE];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>SqList.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqlist.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSqList</span><span class="params">(SqList *&amp;sl)</span></span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqList *sl)</span></span>; <span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCapacity</span><span class="params">(SqList *&amp;sl)</span></span>; <span class="comment">//扩容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySqList</span><span class="params">(SqList *&amp;sl)</span></span>; <span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqList *sl)</span></span>; <span class="comment">//获取长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList *sl)</span></span>; <span class="comment">//输出顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>; <span class="comment">//删除下标为i的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType e)</span></span>; <span class="comment">//在i处插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getElementByIndex</span><span class="params">(SqList *sl, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>; <span class="comment">//通过下标i获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(SqList *&amp;sl, ElemType e)</span></span>;<span class="comment">//获取元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqList *sl;</span><br><span class="line">ElemType ele;</span><br><span class="line">initSqList(sl);</span><br><span class="line">insertElement(sl, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">insertElement(sl, <span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">insertElement(sl, <span class="number">3</span>, <span class="number">30</span>);</span><br><span class="line">insertElement(sl, <span class="number">4</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">deleteElement(sl,<span class="number">4</span>,ele);</span><br><span class="line">printList(sl);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"元素%d的位置是：%d\n"</span>,<span class="number">20</span>, getElementIndex(sl,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">getElementByIndex(sl, <span class="number">2</span>, ele);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个元素是：%d\n"</span>,<span class="number">2</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSqList</span><span class="params">(SqList *&amp;sl)</span> </span>&#123;</span><br><span class="line">sl = (SqList *)<span class="built_in">malloc</span>(MAX_SIZE*<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">sl-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqList *sl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (sl-&gt;length == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCapacity</span><span class="params">(SqList *&amp;sl)</span> </span>&#123;</span><br><span class="line">sl = (SqList *)<span class="built_in">realloc</span>(sl,(sl-&gt;length + INCREMENT_SIZE));</span><br><span class="line"><span class="keyword">if</span> (!sl) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"扩容失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意是length，不是MAX_SIZE,假如这不是第一次扩容</span></span><br><span class="line">sl-&gt;length += INCREMENT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySqList</span><span class="params">(SqList *&amp;sl)</span> </span>&#123;</span><br><span class="line"><span class="built_in">free</span>(sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqList *sl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sl-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList *sl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(sl)) &#123;<span class="comment">//是否是空表</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"List is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; sl-&gt;length; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,sl-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果list里只有10个元素，你最多能在11的位置上插入，不能大于11</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;sl-&gt;length+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入的位置不合法\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果超过容量，就扩容</span></span><br><span class="line"><span class="keyword">if</span> (sl-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">addCapacity(sl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">//从最后一个元素 到第i-1个元素后移，自己在纸上画出来，很容易理解j&gt;=i-1</span></span><br><span class="line"><span class="keyword">for</span> (j=sl-&gt;length<span class="number">-1</span>; j&gt;=i - <span class="number">1</span>; j--)&#123;</span><br><span class="line"><span class="comment">//为什么是j+1 = j,不是j = j-1，想想最后一个元素是怎么移动的就很好理解了</span></span><br><span class="line">sl-&gt;data[j + <span class="number">1</span>] = sl-&gt;data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把元素插入到下标为(i-1)的位置</span></span><br><span class="line">sl-&gt;data[i - <span class="number">1</span>] = e;</span><br><span class="line"><span class="comment">//记得length++</span></span><br><span class="line">sl-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;sl-&gt;length) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入的位置不合法\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = sl-&gt;data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; sl-&gt;length; j++) &#123;</span><br><span class="line">sl-&gt;data[j - <span class="number">1</span>] = sl-&gt;data[j];</span><br><span class="line">&#125;</span><br><span class="line">sl-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(SqList *&amp;sl, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sl-&gt;length &amp;&amp; sl-&gt;data[i] != e) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; sl-&gt;length) &#123;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">//这个时候的i是从0开始算的，所以要+1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getElementByIndex</span><span class="params">(SqList *sl, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;sl-&gt;length) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"访问的位置不合法"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = sl-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除元素x，x不止一个</span></span><br><span class="line"><span class="comment">找到，然后删除, O(n) = n*n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle_1</span><span class="params">(SqList *sl, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">while</span> ((i = getElementIndex(sl, x)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">deleteElement(sl, i, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除元素x，x不止一个</span></span><br><span class="line"><span class="comment">将O(n) 降低到 O(n)</span></span><br><span class="line"><span class="comment">算法：用复制的思想</span></span><br><span class="line"><span class="comment">重新从0开始计数，只要第n个元素不等于x，就移动到前面去(同时把以前的覆盖)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle_2</span><span class="params">(SqList *sl, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sl-&gt;length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sl-&gt;data[i] != x) &#123;</span><br><span class="line">sl-&gt;data[k] = sl-&gt;data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sl-&gt;length = k; <span class="comment">//删除x后，k就是长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
