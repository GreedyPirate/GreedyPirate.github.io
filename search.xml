<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>kafka本地启动后不打印日志问题</title>
      <link href="/2020/01/25/kafka%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E5%90%8E%E4%B8%8D%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/25/kafka%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E5%90%8E%E4%B8%8D%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<blockquote><p>2020年的春节新冠状病毒肆虐，只能宅在家里(天赋异禀)，闲来无事再次打开kafka项目阅读源码，但是从一开始就有个小问题困扰着我，<br>kafka本地启动后不打印日志，虽然能运行，但是心里总是很难受，今日下定决心解决之</p></blockquote><p>在<a href="https://greedypirate.github.io/2019/10/29/kafka%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">kafka源码环境搭建</a>一文中，启动kafka之后，控制台如下<br><img src="https://ae01.alicdn.com/kf/H0dccf862d1364893ac367dce5856bc72l.png" alt=""><br>和我们用命令启动不一样，完全没有日志产生</p><p>虽然我通过百度，Stack Overflow等多个地方查找，想要解决这个问题，<br>但解决方案还是在图片中的链接里:<a href="http://www.slf4j.org/codes.html#StaticLoggerBinder" target="_blank" rel="noopener">http://www.slf4j.org/codes.html#StaticLoggerBinder</a></p><p>根据下面的提示，只需要替换这三个jar的任意一个即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Placing one (and only one) of slf4j-nop.jar slf4j-simple.jar, slf4j-log4j12.jar, slf4j-jdk14.jar</span><br></pre></td></tr></table></figure></p><p>剩下的就简单了，通过本人的摸索(没有学习过gradle)，kafka的依赖管理在如下位置<br><img src="https://ae01.alicdn.com/kf/He7f6efd2a0c64e20b1eaffc19ff905e8e.png" alt=""></p><p>log4j_bugfix是我新加的一个依赖，分别在dependencies.gradle的versions和libs数组的最后一行添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">versions += [</span><br><span class="line">...</span><br><span class="line">log4j_bugfix: &quot;1.7.30&quot;</span><br><span class="line">]</span><br><span class="line">libs += [</span><br><span class="line">... </span><br><span class="line">log4jBugFix:&quot;org.slf4j:slf4j-log4j12:$versions.log4j_bugfix&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>完成以上步骤后，找到根目录下的build.gradle文件，大约来543行，添加刚才新增的依赖<br><img src="https://ae01.alicdn.com/kf/Hba525c213131420088f4420f7bce7a90z.png" alt=""></p><p>最后在启动参数中加入log的目录配置:-Dkafka.logs.dir=<br><img src="https://ae01.alicdn.com/kf/Hbf9d0dee5d5246c69b2febb82458e13ap.png" alt=""></p><p>启动kafka，日志开始正常打印，大功告成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[2020-01-25 21:34:51,570] INFO Registered kafka:type=kafka.Log4jController MBean (kafka.utils.Log4jControllerRegistration$)</span><br><span class="line">[2020-01-25 21:34:52,824] INFO starting (kafka.server.KafkaServer)</span><br><span class="line">[2020-01-25 21:34:52,826] INFO Connecting to zookeeper on localhost:2181/cluster_201 (kafka.server.KafkaServer)</span><br><span class="line">[2020-01-25 21:34:52,920] INFO [ZooKeeperClient] Initializing a new session to localhost:2181. (kafka.zookeeper.ZooKeeperClient)</span><br><span class="line">[2020-01-25 21:34:52,971] INFO Client environment:zookeeper.version=3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 00:39 GMT (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">[2020-01-25 21:34:52,971] INFO Client environment:host.name=localhost (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">[2020-01-25 21:34:52,971] INFO Client environment:java.version=1.8.0_161 (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">[2020-01-25 21:34:52,971] INFO Client environment:java.vendor=Oracle Corporation (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka server端源码分析之副本同步</title>
      <link href="/2020/01/08/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/01/08/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常我们会为了提高系统并发能力、可伸缩性，为topic设置多个分区，每个分区副本数通常设置为3个，其中1个为leader副本，其余2个follower副本为冗余备份使用。</p><p>在producer端为了保证消息不丢失，通常设置ack=-1，并搭配失败重试机制</p><p>本文主要讨论broker端写入leader副本后，follower副本如何同步消息，以及如何更新HighWatermark，并使Purgatory延迟队列中的PRODUCE请求完成(complete)，响应客户端</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>follower副本同步是通过ReplicaFetcherThread线程(以下简称fetcher线程)完成的</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka server端源码分析之拉取消息</title>
      <link href="/2019/12/17/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF/"/>
      <url>/2019/12/17/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF/</url>
      <content type="html"><![CDATA[<blockquote><p>发送fetch请求的对象有2类：client和follower，client拉取时有高水位线的限制，follower则没有，本文仅介绍client，<br>follower拉取时涉及到副本同步，以后单独分析</p></blockquote><h1 id="术语回顾"><a href="#术语回顾" class="headerlink" title="术语回顾"></a>术语回顾</h1><p><img src="https://ae01.alicdn.com/kf/H7a61234572984b95a98cc61ef9abf1f4C.png" alt=""><br>在kafka消息中有2个重要的术语：HW(HighWatermark)，LEO(Log End Offset)</p><p>HW会在生产者发送的消息写入后，等待follower副本同步完成后更新, HW之前的消息称之为committed(已提交的消息)，消费者只能消费HW之前的消息<br>而LEO则是在消息写入到本地leader副本后立即更新，它的值是最后一条消息的下一个位移，图中15被虚线标注，表示LEO处没有消息</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="拉取流程"><a href="#拉取流程" class="headerlink" title="拉取流程"></a>拉取流程</h2><p>拉取消息的流程和写入消息的流程是类似的，都是经过那么几个类层层包装，可以参考之前的<a href="">kafka server端源码分析之接收消息</a></p><h2 id="client端发送的FETCH请求"><a href="#client端发送的FETCH请求" class="headerlink" title="client端发送的FETCH请求"></a>client端发送的FETCH请求</h2><p>client端发送的FetchRequest在Fetcher#sendFetches方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">                    .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">                    .isolationLevel(isolationLevel)</span><br><span class="line">                    .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">                    .metadata(data.metadata())</span><br><span class="line">                    .toForget(data.toForget());</span><br></pre></td></tr></table></figure><p>其中大部分的参数大家都很熟悉，主要说2个不常见的参数：metadata和toForget<br>这两个参数是kafka 1.1.0版本之后新加的，用于FetchSession的实现，主要解决了在server端没有接收到消息时，消费者会空轮询，在topic分区较多时，FetchSession为Fetch请求体起到了瘦身的作用</p><p>想象一下每个client不止订阅一个topic，也会不止分配到一个TopicPartition，消费者在发送FETCH请求之前，要知道每个partition的leader副本在哪个broker上，然后按照broker分组，fetch请求体很大并不是空穴来风，kafka对此进行优化是很有必要的</p><p>以下是Fetch请求体格式，红框内的参数先不必关注，之后分析FetchSession相关内容<br><img src="https://ae01.alicdn.com/kf/Haf611a59880e479d953217e41e26eaf47.png" alt="FetchRequest"></p><h2 id="FETCH请求"><a href="#FETCH请求" class="headerlink" title="FETCH请求"></a>FETCH请求</h2><p>FETCH请求同样也是在KafkaApis类中处理，此处省略部分代码，如FetchSession相关，关注拉取的核心流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">handleFetchRequest</span><span class="params">(request: RequestChannel.Request)</span> </span>&#123;</span><br><span class="line">    val versionId = request.header.apiVersion</span><br><span class="line">    val clientId = request.header.clientId</span><br><span class="line">    val fetchRequest = request.body[FetchRequest]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FetchSession来做增量的fetch请求</span></span><br><span class="line">    val fetchContext = fetchManager.newContext(fetchRequest.metadata(),</span><br><span class="line">          fetchRequest.fetchData(),</span><br><span class="line">          fetchRequest.toForget(),</span><br><span class="line">          <span class="comment">// isFromFollower： replicaId是否大于0表示是follower</span></span><br><span class="line">          fetchRequest.isFromFollower())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常响应方法：传入一个Error，返回发送异常时的Response</span></span><br><span class="line">    def errorResponse[T &gt;: MemoryRecords &lt;: BaseRecords](error: Errors): FetchResponse.PartitionData[T] = &#123;</span><br><span class="line">      <span class="keyword">new</span> FetchResponse.PartitionData[T](error, FetchResponse.INVALID_HIGHWATERMARK, FetchResponse.INVALID_LAST_STABLE_OFFSET,</span><br><span class="line">        FetchResponse.INVALID_LOG_START_OFFSET, <span class="keyword">null</span>, MemoryRecords.EMPTY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val erroneous = mutable.ArrayBuffer[(TopicPartition, FetchResponse.PartitionData[Records])]()</span><br><span class="line">    val interesting = mutable.ArrayBuffer[(TopicPartition, FetchRequest.PartitionData)]()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选TP, 放入interesting集合中</span></span><br><span class="line">    <span class="keyword">if</span> (fetchRequest.isFromFollower()) &#123;</span><br><span class="line">    <span class="comment">// 暂不关心follower fetch</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// foreachPartition由FullFetchContext和IncrementalFetchContext实现</span></span><br><span class="line">      fetchContext.foreachPartition &#123; (topicPartition, data) =&gt;</span><br><span class="line">      <span class="comment">// consumer要有READ读权限，而且在metadata里有记录</span></span><br><span class="line">        <span class="keyword">if</span> (!authorize(request.session, Read, Resource(Topic, topicPartition.topic, LITERAL)))</span><br><span class="line">          erroneous += topicPartition -&gt; errorResponse(Errors.TOPIC_AUTHORIZATION_FAILED)</span><br><span class="line">        <span class="comment">// 元数据中要有该topicPartition</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!metadataCache.contains(topicPartition))</span><br><span class="line">          erroneous += topicPartition -&gt; errorResponse(Errors.UNKNOWN_TOPIC_OR_PARTITION)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          interesting += (topicPartition -&gt; data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应的回调函数，最后分析</span></span><br><span class="line">    <span class="function">def <span class="title">processResponseCallback</span><span class="params">(responsePartitionData: Seq[(TopicPartition, FetchPartitionData)</span>]): Unit </span>= &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interesting.isEmpty)</span><br><span class="line">      processResponseCallback(Seq.empty)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// replicaManager为入口调用</span></span><br><span class="line">      <span class="comment">// call the replica manager to fetch messages from the local replica</span></span><br><span class="line">      replicaManager.fetchMessages(</span><br><span class="line">        fetchRequest.maxWait.toLong,</span><br><span class="line">        fetchRequest.replicaId,</span><br><span class="line">        fetchRequest.minBytes,</span><br><span class="line">        fetchRequest.maxBytes,</span><br><span class="line">        versionId &lt;= <span class="number">2</span>, <span class="comment">// 从后面的代码看，version &lt;= 2时，至少返回第一条消息，哪怕它的大小超出了maxBytes</span></span><br><span class="line">        interesting,</span><br><span class="line">        replicationQuota(fetchRequest),</span><br><span class="line">        processResponseCallback,</span><br><span class="line">        fetchRequest.isolationLevel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleFetchRequest方法主要是过滤请求中可用的TopicPartition作为interesting参数，最后连带响应的回调函数一起传给replicaManager的fetchMessages方法，processResponseCallback响应回调最终再分析</p><h1 id="ReplicaManager-fetchMessages"><a href="#ReplicaManager-fetchMessages" class="headerlink" title="ReplicaManager#fetchMessages"></a>ReplicaManager#fetchMessages</h1><p>fetchMessages方法中主要调用了readFromLog-&gt;readFromLocalLog方法来读取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fetchMessages</span><span class="params">(timeout: Long,</span></span></span><br><span class="line"><span class="function"><span class="params">                    replicaId: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                    fetchMinBytes: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                    fetchMaxBytes: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                    hardMaxBytesLimit: Boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">                    fetchInfos: Seq[(TopicPartition, PartitionData)</span>],</span></span><br><span class="line"><span class="function">                    quota: ReplicaQuota </span>= UnboundedQuota,</span><br><span class="line">                    responseCallback: Seq[(TopicPartition, FetchPartitionData)] =&gt; Unit,</span><br><span class="line">                    isolationLevel: IsolationLevel) &#123;</span><br><span class="line">    val isFromFollower = Request.isValidBrokerId(replicaId)</span><br><span class="line">    val fetchOnlyFromLeader = replicaId != Request.DebuggingConsumerId &amp;&amp; replicaId != Request.FutureLocalReplicaId <span class="comment">// 还有不从leader同步的？</span></span><br><span class="line">    <span class="comment">// follower fetch时没有高水位线的限制</span></span><br><span class="line">    val fetchOnlyCommitted = !isFromFollower &amp;&amp; replicaId != Request.FutureLocalReplicaId</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先定义后调用</span></span><br><span class="line">    <span class="function">def <span class="title">readFromLog</span><span class="params">()</span>: Seq[<span class="params">(TopicPartition, LogReadResult)</span>] </span>= &#123;</span><br><span class="line">      val result = readFromLocalLog(</span><br><span class="line">        replicaId = replicaId,</span><br><span class="line">        fetchOnlyFromLeader = fetchOnlyFromLeader,</span><br><span class="line">        readOnlyCommitted = fetchOnlyCommitted,</span><br><span class="line">        fetchMaxBytes = fetchMaxBytes,</span><br><span class="line">        <span class="comment">// vision&lt;=2，目前=8，说明为false，v2版本有最大字节限制吗？</span></span><br><span class="line">        hardMaxBytesLimit = hardMaxBytesLimit,</span><br><span class="line">        <span class="comment">// fetchInfos是读取的关键，这是fetch参数，注意要读取多个分区，这是个</span></span><br><span class="line">        readPartitionInfo = fetchInfos,</span><br><span class="line">        <span class="comment">// 配额</span></span><br><span class="line">        quota = quota,</span><br><span class="line">        <span class="comment">// 事务隔离级别，默认read_uncommited</span></span><br><span class="line">        isolationLevel = isolationLevel)</span><br><span class="line">      <span class="comment">// 这里是follower的fetch结果处理</span></span><br><span class="line">      <span class="keyword">if</span> (isFromFollower) updateFollowerLogReadResults(replicaId, result)</span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用并返回一个(TopicPartition, LogReadResult)集合</span></span><br><span class="line">    val logReadResults = readFromLog()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if this fetch request can be satisfied right away</span></span><br><span class="line">    <span class="comment">// LogReadResult集合</span></span><br><span class="line">    val logReadResultValues = logReadResults.map &#123; <span class="keyword">case</span> (_, v) =&gt; v &#125;</span><br><span class="line">    <span class="comment">// 读取的消息大小之和</span></span><br><span class="line">    val bytesReadable = logReadResultValues.map(_.info.records.sizeInBytes).sum</span><br><span class="line">    <span class="comment">// 结果中是否有错误</span></span><br><span class="line">    val errorReadingData = logReadResultValues.foldLeft(<span class="keyword">false</span>) ((errorIncurred, readResult) =&gt;</span><br><span class="line">      errorIncurred || (readResult.error != Errors.NONE))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 能够立即返回给客户端的4种情况</span></span><br><span class="line"><span class="comment">      * 1. fetch请求没有大于0的wait时间,参考fetch.max.wait.ms设置</span></span><br><span class="line"><span class="comment">      * 2. fetch请求要拉取的分区为空</span></span><br><span class="line"><span class="comment">      * 3. 根据fetch.min.bytes的设置，有足够的数据返回</span></span><br><span class="line"><span class="comment">      * 4. 出现异常</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span> || fetchInfos.isEmpty || bytesReadable &gt;= fetchMinBytes || errorReadingData) &#123;</span><br><span class="line">      <span class="comment">// fetchPartitionData是一个TopicPartition -&gt; FetchPartitionData 的map集合</span></span><br><span class="line">      val fetchPartitionData = logReadResults.map &#123; <span class="keyword">case</span> (tp, result) =&gt;</span><br><span class="line">        tp -&gt; FetchPartitionData(result.error, result.highWatermark, result.leaderLogStartOffset, result.info.records,</span><br><span class="line">          result.lastStableOffset, result.info.abortedTransactions)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用响应回调函数</span></span><br><span class="line">      responseCallback(fetchPartitionData)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 创建响应的DelayOption，放入purgatory中，等待完成</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// construct the fetch results from the read results</span></span><br><span class="line">      val fetchPartitionStatus = logReadResults.map &#123; <span class="keyword">case</span> (topicPartition, result) =&gt;</span><br><span class="line">        <span class="comment">// collectFirst：根据function find first element</span></span><br><span class="line">        <span class="comment">// fetchInfos是请求参数(TopicPartition, PartitionData)集合，</span></span><br><span class="line">        <span class="comment">// 意思就是从读取结果logReadResults里的TopicPartition和fetchInfos里的TopicPartition匹配</span></span><br><span class="line">        <span class="comment">// 找出该TopicPartition的PartitionData请求参数</span></span><br><span class="line">        val fetchInfo = fetchInfos.collectFirst &#123;</span><br><span class="line">          <span class="keyword">case</span> (tp, v) <span class="keyword">if</span> tp == topicPartition =&gt; v</span><br><span class="line">        &#125;.getOrElse(sys.error(s<span class="string">"Partition $topicPartition not found in fetchInfos"</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值给外层的fetchPartitionStatus</span></span><br><span class="line">        (topicPartition, FetchPartitionStatus(result.info.fetchOffsetMetadata, fetchInfo))</span><br><span class="line">      &#125;</span><br><span class="line">      val fetchMetadata = FetchMetadata(fetchMinBytes, fetchMaxBytes, hardMaxBytesLimit, fetchOnlyFromLeader,</span><br><span class="line">        fetchOnlyCommitted, isFromFollower, replicaId, fetchPartitionStatus)</span><br><span class="line">      val delayedFetch = <span class="keyword">new</span> DelayedFetch(timeout, fetchMetadata, <span class="keyword">this</span>, quota, isolationLevel, responseCallback)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create a list of (topic, partition) pairs to use as keys for this delayed fetch operation</span></span><br><span class="line">      <span class="comment">// 以分区为delay的watchKey</span></span><br><span class="line">      val delayedFetchKeys = fetchPartitionStatus.map &#123; <span class="keyword">case</span> (tp, _) =&gt; <span class="keyword">new</span> TopicPartitionOperationKey(tp) &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// try to complete the request immediately, otherwise put it into the purgatory;</span></span><br><span class="line">      <span class="comment">// this is because while the delayed fetch operation is being created, new requests</span></span><br><span class="line">      <span class="comment">// may arrive and hence make this operation completable.</span></span><br><span class="line">      <span class="comment">// 先尝试一次，不行就放入Purgatory中</span></span><br><span class="line">      delayedFetchPurgatory.tryCompleteElseWatch(delayedFetch, delayedFetchKeys)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法还是有一定的复杂度，需要点耐心，但是思路也很清晰，以下这行代码读取消息，之后对结果进行处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val logReadResults = readFromLog()</span><br></pre></td></tr></table></figure></p><p>由于Consumer有一系列的参数控制，如fetch.max.wait.ms，fetch.min.bytes等，让本次fetch不能立即完成<br>需要新建一个DelayedOption对象，放入Purgatory中，等待后续操作触发本次请求的完成(complete)</p><p>接下来就从readFromLocalLog方法看看如何读取消息</p><h2 id="readFromLocalLog方法"><a href="#readFromLocalLog方法" class="headerlink" title="readFromLocalLog方法"></a>readFromLocalLog方法</h2><p>首先明确性该方法的入参和返回值，入参前文有详细注释，返回值则是一个(TopicPartition, LogReadResult)集合，前文也已提到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read from multiple topic partitions at the given offset up to maxSize bytes</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function">def <span class="title">readFromLocalLog</span><span class="params">(replicaId: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                       fetchOnlyFromLeader: Boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">                       readOnlyCommitted: Boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">                       fetchMaxBytes: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                       hardMaxBytesLimit: Boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">                       readPartitionInfo: Seq[(TopicPartition, PartitionData)</span>],</span></span><br><span class="line"><span class="function">                       quota: ReplicaQuota,</span></span><br><span class="line"><span class="function">                       isolationLevel: IsolationLevel): Seq[<span class="params">(TopicPartition, LogReadResult)</span>] </span>= &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 又是先定义后调用，从后面的代码块这是在遍历请求参数中的TopicPartition集合</span></span><br><span class="line"><span class="comment">      * 作用是读取一个分区里的消息</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> tp 要读取的分区</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> fetchInfo 读取的参数，如从哪里开始读，读多少</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> limitBytes fetchMaxBytes参数</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> minOneMessage 是否至少读第一条后立即返回，即使它比fetchMaxBytes大，true</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 读取的结果</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="function">def <span class="title">read</span><span class="params">(tp: TopicPartition, fetchInfo: PartitionData, limitBytes: Int, minOneMessage: Boolean)</span>: LogReadResult </span>= &#123;</span><br><span class="line">val offset = fetchInfo.fetchOffset <span class="comment">//从哪fetch</span></span><br><span class="line">val partitionFetchSize = fetchInfo.maxBytes <span class="comment">// fetch多少</span></span><br><span class="line">val followerLogStartOffset = fetchInfo.logStartOffset <span class="comment">// 这应该是针对follower的，consumer始终为-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// decide whether to only fetch from leader</span></span><br><span class="line">val localReplica = <span class="keyword">if</span> (fetchOnlyFromLeader)</span><br><span class="line">  <span class="comment">//先找leader副本</span></span><br><span class="line">  getLeaderReplicaIfLocal(tp)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  getReplicaOrException(tp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hw</span></span><br><span class="line">val initialHighWatermark = localReplica.highWatermark.messageOffset</span><br><span class="line"><span class="comment">// 事务相关</span></span><br><span class="line">val lastStableOffset = <span class="keyword">if</span> (isolationLevel == IsolationLevel.READ_COMMITTED)</span><br><span class="line">  Some(localReplica.lastStableOffset.messageOffset)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  None</span><br><span class="line"></span><br><span class="line"><span class="comment">// decide whether to only fetch committed data (i.e. messages below high watermark)</span></span><br><span class="line">val maxOffsetOpt = <span class="keyword">if</span> (readOnlyCommitted)</span><br><span class="line">  <span class="comment">// 没开启事务时lastStableOffset应该为None</span></span><br><span class="line">  <span class="comment">// 这里返回的还是initialHighWatermark</span></span><br><span class="line">  Some(lastStableOffset.getOrElse(initialHighWatermark))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  None</span><br><span class="line">val initialLogEndOffset = localReplica.logEndOffset.messageOffset <span class="comment">// LEO</span></span><br><span class="line"><span class="comment">// 这应该是副本目前所有Segment的初始位移(第一个Segment的baseOffset),会随着日志清理改变</span></span><br><span class="line">val initialLogStartOffset = localReplica.logStartOffset</span><br><span class="line">val fetchTimeMs = time.milliseconds <span class="comment">// 当前时间</span></span><br><span class="line">val logReadInfo = localReplica.log match &#123;</span><br><span class="line">  <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(log)</span> </span>=&gt;</span><br><span class="line">    <span class="comment">// TODO 目前还没搞清楚PartitionData里的maxBytes和FetchRequest的maxBytes什么区别</span></span><br><span class="line">    <span class="comment">// limitBytes是请求参数中的maxBytes</span></span><br><span class="line">    val adjustedFetchSize = math.min(partitionFetchSize, limitBytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the read first, this tells us whether we need all of adjustedFetchSize for this partition</span></span><br><span class="line">   <span class="comment">// 从Log对象中读取</span></span><br><span class="line">    val fetch = log.read(offset, adjustedFetchSize, maxOffsetOpt, minOneMessage, isolationLevel)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the partition is being throttled, simply return an empty set.</span></span><br><span class="line">    <span class="comment">// 超出配额(被限流)时返回一个空消息</span></span><br><span class="line">    <span class="keyword">if</span> (shouldLeaderThrottle(quota, tp, replicaId))</span><br><span class="line">      FetchDataInfo(fetch.fetchOffsetMetadata, MemoryRecords.EMPTY)</span><br><span class="line">    <span class="comment">// For FetchRequest version 3, we replace incomplete message sets with an empty one as consumers can make</span></span><br><span class="line">    <span class="comment">// progress in such cases and don't need to report a `RecordTooLargeException`</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!hardMaxBytesLimit &amp;&amp; fetch.firstEntryIncomplete)</span><br><span class="line">      FetchDataInfo(fetch.fetchOffsetMetadata, MemoryRecords.EMPTY)</span><br><span class="line">    <span class="keyword">else</span> fetch <span class="comment">// 返回正常的结果给logReadInfo变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> None =&gt;</span><br><span class="line">    error(s<span class="string">"Leader for partition $tp does not have a local log"</span>)</span><br><span class="line">    FetchDataInfo(LogOffsetMetadata.UnknownOffsetMetadata, MemoryRecords.EMPTY)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line">LogReadResult(info = logReadInfo,</span><br><span class="line">              highWatermark = initialHighWatermark,</span><br><span class="line">              leaderLogStartOffset = initialLogStartOffset,</span><br><span class="line">              leaderLogEndOffset = initialLogEndOffset,</span><br><span class="line">              followerLogStartOffset = followerLogStartOffset,</span><br><span class="line">              fetchTimeMs = fetchTimeMs,</span><br><span class="line">              readSize = partitionFetchSize,</span><br><span class="line">              lastStableOffset = lastStableOffset,</span><br><span class="line">              exception = None)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var limitBytes = fetchMaxBytes</span><br><span class="line">val result = <span class="keyword">new</span> mutable.ArrayBuffer[(TopicPartition, LogReadResult)]</span><br><span class="line">var minOneMessage = !hardMaxBytesLimit <span class="comment">// true</span></span><br><span class="line">readPartitionInfo.foreach &#123; <span class="keyword">case</span> (tp, fetchInfo) =&gt; <span class="comment">// 遍历每个tp，按照消费者的参数读取日志</span></span><br><span class="line">  val readResult = read(tp, fetchInfo, limitBytes, minOneMessage)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到读取结果后，更新limitBytes，添加到result集合中</span></span><br><span class="line">  val recordBatchSize = readResult.info.records.sizeInBytes</span><br><span class="line">  <span class="comment">// Once we read from a non-empty partition, we stop ignoring request and partition level size limits</span></span><br><span class="line">  <span class="keyword">if</span> (recordBatchSize &gt; <span class="number">0</span>)</span><br><span class="line">    minOneMessage = <span class="keyword">false</span></span><br><span class="line">  <span class="comment">// fetchMaxBytes 减去 已读取的消息大小</span></span><br><span class="line">  limitBytes = math.max(<span class="number">0</span>, limitBytes - recordBatchSize)</span><br><span class="line">  result += (tp -&gt; readResult)</span><br><span class="line">&#125;</span><br><span class="line">result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readFromLocalLog主要是遍历请求中的分区，调用事先定义好的嵌套方法read，read方法会先找到leader副本，并且准备好读取的各种参数，最终调用Log对象的read方法</p><p>而外层的readFromLocalLog在拿到结果之后，会在循环中从fetchMaxBytes里减去已读取的消息大小</p><h2 id="Log-read"><a href="#Log-read" class="headerlink" title="Log#read"></a>Log#read</h2><p>我们知道Log只是个逻辑上的概念，本质是一个个Segment文件，每个Segment文件都有自己的起始位移(baseOffset)，<br>fetch请求要从fetchOffset处开始读取消息，我们常规的做法是先找到要读取的Segment文件，kafka为了加快寻找速度，增加了索引文件的概念，找到后根据fetchMaxBytes参数(当前在循环中，会一直变化)， 在高水位线的限制下调用Segment对象read方法读取消息，返回FetchDataInfo结果对象</p><p>以上就是该方法要做的事，Log对象的read方法源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read messages from the log.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> startOffset 从哪里fetch，fetch请求中的fetchOffset参数:</span></span><br><span class="line"><span class="comment">    *                    The offset to begin reading at</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxLength fetch的maxBytes-已读取的消息大小:</span></span><br><span class="line"><span class="comment">    *                  The maximum number of bytes to read</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxOffset fetch的上限，即高水位线:</span></span><br><span class="line"><span class="comment">    *                  The offset to read up to, exclusive. (i.e. this offset NOT included in the resulting message set)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> minOneMessage 是否至少fetch一条，即使的大小它已经超出了maxBytes:</span></span><br><span class="line"><span class="comment">    *                      If this is true, the first message will be returned even if it exceeds `maxLength` (if one exists)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">def <span class="title">read</span><span class="params">(startOffset: Long, maxLength: Int, maxOffset: Option[Long] = None, minOneMessage: Boolean = <span class="keyword">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">           isolationLevel: IsolationLevel)</span>: FetchDataInfo </span>= &#123;</span><br><span class="line">    maybeHandleIOException(s<span class="string">"Exception while reading from $topicPartition in dir $&#123;dir.getParent&#125;"</span>) &#123;</span><br><span class="line">      trace(s<span class="string">"Reading $maxLength bytes from offset $startOffset of length $size bytes"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Because we don't use lock for reading, the synchronization is a little bit tricky.</span></span><br><span class="line">      <span class="comment">// We create the local variables to avoid race conditions with updates to the log.</span></span><br><span class="line">      <span class="comment">// 使用局部变量来避免并发锁竞争，nextOffsetMetadata.messageOffset就是LEO</span></span><br><span class="line">      val currentNextOffsetMetadata = nextOffsetMetadata</span><br><span class="line">      val next = currentNextOffsetMetadata.messageOffset</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 事务部分，先不关心</span></span><br><span class="line">      <span class="keyword">if</span> (startOffset == next) &#123;</span><br><span class="line">        val abortedTransactions =</span><br><span class="line">          <span class="keyword">if</span> (isolationLevel == IsolationLevel.READ_COMMITTED) Some(List.empty[AbortedTransaction])</span><br><span class="line">          <span class="keyword">else</span> None</span><br><span class="line">        <span class="keyword">return</span> FetchDataInfo(currentNextOffsetMetadata, MemoryRecords.EMPTY, firstEntryIncomplete = <span class="keyword">false</span>,</span><br><span class="line">          abortedTransactions = abortedTransactions)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// segments是一个跳表做的map，key为Segment的baseOffset，value是LogSegment对象</span></span><br><span class="line">      <span class="comment">// floorEntry是干嘛的？看哪个LogSegment的baseOffset &lt;= startOffset，其实就是在找要读取的LogSegment</span></span><br><span class="line">      <span class="comment">// segmentEntry是一个entry: &lt;baseOffset,LogSegment&gt;</span></span><br><span class="line">      var segmentEntry = segments.floorEntry(startOffset)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// return error on attempt to read beyond the log end offset or read below log start offset</span></span><br><span class="line">      <span class="comment">// 异常处理，大于LEO肯定不对，没找到合适的LogSegment也是不对的，至于startOffset &lt; logStartOffset感觉很多余</span></span><br><span class="line">      <span class="keyword">if</span> (startOffset &gt; next || segmentEntry == <span class="keyword">null</span> || startOffset &lt; logStartOffset)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OffsetOutOfRangeException(s<span class="string">"Received request for offset $startOffset for partition $topicPartition, "</span> +</span><br><span class="line">          s<span class="string">"but we only have log segments in the range $logStartOffset to $next."</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 从baseOffset小于指定offset的Segment里读取消息，但如果Segment里没有消息，</span></span><br><span class="line"><span class="comment">        * 就继续往后面的Segment读,直到读取到了消息，或者到达了log的末尾</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="comment">// Do the read on the segment with a base offset less than the target offset</span></span><br><span class="line">      <span class="comment">// but if that segment doesn't contain any messages with an offset greater than that</span></span><br><span class="line">      <span class="comment">// continue to read from successive segments until we get some messages or we reach the end of the log</span></span><br><span class="line">      <span class="keyword">while</span> (segmentEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出LogSegment</span></span><br><span class="line">        val segment = segmentEntry.getValue</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果fetch读取了active Segment(最后一个正在写入的LogSegment)，在LEO更新前，发生了两次fetch会产生并发竞争，</span></span><br><span class="line">        <span class="comment">// 那么第二次fetch可能会发生OffsetOutOfRangeException，因此我们限制读取已暴露的位置(下面的maxPosition变量)，而不是active Segment的LEO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the fetch occurs on the active segment, there might be a race condition where two fetch requests occur after</span></span><br><span class="line">        <span class="comment">// the message is appended but before the nextOffsetMetadata is updated. In that case the second fetch may</span></span><br><span class="line">        <span class="comment">// cause OffsetOutOfRangeException. To solve that, we cap the reading up to exposed position instead of the log</span></span><br><span class="line">        <span class="comment">// end of the active segment.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * maxPosition大概是说segmentEntry如果是最后一个(active Segment)就返回LEO，</span></span><br><span class="line"><span class="comment">          * 否则返回当前Segment的大小</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        val maxPosition = &#123;</span><br><span class="line">          <span class="keyword">if</span> (segmentEntry == segments.lastEntry) &#123;</span><br><span class="line">            val exposedPos = nextOffsetMetadata.relativePositionInSegment.toLong</span><br><span class="line">            <span class="comment">// 这个check again真的有用吗，为了解决bug？有点low</span></span><br><span class="line">            <span class="comment">// Check the segment again in case a new segment has just rolled out.</span></span><br><span class="line">            <span class="keyword">if</span> (segmentEntry != segments.lastEntry)</span><br><span class="line">            <span class="comment">// New log segment has rolled out, we can read up to the file end.</span></span><br><span class="line">              segment.size</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              exposedPos</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            segment.size</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 总结一下这几个入参</span></span><br><span class="line"><span class="comment">          * startOffset：从哪个位置开始读</span></span><br><span class="line"><span class="comment">          * maxOffset：读取的上限，高水位线</span></span><br><span class="line"><span class="comment">          * maxLength：读取的maxBytes</span></span><br><span class="line"><span class="comment">          * maxPosition：目前不知道什么用，LEO或者Segment的size</span></span><br><span class="line"><span class="comment">          * minOneMessage：是否至少读第一条</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        val fetchInfo = segment.read(startOffset, maxOffset, maxLength, maxPosition, minOneMessage)</span><br><span class="line">        <span class="keyword">if</span> (fetchInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">          segmentEntry = segments.higherEntry(segmentEntry.getKey)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> isolationLevel match &#123;</span><br><span class="line">            <span class="comment">// 默认是READ_UNCOMMITTED，这里的fetchInfo作为返回值</span></span><br><span class="line">            <span class="keyword">case</span> IsolationLevel.READ_UNCOMMITTED =&gt; fetchInfo</span><br><span class="line">            <span class="keyword">case</span> IsolationLevel.READ_COMMITTED =&gt; addAbortedTransactions(startOffset, segmentEntry, fetchInfo)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 上面的while执行到最后一个Segment都还没return，说明我们要读取的消息都被删除了，这种情况返回空消息</span></span><br><span class="line">      <span class="comment">// okay we are beyond the end of the last segment with no data fetched although the start offset is in range,</span></span><br><span class="line">      <span class="comment">// this can happen when all messages with offset larger than start offsets have been deleted.</span></span><br><span class="line">      <span class="comment">// In this case, we will return the empty set with log end offset metadata</span></span><br><span class="line">      FetchDataInfo(nextOffsetMetadata, MemoryRecords.EMPTY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LogSegment-read"><a href="#LogSegment-read" class="headerlink" title="LogSegment#read"></a>LogSegment#read</h2><p>LogSegment#read属于接近底层的方法了，上一小节已经根据一个&lt;baseOffset, Segment&gt;的map找到了相应的Segment，但是要知道默认一个Segment大小为1G，想要在这么大的文件中查询数据，必须依赖索引。</p><p>kafka的读取逻辑是先根据二分法找到相应的offset和position，最终通过FileRecords.slice读取区间内的消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> startOffset 从哪个位置开始读：</span></span><br><span class="line"><span class="comment">    *                    A lower bound on the first offset to include in the message set we read</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxOffset 读取的上限，高水位线：</span></span><br><span class="line"><span class="comment">    *                  An optional maximum offset for the message set we read</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxSize fetch的maxBytes-已读取的消息大小：</span></span><br><span class="line"><span class="comment">    *                The maximum number of bytes to include in the message set we read</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxPosition 目前不知道什么用，LEO或者Segment的size：</span></span><br><span class="line"><span class="comment">    *                    The maximum position in the log segment that should be exposed for read</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> minOneMessage 是否至少读第一条：</span></span><br><span class="line"><span class="comment">    *                      If this is true, the first message will be returned even if it exceeds `maxSize` (if one exists)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The fetched data and the offset metadata of the first message whose offset is &gt;= startOffset,</span></span><br><span class="line"><span class="comment">   *         or null if the startOffset is larger than the largest offset in this log</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@threadsafe</span></span><br><span class="line">  <span class="function">def <span class="title">read</span><span class="params">(startOffset: Long, maxOffset: Option[Long], maxSize: Int, maxPosition: Long = size,</span></span></span><br><span class="line"><span class="function"><span class="params">           minOneMessage: Boolean = <span class="keyword">false</span>)</span>: FetchDataInfo </span>= &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 日志文件字节数大小</span></span><br><span class="line">    val logSize = log.sizeInBytes <span class="comment">// this may change, need to save a consistent copy</span></span><br><span class="line">    <span class="comment">// 从index文件里查找offset,position</span></span><br><span class="line">    val startOffsetAndSize = translateOffset(startOffset)</span><br><span class="line"></span><br><span class="line">    val startPosition = startOffsetAndSize.position</span><br><span class="line">    val offsetMetadata = <span class="keyword">new</span> LogOffsetMetadata(startOffset, <span class="keyword">this</span>.baseOffset, startPosition)</span><br><span class="line"></span><br><span class="line">    val adjustedMaxSize =</span><br><span class="line">      <span class="keyword">if</span> (minOneMessage) math.max(maxSize, startOffsetAndSize.size)</span><br><span class="line">      <span class="keyword">else</span> maxSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the length of the message set to read based on whether or not they gave us a maxOffset</span></span><br><span class="line">    val fetchSize: Int = maxOffset match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(offset)</span> </span>=&gt;</span><br><span class="line">        val mapping = translateOffset(offset, startPosition)</span><br><span class="line">        val endPosition =</span><br><span class="line">          <span class="keyword">if</span> (mapping == <span class="keyword">null</span>)</span><br><span class="line">            logSize <span class="comment">// the max offset is off the end of the log, use the end of the file</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            mapping.position</span><br><span class="line">        min(min(maxPosition, endPosition) - startPosition, adjustedMaxSize).toInt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log.slice方法是在真正的获取消息</span></span><br><span class="line">    FetchDataInfo(offsetMetadata, log.slice(startPosition, fetchSize),</span><br><span class="line">      firstEntryIncomplete = adjustedMaxSize &lt; startOffsetAndSize.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="返回结果处理"><a href="#返回结果处理" class="headerlink" title="返回结果处理"></a>返回结果处理</h2><p>经过层层返回，回到最初的的handleFetchRequest方法中，看看processResponseCallback方法中是如何对读取结果进行处理并返回给consumer的</p><p>省略配额限流相关代码…</p><p>该方法的入参是一个(TopicPartition, FetchPartitionData)，表示每个分区对应的读取结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the callback for process a fetch response, invoked before throttling</span></span><br><span class="line"><span class="function">def <span class="title">processResponseCallback</span><span class="params">(responsePartitionData: Seq[(TopicPartition, FetchPartitionData)</span>]): Unit </span>= &#123;</span><br><span class="line">  <span class="comment">// FetchPartitionData转PartitionData</span></span><br><span class="line">  val partitions = <span class="keyword">new</span> util.LinkedHashMap[TopicPartition, FetchResponse.PartitionData[Records]]</span><br><span class="line">  responsePartitionData.foreach &#123; <span class="keyword">case</span> (tp, data) =&gt;</span><br><span class="line">    val abortedTransactions = data.abortedTransactions.map(_.asJava).orNull</span><br><span class="line">    val lastStableOffset = data.lastStableOffset.getOrElse(FetchResponse.INVALID_LAST_STABLE_OFFSET)</span><br><span class="line">    partitions.put(tp, <span class="keyword">new</span> FetchResponse.PartitionData(data.error, data.highWatermark, lastStableOffset,</span><br><span class="line">      data.logStartOffset, abortedTransactions, data.records))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误的分区也要返回各自的错误信息</span></span><br><span class="line">  erroneous.foreach &#123; <span class="keyword">case</span> (tp, data) =&gt; partitions.put(tp, data) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When this callback is triggered, the remote API call has completed.</span></span><br><span class="line">  <span class="comment">// Record time before any byte-rate throttling.</span></span><br><span class="line">  request.apiRemoteCompleteTimeNanos = time.nanoseconds</span><br><span class="line"></span><br><span class="line">  var unconvertedFetchResponse: FetchResponse[Records] = <span class="keyword">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// follower同步的fetch</span></span><br><span class="line">  <span class="keyword">if</span> (fetchRequest.isFromFollower) &#123;</span><br><span class="line">    <span class="comment">// We've already evaluated against the quota and are good to go. Just need to record it now.</span></span><br><span class="line">    unconvertedFetchResponse = fetchContext.updateAndGenerateResponseData(partitions)</span><br><span class="line">    val responseSize = sizeOfThrottledPartitions(versionId, unconvertedFetchResponse, quotas.leader)</span><br><span class="line">    quotas.leader.record(responseSize)</span><br><span class="line">    trace(s<span class="string">"Sending Fetch response with partitions.size=$&#123;unconvertedFetchResponse.responseData().size()&#125;, "</span> +</span><br><span class="line">      s<span class="string">"metadata=$&#123;unconvertedFetchResponse.sessionId()&#125;"</span>)</span><br><span class="line">    sendResponseExemptThrottle(request, createResponse(<span class="number">0</span>), Some(updateConversionStats))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fetch size used to determine throttle time is calculated before any down conversions.</span></span><br><span class="line">    <span class="comment">// This may be slightly different from the actual response size. But since down conversions</span></span><br><span class="line">    <span class="comment">// result in data being loaded into memory, we should do this only when we are not going to throttle.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Record both bandwidth and request quota-specific values and throttle by muting the channel if any of the</span></span><br><span class="line">    <span class="comment">// quotas have been violated. If both quotas have been violated, use the max throttle time between the two</span></span><br><span class="line">    <span class="comment">// quotas. When throttled, we unrecord the recorded bandwidth quota value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大部分都是限流先关代码，先忽略</span></span><br><span class="line">    val responseSize = fetchContext.getResponseSize(partitions, versionId)</span><br><span class="line">    val timeMs = time.milliseconds()</span><br><span class="line">    val requestThrottleTimeMs = quotas.request.maybeRecordAndGetThrottleTimeMs(request)</span><br><span class="line">    val bandwidthThrottleTimeMs = quotas.fetch.maybeRecordAndGetThrottleTimeMs(request, responseSize, timeMs)</span><br><span class="line"></span><br><span class="line">    val maxThrottleTimeMs = math.max(bandwidthThrottleTimeMs, requestThrottleTimeMs)</span><br><span class="line">    <span class="keyword">if</span> (maxThrottleTimeMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Even if we need to throttle for request quota violation, we should "unrecord" the already recorded value</span></span><br><span class="line">      <span class="comment">// from the fetch quota because we are going to return an empty response.</span></span><br><span class="line">      quotas.fetch.unrecordQuotaSensor(request, responseSize, timeMs)</span><br><span class="line">      <span class="keyword">if</span> (bandwidthThrottleTimeMs &gt; requestThrottleTimeMs) &#123;</span><br><span class="line">        quotas.fetch.throttle(request, bandwidthThrottleTimeMs, sendResponse)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quotas.request.throttle(request, requestThrottleTimeMs, sendResponse)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If throttling is required, return an empty response.</span></span><br><span class="line">      unconvertedFetchResponse = fetchContext.getThrottledResponse(maxThrottleTimeMs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Get the actual response. This will update the fetch context.</span></span><br><span class="line">      <span class="comment">// 这是很关键的一行代码，创建了Response对象，全量和增量的方式有所不同，后续的FetchSession再说</span></span><br><span class="line">      unconvertedFetchResponse = fetchContext.updateAndGenerateResponseData(partitions)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the response immediately.</span></span><br><span class="line">    <span class="comment">// 发送响应到Processor的responseQueue中</span></span><br><span class="line">    sendResponse(request, Some(createResponse(maxThrottleTimeMs)), Some(updateConversionStats))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 很简单的一个方法，里面用maybeConvertFetchedData方法处理版本兼容引起的消息降级转换</span></span><br><span class="line"><span class="comment">    * 然后统计了下bytes out的metric，最终返回FetchResponse</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function">def <span class="title">createResponse</span><span class="params">(throttleTimeMs: Int)</span>: FetchResponse[BaseRecords] </span>= &#123;</span><br><span class="line">    <span class="comment">// Down-convert messages for each partition if required</span></span><br><span class="line">    val convertedData = <span class="keyword">new</span> util.LinkedHashMap[TopicPartition, FetchResponse.PartitionData[BaseRecords]]</span><br><span class="line">    unconvertedFetchResponse.responseData().asScala.foreach &#123; <span class="keyword">case</span> (tp, unconvertedPartitionData) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (unconvertedPartitionData.error != Errors.NONE)</span><br><span class="line">        debug(s<span class="string">"Fetch request with correlation id $&#123;request.header.correlationId&#125; from client $clientId "</span> +</span><br><span class="line">          s<span class="string">"on partition $tp failed due to $&#123;unconvertedPartitionData.error.exceptionName&#125;"</span>)</span><br><span class="line">      convertedData.put(tp, maybeConvertFetchedData(tp, unconvertedPartitionData))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare fetch response from converted data</span></span><br><span class="line">    val response = <span class="keyword">new</span> FetchResponse(unconvertedFetchResponse.error(), convertedData, throttleTimeMs,</span><br><span class="line">      unconvertedFetchResponse.sessionId())</span><br><span class="line">    response.responseData.asScala.foreach &#123; <span class="keyword">case</span> (topicPartition, data) =&gt;</span><br><span class="line">      <span class="comment">// record the bytes out metrics only when the response is being sent</span></span><br><span class="line">      brokerTopicStats.updateBytesOut(topicPartition.topic, fetchRequest.isFromFollower, data.records.sizeInBytes)</span><br><span class="line">    &#125;</span><br><span class="line">    info(s<span class="string">"fetch response is $&#123;response&#125;"</span>)</span><br><span class="line">    response</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">def <span class="title">updateConversionStats</span><span class="params">(send: Send)</span>: Unit </span>= &#123;</span><br><span class="line">    send match &#123;</span><br><span class="line">      <span class="keyword">case</span> send: MultiRecordsSend <span class="keyword">if</span> send.recordConversionStats != <span class="keyword">null</span> =&gt;</span><br><span class="line">        send.recordConversionStats.asScala.toMap.foreach &#123;</span><br><span class="line">          <span class="keyword">case</span> (tp, stats) =&gt; updateRecordConversionStats(request, tp, stats)</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>fetch请求处理流程调用的对象基本和produce请求类似，需要注意的几点是：</p><ol><li>fetch请求分为consumer和follower，server端用一个replicaId字段判断，consumer为-1</li><li>consumer读取有高水位线的限制，follower则没有</li><li>consumer受限于各种参数，不会立即响应，需要放入purgatory延迟队列中等待完成</li><li>响应回调中遇到了限流，FetchSession，消息降级等过程</li></ol><p><img src="https://ae01.alicdn.com/kf/Hfe405813f8c148df945920680455868dt.png" alt="consumer fetch流程"></p><p>部分图片引用：<br><a href="https://www.cnblogs.com/huxi2b/p/9335064.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxi2b/p/9335064.html</a><br><a href="https://www.cnblogs.com/huxi2b/p/7453543.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxi2b/p/7453543.html</a></p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka-server端源码分析之LIST_OFFSETS请求</title>
      <link href="/2019/12/15/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BLIST-OFFSETS%E8%AF%B7%E6%B1%82/"/>
      <url>/2019/12/15/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BLIST-OFFSETS%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文聊聊kafka server中的LIST_OFFSETS请求，这个请求的功能一言以蔽之:根据请求参数中的timeStamp获取消费者(或副本)能够fetch的位移</p><p>主要应用场景为消费者第一次拉取消息时，不知道从哪个offset拉取，这个拉取策略可以消费者通过auto.offset.reset指定，请求时翻译成timeStamp(ListOffsetRequest类常量)，<br>server端处理时从日志(LogSegment)中查找应该被fetch的offset(TimestampOffset)</p><p>在消费者之后的拉取中，记录了上次拉取的位置(TopicPartitionState@position)，不用再重新获取</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>之前的文章中说过，server端通过KafkaApis#handle方法处理所有网络请求，LIST_OFFSETS请求如下</p><h2 id="handleListOffsetRequest"><a href="#handleListOffsetRequest" class="headerlink" title="handleListOffsetRequest"></a>handleListOffsetRequest</h2><p>忽略别的代码，仅关注handleListOffsetRequestV1AndAbove方法, 它返回了每个TP对应的fetch offset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">handleListOffsetRequestV1AndAbove</span><span class="params">(request : RequestChannel.Request)</span>: Map[TopicPartition, ListOffsetResponse.PartitionData] </span>= &#123;</span><br><span class="line">    val correlationId = request.header.correlationId</span><br><span class="line">    val clientId = request.header.clientId</span><br><span class="line">    val offsetRequest = request.body[ListOffsetRequest]</span><br><span class="line"></span><br><span class="line">    val (authorizedRequestInfo, unauthorizedRequestInfo) = offsetRequest.partitionTimestamps.asScala.partition &#123;</span><br><span class="line">      <span class="keyword">case</span> (topicPartition, _) =&gt; authorize(request.session, Describe, Resource(Topic, topicPartition.topic, LITERAL))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val unauthorizedResponseStatus = unauthorizedRequestInfo.mapValues(_ =&gt; &#123;</span><br><span class="line">      <span class="keyword">new</span> ListOffsetResponse.PartitionData(Errors.TOPIC_AUTHORIZATION_FAILED,</span><br><span class="line">                                           ListOffsetResponse.UNKNOWN_TIMESTAMP,</span><br><span class="line">                                           ListOffsetResponse.UNKNOWN_OFFSET)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    val responseMap = authorizedRequestInfo.map &#123; <span class="keyword">case</span> (topicPartition, timestamp) =&gt;</span><br><span class="line"><span class="comment">// 获取leader</span></span><br><span class="line">val localReplica = replicaManager.getLeaderReplicaIfLocal(topicPartition)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1表示consumer</span></span><br><span class="line">val fromConsumer = offsetRequest.replicaId == ListOffsetRequest.CONSUMER_REPLICA_ID</span><br><span class="line"></span><br><span class="line">val found = <span class="keyword">if</span> (fromConsumer) &#123;</span><br><span class="line"><span class="comment">// 根据事务隔离级别，获取可拉取的位移</span></span><br><span class="line">val lastFetchableOffset = offsetRequest.isolationLevel match &#123;</span><br><span class="line">  <span class="keyword">case</span> IsolationLevel.READ_COMMITTED =&gt; localReplica.lastStableOffset.messageOffset</span><br><span class="line">    <span class="comment">// 默认没使用事务，返回的是highWatermark</span></span><br><span class="line">  <span class="keyword">case</span> IsolationLevel.READ_UNCOMMITTED =&gt; localReplica.highWatermark.messageOffset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的if...else...就是if (fromConsumer)的返回值</span></span><br><span class="line"><span class="comment">// reset到最新的</span></span><br><span class="line"><span class="keyword">if</span> (timestamp == ListOffsetRequest.LATEST_TIMESTAMP)</span><br><span class="line">  <span class="comment">// TimestampOffset，case class： -1 和 highWatermark</span></span><br><span class="line">  TimestampOffset(RecordBatch.NO_TIMESTAMP, lastFetchableOffset)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 过滤函数：从log里查找出来的offset一定要比lastFetchableOffset小 或者是earliest</span></span><br><span class="line">  <span class="function">def <span class="title">allowed</span><span class="params">(timestampOffset: TimestampOffset)</span>: Boolean </span>=</span><br><span class="line">    timestamp == ListOffsetRequest.EARLIEST_TIMESTAMP || timestampOffset.offset &lt; lastFetchableOffset</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取offset</span></span><br><span class="line">  fetchOffsetForTimestamp(topicPartition, timestamp)</span><br><span class="line">    .filter(allowed).getOrElse(TimestampOffset.Unknown)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 不是consumer的先不看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是map方法的返回，也就是在循环内</span></span><br><span class="line">(topicPartition, <span class="keyword">new</span> ListOffsetResponse.PartitionData(Errors.NONE, found.timestamp, found.offset))</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和未认证的TP并集，返回给客户端</span></span><br><span class="line">    responseMap ++ unauthorizedResponseStatus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Segment中获取"><a href="#Segment中获取" class="headerlink" title="Segment中获取"></a>Segment中获取</h2><p>该方法就是根据客户端的reset policy(TimeStamp)来返回offset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fetchOffsetsByTimestamp</span><span class="params">(targetTimestamp: Long)</span>: Option[TimestampOffset] </span>= &#123;</span><br><span class="line">    maybeHandleIOException(s<span class="string">"Error while fetching offset by timestamp for $topicPartition in dir $&#123;dir.getParent&#125;"</span>) &#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 所有LogSegment的副本，共享变私有，避免锁竞争</span></span><br><span class="line">      val segmentsCopy = logSegments.toBuffer</span><br><span class="line">      <span class="comment">// For the earliest and latest, we do not need to return the timestamp.</span></span><br><span class="line">      <span class="keyword">if</span> (targetTimestamp == ListOffsetRequest.EARLIEST_TIMESTAMP)</span><br><span class="line">        <span class="comment">// earliest返回logStartOffset：当前TP在日志自动清理后，目前最小的offset</span></span><br><span class="line">        <span class="keyword">return</span> Some(TimestampOffset(RecordBatch.NO_TIMESTAMP, logStartOffset))</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetTimestamp == ListOffsetRequest.LATEST_TIMESTAMP)</span><br><span class="line">        <span class="comment">// latest返回LEO 但是为什么返回LEO呢，万一一直没提交呢，返回HW不是更稳妥吗</span></span><br><span class="line">        <span class="keyword">return</span> Some(TimestampOffset(RecordBatch.NO_TIMESTAMP, logEndOffset))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// earliest，latest之外的类型：Timestamp表示具体的时间戳，-1，-2只是表示了2个特殊的offset</span></span><br><span class="line">      val targetSeg = &#123;</span><br><span class="line">        <span class="comment">// Get all the segments whose largest timestamp is smaller than target timestamp</span></span><br><span class="line">        <span class="comment">// 先找segments，找第一个Segment的最大Timestamp大于请求中的Timestamp，可以看下takeWhile源码</span></span><br><span class="line">        val earlierSegs = segmentsCopy.takeWhile(_.largestTimestamp &lt; targetTimestamp) <span class="comment">// takeWhile牛逼啊，一直循环，只要不满足表示式停止</span></span><br><span class="line">        <span class="comment">// We need to search the first segment whose largest timestamp is greater than the target timestamp if there is one.</span></span><br><span class="line">        <span class="comment">// 再找offset</span></span><br><span class="line">        <span class="keyword">if</span> (earlierSegs.length &lt; segmentsCopy.length)</span><br><span class="line">          Some(segmentsCopy(earlierSegs.length))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          None</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      targetSeg.flatMap(_.findOffsetByTimestamp(targetTimestamp, logStartOffset))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka导出消息日志及索引原理分析</title>
      <link href="/2019/12/12/kafka%E5%AF%BC%E5%87%BA%E6%B6%88%E6%81%AF%E6%97%A5%E5%BF%97%E5%8F%8A%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/12/kafka%E5%AF%BC%E5%87%BA%E6%B6%88%E6%81%AF%E6%97%A5%E5%BF%97%E5%8F%8A%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>./kafka-run-class.sh kafka.tools.DumpLogSegments –files /Users/admin/private/kafka/data/test-1-0/00000000000000129009.timeindex –print-data-log</p><p>log.segment.bytes</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka server端源码分析之接收消息</title>
      <link href="/2019/12/10/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF/"/>
      <url>/2019/12/10/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF/</url>
      <content type="html"><![CDATA[<blockquote><p>承接上篇搭建kafka源码环境之后，本文正式开始分析</p></blockquote><h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>在前文<a href="https://greedypirate.github.io/2019/12/06/kafka%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/">kafka网络请求处理模型</a>中提到, KafkaServer#startup方法涵盖了kafka server所有模块的初始化<br>KafkaRequestHandlerPool线程池中的KafkaRequestHandler对象通过调用KafkaApis的handle方法，处理各类网络请求</p><h1 id="图文解析"><a href="#图文解析" class="headerlink" title="图文解析"></a>图文解析</h1><p><img src="https://ae01.alicdn.com/kf/H46b57c5ef8eb44fbb533c5d808b49906v.png" alt="append消息流程"></p><p>上图是kafka server追加消息到日志的整个流程，主要分为以下几步</p><ol><li>handleProduceRequest首先过滤认证失败和leader未知的分区，定义响应回调。如果ack=0直接响应，否则继续ReplicaManager处理</li><li>将生产者的相关参数，如超时时间，ack，以及第1步的响应回调函数传给ReplicaManager#appendRecords，appendRecords继续调用appendToLocalLog，完成后如果ack=-1时，第一次尝试结束请求</li><li>appendToLocalLog则遍历所有分区，获取该分区的本地leader副本Partition对象，调用它的appendRecordsToLeader方法，为每个分区追加消息</li><li>Partition#appendRecordsToLeader方法中，在校验完minIsr参数后，调用Log对象appendAsLeader-&gt;append方法，里面首先计算要追加的位移，消息CRC校验，截断无效消息等</li><li>Log#append方法之后会判断当前activeSegment是否需要roll(新建一个)，然后调用LogSegment#append-&gt;…-&gt;FileChannel#write将消息写入日志中</li><li>层层返回，调用响应回调函数中的sendResponse，和<a href="https://greedypirate.github.io/2019/12/06/kafka%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/">kafka网络请求处理模型</a>一文承上启下，将Response对象放入Processor中的responseQueue，等待Processor轮询处理</li></ol><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>注: TopicPartition, 包含topic和partition的值，简称TP</p><h2 id="生产者请求处理方法"><a href="#生产者请求处理方法" class="headerlink" title="生产者请求处理方法"></a>生产者请求处理方法</h2><p>关于KafkaRequestHandler线程类的相关源码省略，查看其run方法即可</p><p>KafkaApis#handle方法根据不同类型的请求，调用不同的handleXxx方法，生产者请求在handleProduceRequest方法中</p><p>该方法除了调用ReplicaManager#appendRecords,还对日志权限，事务，限流等做了处理，并且定义好了响应回调函数，一并作为参数传给了ReplicaManager#appendRecords方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="function">def <span class="title">handleProduceRequest</span><span class="params">(request: RequestChannel.Request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 转换为具体的请求对象</span></span><br><span class="line">    val produceRequest = request.body[ProduceRequest]</span><br><span class="line">    val numBytesAppended = request.header.toStruct.sizeOf + request.sizeOfBodyInBytes</span><br><span class="line"></span><br><span class="line">    val unauthorizedTopicResponses = mutable.Map[TopicPartition, PartitionResponse]()</span><br><span class="line">    val nonExistingTopicResponses = mutable.Map[TopicPartition, PartitionResponse]()</span><br><span class="line">    val authorizedRequestInfo = mutable.Map[TopicPartition, MemoryRecords]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ((topicPartition, memoryRecords) &lt;- produceRequest.partitionRecordsOrFail.asScala) &#123;</span><br><span class="line">      <span class="comment">// 是否认证通过，是否有write权限</span></span><br><span class="line">      <span class="keyword">if</span> (!authorize(request.session, Write, Resource(Topic, topicPartition.topic, LITERAL)))</span><br><span class="line">        <span class="comment">// 忘了语法... +=是想集合添加元素，但是 -&gt;呢？ 这是map的key-&gt;value 语法</span></span><br><span class="line">        unauthorizedTopicResponses += topicPartition -&gt; <span class="keyword">new</span> PartitionResponse(Errors.TOPIC_AUTHORIZATION_FAILED)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!metadataCache.contains(topicPartition))</span><br><span class="line">        <span class="comment">// 元数据缓存中是否有该tp，元数据缓存是由controller直接更新的</span></span><br><span class="line">        nonExistingTopicResponses += topicPartition -&gt; <span class="keyword">new</span> PartitionResponse(Errors.UNKNOWN_TOPIC_OR_PARTITION)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 剩下的都是可用的消息</span></span><br><span class="line">        authorizedRequestInfo += (topicPartition -&gt; memoryRecords)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the callback for sending a produce response</span></span><br><span class="line">    <span class="comment">// 嵌套方法，定义响应回调，可以先不看</span></span><br><span class="line">    <span class="function">def <span class="title">sendResponseCallback</span><span class="params">(responseStatus: Map[TopicPartition, PartitionResponse])</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ++表示集合合并</span></span><br><span class="line">      val mergedResponseStatus = responseStatus ++ unauthorizedTopicResponses ++ nonExistingTopicResponses</span><br><span class="line">      var errorInResponse = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先打个日志，不管</span></span><br><span class="line">      mergedResponseStatus.foreach &#123; <span class="keyword">case</span> (topicPartition, status) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (status.error != Errors.NONE) &#123;</span><br><span class="line">          errorInResponse = <span class="keyword">true</span></span><br><span class="line">          debug(<span class="string">"Produce request with correlation id %d from client %s on partition %s failed due to %s"</span>.format(</span><br><span class="line">            request.header.correlationId,</span><br><span class="line">            request.header.clientId,</span><br><span class="line">            topicPartition,</span><br><span class="line">            status.error.exceptionName))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略配额限流相关代码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Send the response immediately. In case of throttling, the channel has already been muted.</span></span><br><span class="line">      <span class="comment">// ack=0表示发到broker就返回，不关心副本是否写入</span></span><br><span class="line">      <span class="keyword">if</span> (produceRequest.acks == <span class="number">0</span>) &#123;</span><br><span class="line">          sendNoOpResponseExemptThrottle(request)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ack为-1或1的响应</span></span><br><span class="line">        sendResponse(request, Some(<span class="keyword">new</span> ProduceResponse(mergedResponseStatus.asJava, maxThrottleTimeMs)), None)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有__admin_client客户端才能写入内部topic，例如__consumer_offset</span></span><br><span class="line">  val internalTopicsAllowed = request.header.clientId == AdminUtils.AdminClientId</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call the replica manager to append messages to the replicas</span></span><br><span class="line">  <span class="comment">// 开始调用副本管理器追加消息</span></span><br><span class="line">  replicaManager.appendRecords(</span><br><span class="line">  <span class="comment">// 超时时间, 客户端Sender中的requestTimeoutMs，表示客户端请求超时</span></span><br><span class="line">  timeout = produceRequest.timeout.toLong,</span><br><span class="line">  <span class="comment">// ack参数</span></span><br><span class="line">  requiredAcks = produceRequest.acks,</span><br><span class="line">  <span class="comment">// 是否允许添加内部topic消息</span></span><br><span class="line">  internalTopicsAllowed = internalTopicsAllowed,</span><br><span class="line">  <span class="comment">// 是否来自client，也有可能来自别的broker</span></span><br><span class="line">  isFromClient = <span class="keyword">true</span>,</span><br><span class="line">  <span class="comment">// 消息体</span></span><br><span class="line">  entriesPerPartition = authorizedRequestInfo,</span><br><span class="line">  <span class="comment">// 响应函数</span></span><br><span class="line">  responseCallback = sendResponseCallback,</span><br><span class="line">  <span class="comment">// 状态转换函数</span></span><br><span class="line">  recordConversionStatsCallback = processingStatsCallback</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if the request is put into the purgatory, it will have a held reference and hence cannot be garbage collected;</span></span><br><span class="line">  <span class="comment">// hence we clear its data here in order to let GC reclaim its memory since it is already appended to log</span></span><br><span class="line">  <span class="comment">// 如果需要被放入purgatory，清空引用让GC回收, 因为已经append到log了</span></span><br><span class="line">  produceRequest.clearPartitionRecords()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReplicaManager"><a href="#ReplicaManager" class="headerlink" title="ReplicaManager"></a>ReplicaManager</h1><p>ReplicaManager的主要功能是对分区副本层面做管理，包含日志写入，读取，ISR的变更，副本同步等。</p><p>appendRecords的方法注释如下：将消费追加到分区的leader副本，然后等待它们被follower副本复制，回调函数将会在超时或者ack条件满足是触发</p><p>该方法主要是在append消息之后，对当前请求的处理。ack=-1尝试完成当前请求，在ack=1时直接调用响应函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">appendRecords</span><span class="params">(... )</span> </span>&#123; <span class="comment">//参数参考上面</span></span><br><span class="line">    <span class="comment">// 简单的校验ack合法性，-1，0，1才合法</span></span><br><span class="line">    <span class="keyword">if</span> (isValidRequiredAcks(requiredAcks)) &#123;</span><br><span class="line">      val sTime = time.milliseconds</span><br><span class="line">      <span class="comment">// 写入到本地broker中, 返回每个TPLogAppendResult =&gt; LogAppendInfo和异常</span></span><br><span class="line">      val localProduceResults = appendToLocalLog(internalTopicsAllowed = internalTopicsAllowed,</span><br><span class="line">        isFromClient = isFromClient, entriesPerPartition, requiredAcks)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// produceStatus类型:Map[TopicPartition, ProducePartitionStatus]</span></span><br><span class="line">      <span class="comment">// 这个map保存的是每个TopicPartition append后的状态，状态包括：LEO和结果，结果里面有是否append出现错误等</span></span><br><span class="line">      val produceStatus = localProduceResults.map &#123; <span class="keyword">case</span> (topicPartition, result) =&gt;</span><br><span class="line">        topicPartition -&gt;</span><br><span class="line">                ProducePartitionStatus(</span><br><span class="line">                  result.info.lastOffset + <span class="number">1</span>, <span class="comment">// required offset ， LEO </span></span><br><span class="line">                  <span class="keyword">new</span> PartitionResponse(result.error, result.info.firstOffset.getOrElse(-<span class="number">1</span>), result.info.logAppendTime, result.info.logStartOffset)) <span class="comment">// response status</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      recordConversionStatsCallback(localProduceResults.mapValues(_.info.recordConversionStats))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ack为-1时需要follower同步，需要放入延迟队列中，等待条件满足后返回</span></span><br><span class="line">      <span class="keyword">if</span> (delayedProduceRequestRequired(requiredAcks, entriesPerPartition, localProduceResults)) &#123;</span><br><span class="line">        <span class="comment">// create delayed produce operation</span></span><br><span class="line">        <span class="comment">// ack和消息append后的结果</span></span><br><span class="line">        val produceMetadata = ProduceMetadata(requiredAcks, produceStatus)</span><br><span class="line">        <span class="comment">// 注意看里面的初始化语句块</span></span><br><span class="line">        val delayedProduce = <span class="keyword">new</span> DelayedProduce(timeout, produceMetadata, <span class="keyword">this</span>, responseCallback, delayedProduceLock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是TopicPartition集合</span></span><br><span class="line">        val producerRequestKeys = entriesPerPartition.keys.map(<span class="keyword">new</span> TopicPartitionOperationKey(_)).toSeq</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次尝试结束处理，否则丢入purgatory中，因为下一批消息可能已经到达将这批请求结束</span></span><br><span class="line">        delayedProducePurgatory.tryCompleteElseWatch(delayedProduce, producerRequestKeys)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这是ack=1的时候，leader写入完了，就返回，之前已经处理过ack=0了</span></span><br><span class="line">        val produceResponseStatus = produceStatus.mapValues(status =&gt; status.responseStatus)</span><br><span class="line">        responseCallback(produceResponseStatus)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ack参数无效后直接返回错误</span></span><br><span class="line">      val responseStatus = entriesPerPartition.map &#123; <span class="keyword">case</span> (topicPartition, _) =&gt;</span><br><span class="line">        topicPartition -&gt; <span class="keyword">new</span> PartitionResponse(Errors.INVALID_REQUIRED_ACKS,</span><br><span class="line">          LogAppendInfo.UnknownLogAppendInfo.firstOffset.getOrElse(-<span class="number">1</span>), RecordBatch.NO_TIMESTAMP, LogAppendInfo.UnknownLogAppendInfo.logStartOffset)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后调用传进来的响应回调方法</span></span><br><span class="line">      responseCallback(responseStatus)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="appendToLocalLog方法实现"><a href="#appendToLocalLog方法实现" class="headerlink" title="appendToLocalLog方法实现"></a>appendToLocalLog方法实现</h3><p>appendToLocalLog开始遍历分区消息集合，Map[TopicPartition, MemoryRecords]对象，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Append the messages to the local replica logs</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> internalTopicsAllowed 是否允许操作内部topic</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> isFromClient true，来自客户端</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> entriesPerPartition 消息体</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requiredAcks ack参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> Map[TopicPartition, LogAppendResult]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">appendToLocalLog</span><span class="params">(internalTopicsAllowed: Boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">                           isFromClient: Boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">                           entriesPerPartition: Map[TopicPartition, MemoryRecords],</span></span></span><br><span class="line"><span class="function"><span class="params">                           requiredAcks: Short)</span>: Map[TopicPartition, LogAppendResult] </span>= &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历消息集合，追加消息 map里的case表示是个匿名偏函数</span></span><br><span class="line">entriesPerPartition.map &#123; <span class="keyword">case</span> (topicPartition, records) =&gt;</span><br><span class="line">  <span class="comment">// 如果是内部topic，但没有内部topic的操作权限，就报错，内部topic只有两个__consumer_offsets和__transaction_state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前tp的leader Partition对象</span></span><br><span class="line">      val (partition, _) = getPartitionAndLeaderReplicaIfLocal(topicPartition)</span><br><span class="line">      val info = partition.appendRecordsToLeader(records, isFromClient, requiredAcks)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向一个tp中追加消息结束，返回结果</span></span><br><span class="line">      (topicPartition, LogAppendResult(info))    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Partition-appendRecordsToLeader方法实现"><a href="#Partition-appendRecordsToLeader方法实现" class="headerlink" title="Partition#appendRecordsToLeader方法实现"></a>Partition#appendRecordsToLeader方法实现</h3><p>Partition对象的appendRecordsToLeader方法中检验ack=-1时，min.insync.replicas必须大于ISR个数<br>然后调用Log对象的appendAsLeader-&gt;append方法，追加完消息后，第二次尝试完成生产者请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">appendRecordsToLeader</span><span class="params">(records: MemoryRecords, isFromClient: Boolean, requiredAcks: Int = <span class="number">0</span>)</span>: LogAppendInfo </span>= &#123;</span><br><span class="line">    <span class="comment">// inReadLock是一个柯里化函数，第二个参数是一个函数，返回值是LogAppendInfo和HW是否增加的bool值</span></span><br><span class="line">    <span class="comment">// 相当于给方法加了读锁</span></span><br><span class="line">    val (info, leaderHWIncremented) = inReadLock(leaderIsrUpdateLock) &#123;</span><br><span class="line">      <span class="comment">// leaderReplicaIfLocal表示本地broker中的leader副本</span></span><br><span class="line">      leaderReplicaIfLocal match &#123;</span><br><span class="line">        <span class="comment">//如果存在的话</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(leaderReplica)</span> </span>=&gt;</span><br><span class="line">          <span class="comment">// 获取Replica中的Log对象</span></span><br><span class="line">          val log = leaderReplica.log.get</span><br><span class="line">          <span class="comment">// min.insync.replicas参数</span></span><br><span class="line">          val minIsr = log.config.minInSyncReplicas</span><br><span class="line">          <span class="comment">// Set[Replica] ISR大小</span></span><br><span class="line">          val inSyncSize = inSyncReplicas.size</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Avoid writing to leader if there are not enough insync replicas to make it safe</span></span><br><span class="line">          <span class="comment">// 如果isr的个数没有满足min.insync.replicas就报错，需要知道的是min.insync.replicas是和ack=-1一起使用的</span></span><br><span class="line">          <span class="keyword">if</span> (inSyncSize &lt; minIsr &amp;&amp; requiredAcks == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotEnoughReplicasException(<span class="string">"Number of insync replicas for partition %s is [%d], below required minimum [%d]"</span></span><br><span class="line">              .format(topicPartition, inSyncSize, minIsr))</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 真正的消息追加交给Log对象</span></span><br><span class="line">          val info = log.appendAsLeader(records, leaderEpoch = <span class="keyword">this</span>.leaderEpoch, isFromClient)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 检查Purgatory中，这个tp的操作是否结束，第二次尝试结束处理请求</span></span><br><span class="line">          replicaManager.tryCompleteDelayedFetch(TopicPartitionOperationKey(<span class="keyword">this</span>.topic, <span class="keyword">this</span>.partitionId))</span><br><span class="line">          <span class="comment">// we may need to increment high watermark since ISR could be down to 1</span></span><br><span class="line">          (info, maybeIncrementLeaderHW(leaderReplica))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some delayed operations may be unblocked after HW changed</span></span><br><span class="line">    <span class="keyword">if</span> (leaderHWIncremented)</span><br><span class="line">      tryCompleteDelayedRequests()</span><br><span class="line"></span><br><span class="line">    info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="appendAsLeader-gt-append实现"><a href="#appendAsLeader-gt-append实现" class="headerlink" title="appendAsLeader-&gt;append实现"></a>appendAsLeader-&gt;append实现</h3><p>appendAsLeader方法直接调用了append方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">append</span><span class="params">(records: MemoryRecords, isFromClient: Boolean, assignOffsets: Boolean, leaderEpoch: Int)</span>: LogAppendInfo </span>= &#123;</span><br><span class="line">    maybeHandleIOException(s<span class="string">"Error while appending records to $topicPartition in dir $&#123;dir.getParent&#125;"</span>) &#123;</span><br><span class="line">      val appendInfo = analyzeAndValidateRecords(records, isFromClient = isFromClient)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// return if we have no valid messages or if this is a duplicate of the last appended entry</span></span><br><span class="line">      <span class="keyword">if</span> (appendInfo.shallowCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> appendInfo</span><br><span class="line"></span><br><span class="line">      <span class="comment">// trim any invalid bytes or partial messages before appending it to the on-disk log</span></span><br><span class="line">      var validRecords = trimInvalidBytes(records, appendInfo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      lock <span class="keyword">synchronized</span> &#123;</span><br><span class="line">      <span class="comment">// assignOffsets写死为true，就不看else了</span></span><br><span class="line">        <span class="keyword">if</span> (assignOffsets) &#123;</span><br><span class="line">          <span class="comment">// assign offsets to the message set</span></span><br><span class="line">          val offset = <span class="keyword">new</span> LongRef(nextOffsetMetadata.messageOffset)</span><br><span class="line">          <span class="comment">// firstOffset又重新赋值了</span></span><br><span class="line">          appendInfo.firstOffset = Some(offset.value)</span><br><span class="line">          val now = time.milliseconds</span><br><span class="line">          <span class="comment">// 各种验证</span></span><br><span class="line">          val validateAndOffsetAssignResult = LogValidator.validateMessagesAndAssignOffsets(validRecords,</span><br><span class="line">              offset,</span><br><span class="line">              time,</span><br><span class="line">              now,</span><br><span class="line">              appendInfo.sourceCodec,</span><br><span class="line">              appendInfo.targetCodec,</span><br><span class="line">              config.compact,</span><br><span class="line">              config.messageFormatVersion.recordVersion.value,</span><br><span class="line">              config.messageTimestampType,</span><br><span class="line">              config.messageTimestampDifferenceMaxMs,</span><br><span class="line">              leaderEpoch,</span><br><span class="line">              isFromClient)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 验证通过后的消息</span></span><br><span class="line">          validRecords = validateAndOffsetAssignResult.validatedRecords</span><br><span class="line">          <span class="comment">// 根据校验结果完善appendInfo对象</span></span><br><span class="line">          appendInfo.maxTimestamp = validateAndOffsetAssignResult.maxTimestamp</span><br><span class="line">          appendInfo.offsetOfMaxTimestamp = validateAndOffsetAssignResult.shallowOffsetOfMaxTimestamp</span><br><span class="line">          appendInfo.lastOffset = offset.value - <span class="number">1</span></span><br><span class="line">          appendInfo.recordConversionStats = validateAndOffsetAssignResult.recordConversionStats</span><br><span class="line">          <span class="keyword">if</span> (config.messageTimestampType == TimestampType.LOG_APPEND_TIME)</span><br><span class="line">            appendInfo.logAppendTime = now</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (validateAndOffsetAssignResult.messageSizeMaybeChanged) &#123;</span><br><span class="line">            <span class="keyword">for</span> (batch &lt;- validRecords.batches.asScala) &#123;</span><br><span class="line">              <span class="comment">// 每一批消息不能比max.message.bytes大</span></span><br><span class="line">              <span class="keyword">if</span> (batch.sizeInBytes &gt; config.maxMessageSize) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RecordTooLargeException(s<span class="string">"Message batch size is $&#123;batch.sizeInBytes&#125; bytes in append to"</span> +</span><br><span class="line">                  s<span class="string">"partition $topicPartition which exceeds the maximum configured size of $&#123;config.maxMessageSize&#125;."</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the epoch cache with the epoch stamped onto the message by the leader</span></span><br><span class="line">        validRecords.batches.asScala.foreach &#123; batch =&gt;</span><br><span class="line">          <span class="keyword">if</span> (batch.magic &gt;= RecordBatch.MAGIC_VALUE_V2)</span><br><span class="line">            _leaderEpochCache.assign(batch.partitionLeaderEpoch, batch.baseOffset)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check messages set size may be exceed config.segmentSize</span></span><br><span class="line">        <span class="comment">// MemoryRecords总消息不能比segment.bytes大</span></span><br><span class="line">        <span class="keyword">if</span> (validRecords.sizeInBytes &gt; config.segmentSize) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RecordBatchTooLargeException(s<span class="string">"Message batch size is $&#123;validRecords.sizeInBytes&#125; bytes in append "</span> +</span><br><span class="line">            s<span class="string">"to partition $topicPartition, which exceeds the maximum configured segment size of $&#123;config.segmentSize&#125;."</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// maybe roll the log if this segment is full</span></span><br><span class="line">        <span class="comment">// 是否需要生成一个新的segment，具体判断条件见下文</span></span><br><span class="line">        val segment = maybeRoll(validRecords.sizeInBytes, appendInfo)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存位移的VO</span></span><br><span class="line">        val logOffsetMetadata = LogOffsetMetadata(</span><br><span class="line">          messageOffset = appendInfo.firstOrLastOffsetOfFirstBatch,</span><br><span class="line">          segmentBaseOffset = segment.baseOffset,</span><br><span class="line">          relativePositionInSegment = segment.size)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正append日志的是LogSegment对象</span></span><br><span class="line">        segment.append(largestOffset = appendInfo.lastOffset,</span><br><span class="line">          largestTimestamp = appendInfo.maxTimestamp,</span><br><span class="line">          shallowOffsetOfMaxTimestamp = appendInfo.offsetOfMaxTimestamp,</span><br><span class="line">          records = validRecords)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新LEO，lastOffset + 1</span></span><br><span class="line">        updateLogEndOffset(appendInfo.lastOffset + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unflushedMessages &gt;= config.flushInterval)</span><br><span class="line">          flush()</span><br><span class="line"></span><br><span class="line">        appendInfo</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Roll-Segment-滚动日志段"><a href="#Roll-Segment-滚动日志段" class="headerlink" title="Roll Segment(滚动日志段)"></a>Roll Segment(滚动日志段)</h3><p>首先说一下什么是Roll，可以联想一下log4j日志的滚动，就是在一定条件下，自动生成新文件，常见的log4j一个小时Roll一次，还有用过ES的同学，也可以联想一下Roll Index<br>上文的maybeRoll方法返回要追加消息的segment，要么用当前的activeSegment，要么新生成一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">maybeRoll</span><span class="params">(messagesSize: Int, appendInfo: LogAppendInfo)</span>: LogSegment </span>= &#123;</span><br><span class="line">    val segment = activeSegment</span><br><span class="line">    val now = time.milliseconds</span><br><span class="line"></span><br><span class="line">    val maxTimestampInMessages = appendInfo.maxTimestamp</span><br><span class="line">    val maxOffsetInMessages = appendInfo.lastOffset</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (segment.shouldRoll(messagesSize, maxTimestampInMessages, maxOffsetInMessages, now)) &#123;</span><br><span class="line">      <span class="comment">// 省略了代码</span></span><br><span class="line">      roll(maxOffsetInMessages - Integer.MAX_VALUE)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不需要Roll，就返回当前正在使用的Segment：activeSegment</span></span><br><span class="line">      segment</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Roll方法其实就是在新建.log, .index, .timeIndex文件，如果用了事务，还会有.txnindex文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">roll</span><span class="params">(expectedNextOffset: Long = <span class="number">0</span>)</span>: LogSegment </span>= &#123;</span><br><span class="line">    maybeHandleIOException(s<span class="string">"Error while rolling log segment for $topicPartition in dir $&#123;dir.getParent&#125;"</span>) &#123;</span><br><span class="line">      val start = time.hiResClockMs()</span><br><span class="line">      lock <span class="keyword">synchronized</span> &#123;</span><br><span class="line">        checkIfMemoryMappedBufferClosed()</span><br><span class="line">        val newOffset = math.max(expectedNextOffset, logEndOffset)</span><br><span class="line">        <span class="comment">// 新建.log, .index, .timeIndex文件，如果用了事务，还会有.txnindex文件</span></span><br><span class="line">        val logFile = Log.logFile(dir, newOffset)</span><br><span class="line">        val offsetIdxFile = offsetIndexFile(dir, newOffset)</span><br><span class="line">        val timeIdxFile = timeIndexFile(dir, newOffset)</span><br><span class="line">        val txnIdxFile = transactionIndexFile(dir, newOffset)</span><br><span class="line">        <span class="comment">// 检查是否已存在以上文件，存在则先删除</span></span><br><span class="line">        <span class="keyword">for</span> (file &lt;- List(logFile, offsetIdxFile, timeIdxFile, txnIdxFile) <span class="keyword">if</span> file.exists) &#123;</span><br><span class="line">          warn(s<span class="string">"Newly rolled segment file $&#123;file.getAbsolutePath&#125; already exists; deleting it first"</span>)</span><br><span class="line">          Files.delete(file.toPath)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// segments使用一个跳表构建的Map，说明Segment使用跳表组织的</span></span><br><span class="line">        <span class="comment">// key是Segment的baseOffset，value是Segment对象</span></span><br><span class="line">        Option(segments.lastEntry).foreach(_.getValue.onBecomeInactiveSegment())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建LogSegment，添加到segments集合里</span></span><br><span class="line">        val segment = LogSegment.open(dir,</span><br><span class="line">          baseOffset = newOffset,</span><br><span class="line">          config,</span><br><span class="line">          time = time,</span><br><span class="line">          fileAlreadyExists = <span class="keyword">false</span>,</span><br><span class="line">          initFileSize = initFileSize,</span><br><span class="line">          preallocate = config.preallocate)</span><br><span class="line">        val prev = addSegment(segment)</span><br><span class="line">        <span class="comment">// 说明已存在</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(s<span class="string">"Trying to roll a new log segment for topic partition $topicPartition with "</span> +</span><br><span class="line">            s<span class="string">"start offset $newOffset while it already exists."</span>)</span><br><span class="line">        <span class="comment">// 更新LEO</span></span><br><span class="line">        updateLogEndOffset(nextOffsetMetadata.messageOffset)</span><br><span class="line">        <span class="comment">// 将recoveryPoint到新segment offset，也就是老的segment刷盘，包含4个文件：.log, .index, .timeIndex，.txnindex</span></span><br><span class="line">        scheduler.schedule(<span class="string">"flush-log"</span>, () =&gt; flush(newOffset), delay = <span class="number">0L</span>)</span><br><span class="line"></span><br><span class="line">        segment</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="FileChannel写入"><a href="#FileChannel写入" class="headerlink" title="FileChannel写入"></a>FileChannel写入</h3><p>最后的写入过程如下<br>MemoryRecords是生产者发送MemoryRecords，也是server端接收的对象，因此把写入方法定义在了MemoryRecords中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">append</span><span class="params">(MemoryRecords records)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> written = records.writeFullyTo(channel);</span><br><span class="line">    size.getAndAdd(written);</span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeFullyTo</span><span class="params">(GatheringByteChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    buffer.mark();</span><br><span class="line">    <span class="keyword">int</span> written = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (written &lt; sizeInBytes())</span><br><span class="line">        written += channel.write(buffer);</span><br><span class="line">    buffer.reset();</span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说kafka在ReplicaManager,Partition,Log,LogSegment对象的层层调用来append消息。</p><p>在ack=-1时，因为follower同步之后，才算是消息提交(commit)，而在消息append过程中，并不知道什么时候follower完成同步</p><p>kafka的做法是多次尝试完成生产者请求，因此在源码中我们可以看到在append完成后，还会尝试完成生产者请求，否则放入Purgatory中监听(tryCompleteElseWatch)。</p><p>等待follower副本同步完成，再次尝试完成生产者请求(tryCompleteDelayedFetch)</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka网络请求处理模型</title>
      <link href="/2019/12/06/kafka%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/12/06/kafka%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>众所周知，kafka是一款高性能，可伸缩的消息队列中间件，在一个庞大的kafka集群中，每秒能处理几十万条消息，那么必然存在着大量的网络请求，kafka是如何构建自己的网络请求模型的呢，答案就是Reactor</p><h1 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h1><p>Reactor线程模型即为Java NIO中的selector模型。最简单的Reactor模型中，有多个client向服务端发送请求，首先请求会达到Dispatcher组件，它负责将不同的请求分发到多个线程中处理<br><img src="https://ae01.alicdn.com/kf/H969ad8e2946e4fd284760f4868e91fcfD.png" alt="Reactor线程模型"></p><p>Acceptor(Dispatcher)将变得十分轻量，因为它只负责分发，不用处理十分复杂的逻辑，而worker线程可以伸容、缩容，达到负载均衡的效果。<br>但是当处理读写任务的线程负载过高后，处理速度下降，事件会堆积，严重的会超时，可能导致客户端重新发送请求，性能越来越差</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>kafka server中当Acceptor将请求分发给Processor后，Processor并不处理，而是将请求放入到一个请求队列(requestQueue)中<br>同时还有一个IO线程池(KafkaRequestHandlerPoll)，该线程池大小由num.io.threads参数控制，默认为8，其中的KafkaRequestHandler线程，通过轮询的方式(300ms)从请求队列中取出请求，执行真正的处理。</p><p>KafkaRequestHandler背后真正负责处理的是一个叫做KafkaApis的类，它可以处理40多种请求，包含client与其它broker的请求，其中最重要的就是PRODUCE生产请求和FETCH消费拉取请求。PRODUCE将消息写入日志中；FETCH则从磁盘或页缓存中读取消息。</p><p>当IO线程处理完请求后，会将生成的响应发送到网络线程池的响应队列中，然后由对应的网络线程负责将Response返还给客户端。<br>请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的。这么设计的原因就在于，Acceptor只是用于请求分发而不负责响应回传，因此只能让每个网络线程自己发送Response给客户端，所以这些Response也就没必要放在一个公共的地方。</p><p><img src="https://ae01.alicdn.com/kf/H9d81a3a1afa14c2d945eef4dcce57ec8D.png" alt="kafka请求处理流程"></p><p>在有了上面对kafka的感性认知之后，再来看看它的源码是怎么写的</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>希望大家在看源码之前对java nio代码有一定的熟悉程度，可以事先看看博客，参考我github上的<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/java8/src/main/java/com/net/nio" target="_blank" rel="noopener">代码</a><br>阅读源码时不要去关注边缘代码，这会影响我们的思路，大部分代码我都做了删减，只保留核心部分代码</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Acceptor与Processor的初始化"><a href="#Acceptor与Processor的初始化" class="headerlink" title="Acceptor与Processor的初始化"></a>Acceptor与Processor的初始化</h2><p>从Kafka#main方法出发，跟踪到KafkaServer#startup方法，该方法涵盖kafka server所有模块的初始化，其中也包括了网络请求处理模块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and start the socket server acceptor threads so that the bound port is known.</span></span><br><span class="line"><span class="comment">// Delay starting processors until the end of the initialization sequence to ensure</span></span><br><span class="line"><span class="comment">// that credentials have been loaded before processing authentications.</span></span><br><span class="line">socketServer = <span class="keyword">new</span> SocketServer(config, metrics, time, credentialProvider)</span><br><span class="line">socketServer.startup(startupProcessors = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure></p><h3 id="SocketServer-startup"><a href="#SocketServer-startup" class="headerlink" title="SocketServer#startup"></a>SocketServer#startup</h3><p>SocketServer核心代码如下，第一个参数numNetworkThreads，这是num.network.threads配置的值<br>第二个参数则是listeners配置的值，它是一个EndPoint集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span></span>&#123;</span><br><span class="line"><span class="function">def <span class="title">startup</span><span class="params">(startupProcessors: Boolean = <span class="keyword">true</span>)</span> </span>&#123;</span><br><span class="line">createAcceptorAndProcessors(config.numNetworkThreads, config.listeners)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="创建Acceptor与Processor"><a href="#创建Acceptor与Processor" class="headerlink" title="创建Acceptor与Processor"></a>创建Acceptor与Processor</h3><p>遍历EndPoint集合并在里面创建Acceptor，并启动Acceptor线程</p><p>Acceptor的个数和配置里listeners的个数有关，也就是一个服务用几个端口去监听网络请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">createAcceptorAndProcessors</span><span class="params">(processorsPerListener: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  endpoints: Seq[EndPoint])</span>: Unit </span>= <span class="keyword">synchronized</span> &#123;</span><br><span class="line">endpoints.foreach &#123; endpoint =&gt;</span><br><span class="line">val acceptor = <span class="keyword">new</span> Acceptor(endpoint, sendBufferSize, recvBufferSize, brokerId, connectionQuotas)</span><br><span class="line">addProcessors(acceptor, endpoint, processorsPerListener)</span><br><span class="line"></span><br><span class="line">KafkaThread.nonDaemon(s<span class="string">"kafka-socket-acceptor-$listenerName-$securityProtocol-$&#123;endpoint.port&#125;"</span>, acceptor).start()</span><br><span class="line">acceptor.awaitStartup()</span><br><span class="line">acceptors.put(endpoint, acceptor)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Acceptor类简要分析"><a href="#Acceptor类简要分析" class="headerlink" title="Acceptor类简要分析"></a>Acceptor类简要分析</h3><p>进入到Acceptor类中，下面这行代码建立了socket。注：scala类中，非方法的语句在初始化之前都会先执行，而java中语句只能定义在方法中</p><p>Acceptor的初始化是一个标准的nio ServerSocketChannel创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[kafka] <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractServerThread</span>(间接<span class="keyword">extends</span> <span class="title">Runnable</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 初始化语句</span></span><br><span class="line">val serverChannel = openServerSocket(endPoint.host, endPoint.port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相信熟悉java nio代码的同学看到这里很熟悉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">openServerSocket</span><span class="params">(host: String, port: Int)</span>: ServerSocketChannel </span>= &#123;</span><br><span class="line">val socketAddress =</span><br><span class="line">  <span class="keyword">if</span> (host == <span class="keyword">null</span> || host.trim.isEmpty)</span><br><span class="line">    <span class="keyword">new</span> InetSocketAddress(port)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">new</span> InetSocketAddress(host, port)</span><br><span class="line">val serverChannel = ServerSocketChannel.open()</span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line">serverChannel.socket.bind(socketAddress) </span><br><span class="line">serverChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Acceptor-run方法"><a href="#Acceptor-run方法" class="headerlink" title="Acceptor#run方法"></a>Acceptor#run方法</h4><p>Acceptor本身也是一个线程，在run方法中通过select轮询，接收请求，并将数据通过round-robin(轮询)的方式分配给不同的Processor处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">serverChannel.register(nioSelector, SelectionKey.OP_ACCEPT)</span><br><span class="line">var currentProcessor = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">val ready = nioSelector.select(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">if</span> (ready &gt; <span class="number">0</span>) &#123;</span><br><span class="line">val keys = nioSelector.selectedKeys()</span><br><span class="line">val iter = keys.iterator()</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext &amp;&amp; isRunning) &#123;</span><br><span class="line">  </span><br><span class="line">    val key = iter.next</span><br><span class="line">    iter.remove()</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable) &#123;</span><br><span class="line">      val processor = <span class="keyword">synchronized</span> &#123;</span><br><span class="line">        currentProcessor = currentProcessor % processors.size</span><br><span class="line">        processors(currentProcessor)</span><br><span class="line">      &#125;</span><br><span class="line">      accept(key, processor)</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized key state for acceptor thread."</span>)</span><br><span class="line">    <span class="comment">// round robin to the next processor thread, mod(numProcessors) will be done later</span></span><br><span class="line">    currentProcessor = currentProcessor + <span class="number">1</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意accept(key, processor)这行代码是将请求保存到了Processor对象一个叫做newConnections队列对象中了，它的类型为ConcurrentLinkedQueue<socketchannel><br>这为Processor后续的处理埋下了伏笔</socketchannel></p><h3 id="Processor初始化"><a href="#Processor初始化" class="headerlink" title="Processor初始化"></a>Processor初始化</h3><p>在初始化Acceptor之后，在创建Acceptor之后，<a href="#创建Acceptor与Processor">addProcessors</a>方法会根据num.network.threads的个数循环去创建Processor线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">addProcessors</span><span class="params">(acceptor: Acceptor, endpoint: EndPoint, newProcessorsPerListener: Int)</span>: Unit </span>= <span class="keyword">synchronized</span> &#123;</span><br><span class="line">  val listenerProcessors = <span class="keyword">new</span> ArrayBuffer[Processor]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (_ &lt;- <span class="number">0</span> until newProcessorsPerListener) &#123;</span><br><span class="line">    val processor = newProcessor(nextProcessorId, connectionQuotas, listenerName, securityProtocol, memoryPool)</span><br><span class="line">    listenerProcessors += processor</span><br><span class="line">    requestChannel.addProcessor(processor)</span><br><span class="line">    nextProcessorId += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  listenerProcessors.foreach(p =&gt; processors.put(p.id, p))</span><br><span class="line">  acceptor.addProcessors(listenerProcessors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中有两行代码比较关键<br>requestChannel.addProcessor(processor)是将Processor添加到RequestChannel的缓存map中，为以后的请求处理做准备<br>acceptor.addProcessors(listenerProcessors)是为Acceptor和Processor做关系映射，说明该Processor属于该Acceptor，同时该方法内部启动了Processor线程</p><p>相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">startProcessors</span><span class="params">(processors: Seq[Processor])</span>: Unit </span>= <span class="keyword">synchronized</span> &#123;</span><br><span class="line">processors.foreach &#123; processor =&gt;</span><br><span class="line">KafkaThread.nonDaemon(<span class="string">"..."</span>,processor).start()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Processor类简要分析"><a href="#Processor类简要分析" class="headerlink" title="Processor类简要分析"></a>Processor类简要分析</h3><p>既然Processor是一个线程，那么run方法是必须要看的, 在看run方法之前，需要知道Processor初始化了一个selector<br>虽然它叫KSelector(scala可以重命名import的类), 但熟悉kafka java客户端源码的同学应该知道，这就是kafka客户端中基于java nio Selector封装的Selector。<br>希望大家不要被绕晕了，简而言之，kafka在java nio Selector上封装了一个自己的Selector，而且是同名的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.common.network.&#123;..., Selector =&gt; KSelector&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>[network] <span class="function">def <span class="title">createSelector</span><span class="params">(channelBuilder: ChannelBuilder)</span>: KSelector </span>= &#123;</span><br><span class="line">    <span class="keyword">new</span> KSelector(</span><br><span class="line">      maxRequestSize,</span><br><span class="line">      connectionsMaxIdleMs,</span><br><span class="line">      metrics,</span><br><span class="line">      time,</span><br><span class="line">      <span class="string">"socket-server"</span>,</span><br><span class="line">      metricTags,</span><br><span class="line">      <span class="keyword">false</span>,</span><br><span class="line">      <span class="keyword">true</span>,</span><br><span class="line">      channelBuilder,</span><br><span class="line">      memoryPool,</span><br><span class="line">      logContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">startupComplete()</span><br><span class="line"><span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line"><span class="comment">// setup any new connections that have been queued up</span></span><br><span class="line">configureNewConnections()</span><br><span class="line"><span class="comment">// register any new responses for writing</span></span><br><span class="line">processNewResponses()</span><br><span class="line">poll()</span><br><span class="line">processCompletedReceives()</span><br><span class="line">processCompletedSends()</span><br><span class="line">processDisconnected()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="#Acceptor#run方法">Acceptor#run方法</a>中，kafka将SocketChannel保存到了Processor的一个ConcurrentLinkedQueue<socketchannel>队列中<br>这里依次调用的6个方法就是对队列轮询，取出SocketChannel并做处理</socketchannel></p><ol><li>configureNewConnections：向selector注册OP_READ事件</li><li>processNewResponses：处理响应</li><li>poll：将网络请求放入到List<networkreceive>集合中</networkreceive></li><li>processCompletedReceives：遍历List<networkreceive>集合，构建Request对象，放入到RequestChannel的requestQueue队列中<br>5,6省略，不是现在关心的</networkreceive></li></ol><h4 id="processCompletedReceives详细"><a href="#processCompletedReceives详细" class="headerlink" title="processCompletedReceives详细"></a>processCompletedReceives详细</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">processCompletedReceives</span><span class="params">()</span> </span>&#123;</span><br><span class="line">selector.completedReceives.asScala.foreach &#123; receive =&gt;</span><br><span class="line">    openOrClosingChannel(receive.source) match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(channel)</span> </span>=&gt;</span><br><span class="line">      <span class="comment">// 构建Request对象</span></span><br><span class="line">        val header = RequestHeader.parse(receive.payload)</span><br><span class="line">        val connectionId = receive.source</span><br><span class="line">        val context = <span class="keyword">new</span> RequestContext(header, connectionId, channel.socketAddress,</span><br><span class="line">          channel.principal, listenerName, securityProtocol)</span><br><span class="line">        val req = <span class="keyword">new</span> RequestChannel.Request(processor = id, context = context,</span><br><span class="line">          startTimeNanos = time.nanoseconds, memoryPool, receive.payload, requestChannel.metrics)</span><br><span class="line">        <span class="comment">// 发送到RequestChannel的requestQueue队列中</span></span><br><span class="line">        requestChannel.sendRequest(req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们已经分析完了一半的流程<br><img src="https://ae01.alicdn.com/kf/H5ba778ed69274f8380f75ff04b88d2234.png" alt="处理流程"></p><h2 id="KafkaRequestHandler"><a href="#KafkaRequestHandler" class="headerlink" title="KafkaRequestHandler"></a>KafkaRequestHandler</h2><p>KafkaRequestHandler线程run方法如下, requestChannel.receiveRequest就是每300ms从requestQueue轮询请求，最后交给KafkaApis#handle方法处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">val req = requestChannel.receiveRequest(<span class="number">300</span>)</span><br><span class="line">req match &#123;</span><br><span class="line"><span class="keyword">case</span> request: RequestChannel.Request =&gt;</span><br><span class="line">apis.handle(request)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestChannel"><a href="#RequestChannel" class="headerlink" title="RequestChannel"></a>RequestChannel</h3><p>requestQueue是一个ArrayBlockingQueue有界队列，队列大小由queued.max.requests参数控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class RequestChannel(val queueSize: Int) extends KafkaMetricsGroup &#123;</span><br><span class="line"><span class="keyword">private</span> val requestQueue = <span class="keyword">new</span> ArrayBlockingQueue[BaseRequest](queueSize)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">receiveRequest</span><span class="params">(timeout: Long)</span>: RequestChannel.BaseRequest </span>= </span><br><span class="line">requestQueue.poll(timeout, TimeUnit.MILLISECONDS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KafkaApis处理请求"><a href="#KafkaApis处理请求" class="headerlink" title="KafkaApis处理请求"></a>KafkaApis处理请求</h3><p>KafkaApis具体的请求处理流程以<a href="https://greedypirate.github.io/2019/11/02/kafka-server%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-%E4%B8%80/">kafka server端源码分析之接收消息(一)</a>为例，在每个请求处理结束后，都会调用RequestChannel的sendResponse方法，将Response放入LinkedBlockingDeque无界队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> val responseQueue = <span class="keyword">new</span> LinkedBlockingDeque[RequestChannel.Response]()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Send a response back to the socket server to be sent over the network */</span></span><br><span class="line"><span class="function">def <span class="title">sendResponse</span><span class="params">(response: RequestChannel.Response)</span> </span>&#123;</span><br><span class="line">  val processor = processors.get(response.processor)</span><br><span class="line">  <span class="comment">// The processor may be null if it was shutdown. In this case, the connections</span></span><br><span class="line">  <span class="comment">// are closed, so the response is dropped.</span></span><br><span class="line">  <span class="keyword">if</span> (processor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    processor.enqueueResponse(response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 放入队列</span></span><br><span class="line"><span class="keyword">private</span>[network] <span class="function">def <span class="title">enqueueResponse</span><span class="params">(response: RequestChannel.Response)</span>: Unit </span>= &#123;</span><br><span class="line">  responseQueue.put(response)</span><br><span class="line">  wakeup()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://ae01.alicdn.com/kf/H4e58b30e781b4d2bbdc0a9010fe240dfa.png" alt="sendResponse方法调用链"></p><h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>在<a href="#Processor类简要分析">Processor类简要分析</a>中，有6个方法，其中第2个方法用于处理新的响应，现在向responseQueue队列中放入了Response对象后，回过头来看看发送的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">processNewResponses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    var currentResponse: RequestChannel.Response = <span class="keyword">null</span></span><br><span class="line">    <span class="keyword">while</span> (&#123;currentResponse = dequeueResponse(); currentResponse != <span class="keyword">null</span>&#125;) &#123;</span><br><span class="line">      val channelId = currentResponse.request.context.connectionId</span><br><span class="line"></span><br><span class="line">      currentResponse match &#123;</span><br><span class="line">        <span class="keyword">case</span> response: SendResponse =&gt;</span><br><span class="line">          sendResponse(response, response.responseSend)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>处理响应的代码很清晰，通过dequeueResponse方法获取responseQueue中的Response，循环发送给客户端或其它broker<br>sendResponse方法的代码几乎只有一行，inflightResponses用于保存发送中的Response，表示还未收到客户端应答</p><p>注：带有inflight前缀的还有inflightRequest，含义也是类似的，常用于客户端请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selector.send(responseSend)</span><br><span class="line">inflightResponses += (connectionId -&gt; response)</span><br></pre></td></tr></table></figure></p><p>至此整个kafka的网络请求处理流程分析结束，接下来将会分析kafka server如何处理生产者发送的消息，如何应答消费者的fetch请求，这些都是实际开发中常用的功能，必须要扎实掌握</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《快手万亿级别Kafka集群应用实践与技术演进之路》观后心得</title>
      <link href="/2019/11/21/%E3%80%8A%E5%BF%AB%E6%89%8B%E4%B8%87%E4%BA%BF%E7%BA%A7%E5%88%ABKafka%E9%9B%86%E7%BE%A4%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%A7%82%E5%90%8E%E5%BF%83%E5%BE%97/"/>
      <url>/2019/11/21/%E3%80%8A%E5%BF%AB%E6%89%8B%E4%B8%87%E4%BA%BF%E7%BA%A7%E5%88%ABKafka%E9%9B%86%E7%BE%A4%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%A7%82%E5%90%8E%E5%BF%83%E5%BE%97/</url>
      <content type="html"><![CDATA[<blockquote><p>本文用于记录观看快手万亿级别Kafka集群应用实践与技术演进之路演讲后的心得，从中确实学到了很多，快手作为kafka的重度使用者，对kafka集群从不同角度优化，其中发现问题，解决问题的思路都值得学习</p></blockquote><p>以下这张图是本次演讲的内容，分章节阐述具体内容<br><img src="https://ae01.alicdn.com/kf/Hb4200382b3f448eeb7ebbda8d380768cP.jpg" alt=""></p><h1 id="平滑扩容"><a href="#平滑扩容" class="headerlink" title="平滑扩容"></a>平滑扩容</h1><p>kafka集群节点扩容时，要做副本迁移，但kafka是从副本最开始的offset同步的，并且消息是在不断写入的，那么就要去同步的速度要大于写入的速度，才有可能同步完，要么就会产生以下问题</p><h2 id="磁盘读取"><a href="#磁盘读取" class="headerlink" title="磁盘读取"></a>磁盘读取</h2><p>从最开始的offset开始迁移，就极有可能是在磁盘上，而不是在pageCache中，迁移过程将加大磁盘的负载，影响生产者的写入效率，造成不稳定</p><p>同时kafka有消息过期机制，假设同步完成后，消息过期了，就白同步了。而在大型集群中，一次同步动辄几个小时都是有可能的</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>对最早的offset同步产生质疑，是否有可能从最新的offset开始同步，答案是肯定的，但是这样做会有消费者丢失数据的情况。<br>假设以下情形，消费者拉取消息offset为5，高水位线为8，LEO为10，此时集群扩容，新副本从10开始同步，那么新副本成为leader后，就丢失了6-9的数据</p><p>解决这个问题也不难，快手的解决方案是同步一段时间，等所有消费者都已经消费。<br>我个人的观点是从消费者已提交的位置开始同步，保险起见可以再往前一部分offset</p><h1 id="Mirror集群"><a href="#Mirror集群" class="headerlink" title="Mirror集群"></a>Mirror集群</h1><p>MirrorMarker是用于同步多个kafka集群的工具，但它有很多缺点，不足以大规模应用</p><ol><li>无法同步消费者offset</li><li>缺乏监控</li><li>topic是静态配置的，增加topic需要重启MirrorMarker</li><li>只支持一个集群到另一个集群的同步，无法同步多个集群</li></ol><h1 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h1><p>在<a href="https://greedypirate.github.io/2019/12/29/kafka%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/">kafka网络请求处理模型</a>一文中，阐述了Processor是如何将请求放入requestQueue中的，<br><img src="https://ae01.alicdn.com/kf/H9d81a3a1afa14c2d945eef4dcce57ec8D.png" alt="kafka请求处理流程"><br>该队列是一个有界队列，大小由queued.max.requests参数控制，默认是500，当某一个topic出现问题时，kafka处理速度变慢，导致队列满了，后续请求被阻塞，向上导致Processor和Acceptor接收网络请求被阻塞，这是不能接受的<br>快手的策略是多队列，每个队列后面跟一个worker线程池(KafkaRequestHandlerPoll), 同时发现队列满了以后，请求被丢弃</p><h1 id="cache改造"><a href="#cache改造" class="headerlink" title="cache改造"></a>cache改造</h1><p>cache改造是我很感兴趣的一个部分，原来pageCache有很多稳定性问题，导致缓存命中率降低</p><p>在理想情况下，生产者发送的消费写入到pageCache中，消费者在缓存未失效的情况下，从pageCache中读取，整个过程是基于内存的，效率非常高<br>但是这以下两种情况下，pageCache会被污染，到时消息在pageCache中失效，需要从磁盘中读取，降低了效率</p><ol><li>线上环境消息积压是极有可能的情况，被积压的消息大概率是在磁盘中，此时消费者拉取消息就会将历史消息加载pageCache中<br>而正常topic写入的消息能够使用的pageCache就减少了，又会被写入到磁盘中，此时正常topic的消费者来消费时就要读取磁盘，降低了pageCache的命中率</li><li>follower副本从leader副本同步后，也要写入到broker磁盘中区，但是它也是要先写到pageCache中，我们都知道kafka中的follower副本是不提供读写能力的，那么它也写到pageCache中就很浪费内存了</li></ol><h2 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h2><p>让kafka不要重度依赖pageCache，构建kafka自己的内存cache<br><img src="https://ae01.alicdn.com/kf/H8509500f136e4f3f892e81b07e0cbd71B.png" alt="kafka-cache"></p><p>基于以上设计，consumer拉取消费时，先从cache中获取消息，没有再去pageCache中获取</p>]]></content>
      
      <categories>
          
          <category> 架构随笔录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 演讲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka消费者源码浅析(一)</title>
      <link href="/2019/11/08/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E4%B8%80/"/>
      <url>/2019/11/08/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E4%B8%80/</url>
      <content type="html"><![CDATA[<blockquote><p>本文从消费者拉取消息开始分析消费流程，但kafka并不是单纯的在poll方法中拉取消息，鉴于消费者组的存在，以及Rebalance动作，使整个消费流程的复杂度直线上升，因此需要比生产者花费更多的章节去讲解</p></blockquote><h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>本文首先解析消费者组协调者的初始化，先将poll方法中第一步看懂</p><h1 id="coordinator初始化流程"><a href="#coordinator初始化流程" class="headerlink" title="coordinator初始化流程"></a>coordinator初始化流程</h1><p><img src="https://ae01.alicdn.com/kf/Hcc2697b072b84bd7a8f5a749e43613c5n.png" alt="初始化流程"></p><p>以上是coordinator初始化的流程，大致归纳为：以groupId为参数，向一个负载最小(未完成请求最少)的节点发送请求，成功之后初始化coordinator</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>为了节省时间，将不是核心的部分代码省略</p><h2 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h2><p>源码如下，updateAssignmentMetadataIfNeeded方法coordinator初始化的入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// elapsed 就是已用时间, 因为poll中有多次网络请求，最终要保证不超过timeoutMs，poll方法的参数</span></span><br><span class="line">        <span class="keyword">long</span> elapsedTime = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> metadataEnd;</span><br><span class="line">            <span class="comment">// 每一次fetch请求之前，都会先检查coordinator</span></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> metadataStart = time.milliseconds(); <span class="comment">// SystemTime</span></span><br><span class="line">                <span class="comment">// 检查coordinator是否可用，传入剩余时间，此时elapsedTime=0，其实就是timeoutMs</span></span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(remainingTimeAtLeastZero(timeoutMs, elapsedTime))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">                metadataEnd = time.milliseconds();</span><br><span class="line">                elapsedTime += metadataEnd - metadataStart;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(remainingTimeAtLeastZero(timeoutMs, elapsedTime));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> fetchEnd = time.milliseconds();</span><br><span class="line">            elapsedTime += fetchEnd - metadataEnd;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (elapsedTime &lt; timeoutMs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = time.milliseconds();</span><br><span class="line">    <span class="keyword">if</span> (!coordinator.poll(timeoutMs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(remainingTimeAtLeastZero(timeoutMs, time.milliseconds() - startMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于position"><a href="#关于position" class="headerlink" title="关于position"></a>关于position</h3><p>这里说的position是指TopicPartitionState的position属性，它记录上一次拉取的位移，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateFetchPositions</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    cachedSubscriptionHashAllFetchPositions = subscriptions.hasAllFetchPositions();</span><br><span class="line">    <span class="keyword">if</span> (cachedSubscriptionHashAllFetchPositions) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any partitions which do not have a valid position and are not</span></span><br><span class="line">    <span class="comment">// awaiting reset, then we need to fetch committed offsets. We will only do a</span></span><br><span class="line">    <span class="comment">// coordinator lookup if there are partitions which have missing positions, so</span></span><br><span class="line">    <span class="comment">// a consumer with manually assigned partitions can avoid a coordinator dependence</span></span><br><span class="line">    <span class="comment">// by always ensuring that assigned partitions have an initial position.</span></span><br><span class="line">    <span class="keyword">if</span> (!coordinator.refreshCommittedOffsetsIfNeeded(timeoutMs)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are partitions still needing a position and a reset policy is defined,</span></span><br><span class="line">    <span class="comment">// request reset using the default policy. If no reset strategy is defined and there</span></span><br><span class="line">    <span class="comment">// are partitions with a missing position, then we will raise an exception.</span></span><br><span class="line">    subscriptions.resetMissingPositions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally send an asynchronous request to lookup and update the positions of any</span></span><br><span class="line">    <span class="comment">// partitions which are awaiting reset.</span></span><br><span class="line">    fetcher.resetOffsetsIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConsumerCoordinator-poll方法"><a href="#ConsumerCoordinator-poll方法" class="headerlink" title="ConsumerCoordinator#poll方法"></a>ConsumerCoordinator#poll方法</h2><p>ensureCoordinatorReady<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = time.milliseconds();</span><br><span class="line">    <span class="keyword">long</span> currentTime = startTime;</span><br><span class="line">    <span class="keyword">long</span> elapsed = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    invokeCompletedOffsetCommitCallbacks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否手动制定了TP，else情况不再看了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;</span><br><span class="line">        <span class="comment">// Always update the heartbeat last poll time so that the heartbeat thread does not leave the</span></span><br><span class="line">        <span class="comment">// group proactively due to application inactivity even if (say) the coordinator cannot be found.</span></span><br><span class="line">        <span class="comment">// 将消息拉取时间记为心跳线程最后一次拉取时间，那么说明是把消息拉取记为一次心跳</span></span><br><span class="line">        pollHeartbeat(currentTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// coordinator为null，连不上或者超时，触发ensureCoordinatorReady</span></span><br><span class="line">        <span class="keyword">if</span> (coordinatorUnknown()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ensureCoordinatorReady(remainingTimeAtLeastZero(timeoutMs, elapsed))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentTime = time.milliseconds();</span><br><span class="line">            <span class="comment">// elapsed 就是已用时间</span></span><br><span class="line">            elapsed = currentTime - startTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">            <span class="comment">// due to a race condition between the initial metadata fetch and the initial rebalance,</span></span><br><span class="line">            <span class="comment">// we need to ensure that the metadata is fresh before joining initially. This ensures</span></span><br><span class="line">            <span class="comment">// that we have matched the pattern against the cluster's topics at least once before joining.</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.hasPatternSubscription()) &#123;</span><br><span class="line">                <span class="comment">// For consumer group that uses pattern-based subscription, after a topic is created,</span></span><br><span class="line">                <span class="comment">// any consumer that discovers the topic after metadata refresh can trigger rebalance</span></span><br><span class="line">                <span class="comment">// across the entire consumer group. Multiple rebalances can be triggered after one topic</span></span><br><span class="line">                <span class="comment">// creation if consumers refresh metadata at vastly different times. We can significantly</span></span><br><span class="line">                <span class="comment">// reduce the number of rebalances caused by single topic creation by asking consumer to</span></span><br><span class="line">                <span class="comment">// refresh metadata before re-joining the group as long as the refresh backoff time has</span></span><br><span class="line">                <span class="comment">// passed.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.metadata.timeToAllowUpdate(currentTime) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!client.ensureFreshMetadata(remainingTimeAtLeastZero(timeoutMs, elapsed))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                currentTime = time.milliseconds();</span><br><span class="line">                elapsed = currentTime - startTime;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ensureActiveGroup(remainingTimeAtLeastZero(timeoutMs, elapsed))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTime = time.milliseconds();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    maybeAutoCommitOffsetsAsync(currentTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ensureCoordinatorReady源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ensureCoordinatorReady</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = time.milliseconds();</span><br><span class="line">    <span class="keyword">long</span> elapsedTime = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环直至coordinator可用</span></span><br><span class="line">    <span class="keyword">while</span> (coordinatorUnknown()) &#123;</span><br><span class="line">        <span class="comment">// 查找coordinator</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;Void&gt; future = lookupCoordinator();</span><br><span class="line">        <span class="comment">// 一直发生请求，直到future返回结果</span></span><br><span class="line">        client.poll(future, remainingTimeAtLeastZero(timeoutMs, elapsedTime));</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            <span class="comment">// ran out of time</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理失败</span></span><br><span class="line">        <span class="keyword">if</span> (future.failed()) &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">if</span> (future.isRetriable()) &#123;</span><br><span class="line">                elapsedTime = time.milliseconds() - startTimeMs;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (elapsedTime &gt;= timeoutMs) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                log.debug(<span class="string">"Coordinator discovery failed, refreshing metadata"</span>);</span><br><span class="line">                client.awaitMetadataUpdate(remainingTimeAtLeastZero(timeoutMs, elapsedTime));</span><br><span class="line">                elapsedTime = time.milliseconds() - startTimeMs;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> future.exception();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; client.isUnavailable(coordinator)) &#123;</span><br><span class="line">            <span class="comment">// we found the coordinator, but the connection has failed, so mark</span></span><br><span class="line">            <span class="comment">// it dead and backoff before retrying discovery</span></span><br><span class="line">            <span class="comment">// 发现coordinator连不上，标记Coordinator未知，断开连接，之后进行重试</span></span><br><span class="line">            markCoordinatorUnknown();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> sleepTime = Math.min(retryBackoffMs, remainingTimeAtLeastZero(timeoutMs, elapsedTime));</span><br><span class="line">            time.sleep(sleepTime);</span><br><span class="line">            elapsedTime += sleepTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !coordinatorUnknown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找Coordinator，初始化了AbstractCoordinator.this.coordinator变量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> RequestFuture&lt;Void&gt; <span class="title">lookupCoordinator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findCoordinatorFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// find a node to ask about the coordinator</span></span><br><span class="line">        <span class="comment">// 找到当前未完成的请求最少的node</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.client.leastLoadedNode();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> RequestFuture.noBrokersAvailable();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 向该node发送Coordinator查询请求</span></span><br><span class="line">            findCoordinatorFuture = sendFindCoordinatorRequest(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCoordinatorFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最小负载节点的计算"><a href="#最小负载节点的计算" class="headerlink" title="最小负载节点的计算"></a>最小负载节点的计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">leastLoadedNode</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">this</span>.metadataUpdater.fetchNodes();</span><br><span class="line">    <span class="keyword">int</span> inflight = Integer.MAX_VALUE;</span><br><span class="line">    Node found = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> offset = <span class="keyword">this</span>.randOffset.nextInt(nodes.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = (offset + i) % nodes.size();</span><br><span class="line">        Node node = nodes.get(idx);</span><br><span class="line">        <span class="keyword">int</span> currInflight = <span class="keyword">this</span>.inFlightRequests.count(node.idString());</span><br><span class="line">        <span class="comment">// 如果有一个node的Inflight为0，就是一个未处理的请求都没有，并且连接可用，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (currInflight == <span class="number">0</span> &amp;&amp; isReady(node, now)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.connectionStates.isBlackedOut(node.idString(), now) &amp;&amp; currInflight &lt; inflight) &#123;</span><br><span class="line">            <span class="comment">// 该node可用，并且当前未处理的请求小于inflight</span></span><br><span class="line">            <span class="comment">// 懒得写了，就是一个擂台法求最小值</span></span><br><span class="line">            <span class="comment">// otherwise if this is the best we have found so far, record that</span></span><br><span class="line">            inflight = currInflight;</span><br><span class="line">            found = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">"Removing node &#123;&#125; from least loaded node selection: is-blacked-out: &#123;&#125;, in-flight-requests: &#123;&#125;"</span>,</span><br><span class="line">                    node, <span class="keyword">this</span>.connectionStates.isBlackedOut(node.idString(), now), currInflight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Coordinator查询请求的处理"><a href="#Coordinator查询请求的处理" class="headerlink" title="Coordinator查询请求的处理"></a>Coordinator查询请求的处理</h3><p>sendFindCoordinatorRequest使用底层的NetWorkClient发送请求，这里主要看响应结果处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FindCoordinatorResponseHandler</span> <span class="keyword">extends</span> <span class="title">RequestFutureAdapter</span>&lt;<span class="title">ClientResponse</span>, <span class="title">Void</span>&gt; </span>&#123; <span class="comment">// 泛型表示handler的参数和返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"Received FindCoordinator response &#123;&#125;"</span>, resp);</span><br><span class="line">        clearFindCoordinatorFuture();</span><br><span class="line"></span><br><span class="line">        FindCoordinatorResponse findCoordinatorResponse = (FindCoordinatorResponse) resp.responseBody();</span><br><span class="line">        Errors error = findCoordinatorResponse.error();</span><br><span class="line">        <span class="comment">// 查询Coordinator响应结果处理</span></span><br><span class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// coordinatorConnectionId是计算出来的，而且是幂等的，感觉是个技巧性的代码</span></span><br><span class="line">                <span class="keyword">int</span> coordinatorConnectionId = Integer.MAX_VALUE - findCoordinatorResponse.node().id();</span><br><span class="line">                <span class="comment">// 初始化coordinator：connectionId，ip和端口</span></span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.coordinator = <span class="keyword">new</span> Node(</span><br><span class="line">                        coordinatorConnectionId,</span><br><span class="line">                        findCoordinatorResponse.node().host(),</span><br><span class="line">                        findCoordinatorResponse.node().port());</span><br><span class="line">                log.info(<span class="string">"Discovered group coordinator &#123;&#125;"</span>, coordinator);</span><br><span class="line">                <span class="comment">// 这里应该是向coordinator所在的机器的Acceptor发送OP_CONNECT请求了</span></span><br><span class="line">                client.tryConnect(coordinator);</span><br><span class="line">                <span class="comment">// 链接成功，相当于一次heartbeat</span></span><br><span class="line">                heartbeat.resetTimeouts(time.milliseconds());</span><br><span class="line">            &#125;</span><br><span class="line">            future.complete(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//清空引用，抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka源码环境搭建</title>
      <link href="/2019/10/29/kafka%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/10/29/kafka%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p>从<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">kafka官网</a>下载源码压缩包，以2.0.1版本为例，选择-src结尾的压缩包</p><p><img src="https://ae01.alicdn.com/kf/H210e4ddd7a6e484eb1187793e785a0c1w.png" alt="kafka 2.0.1"></p><h1 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h1><p>kafka采用gradle构建，根据kafka的git提交记录，采用4.10.3版本构建，如果本地有别的gradle版本，可以尝试用<a href="https://sdkman.io/" target="_blank" rel="noopener">sdkman</a>这款工具来管理，一个命令即可切换版本<br>kafka使用scala语言开发，需要安装2.12版本的scala，同样的sdkman也可以快速安装<br><img src="https://ae01.alicdn.com/kf/H2d59f09399574120b822f6d7c71729090.png" alt="提交日志"></p><h1 id="修改配置及日志文件"><a href="#修改配置及日志文件" class="headerlink" title="修改配置及日志文件"></a>修改配置及日志文件</h1><p>修改config/server.properties文件相关参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listeners=PLAINTEXT://localhost:9092</span><br><span class="line"># 设置自己的目录路径</span><br><span class="line">log.dirs=/Users/admin/app/other-kafka/kafka-2.0.1-src/logs</span><br><span class="line"># 如果本地有别的kafka集群，设置zk的chroot</span><br><span class="line">zookeeper.connect=localhost:2181/cluster_201</span><br></pre></td></tr></table></figure></p><p>将config目录下的log4j文件复制到src/main/resources目录下，resources目录自己新建即可<br><img src="https://ae01.alicdn.com/kf/H97695e5cf22d4509b660f785e19ac77dE.png" alt="移动log4j文件"></p><h1 id="导入IDEA"><a href="#导入IDEA" class="headerlink" title="导入IDEA"></a>导入IDEA</h1><p>解压后导入IDEA中，IDEA会自动开始构建，等待IDEA下载依赖</p><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>如果在编译的过程中出现以下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You can&apos;t map a property that does not exist: propertyName=testClassesDir</span><br></pre></td></tr></table></figure></p><p>调整build.gradle中的依赖版本为以下版本<br><img src="https://ae01.alicdn.com/kf/H86c22cdb3be04652b06db45350080181y.png" alt="调整版本"><br>然后继续等待IDEA编译，等待期间多祈祷能下载下来…</p><p>遇到下载超时的jar包，可以到maven中央仓库下载jar，通过命名手动安装</p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -DgroupId=org.scala-lang -DartifactId=scala-reflect -Dversion=2.10.6 -Dpackaging=jar -Dfile=/Users/admin/scala/scala-reflect-2.10.6.jar</span><br></pre></td></tr></table></figure></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>首先启动Zookeeper，成功构建之后，调整kafka的启动参数<br>注：建议将jvm堆内存设置小一点，kafka默认是1G，本机机器完全没有必要 -Xmx512m -Xms512m<br><img src="https://ae01.alicdn.com/kf/H43d9e3cc1fad40fdbdba654de897c442J.png" alt="启动参数"></p><p>启动成功之后控制台如下<br><img src="https://ae01.alicdn.com/kf/H0dccf862d1364893ac367dce5856bc72l.png" alt=""></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>向topic中发送消息之后，logs目录产生了日志文件<br><img src="https://ae01.alicdn.com/kf/Ha8852196a2bc47c993dd79367104e549v.png" alt="lgos目录"></p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka生产者源码浅析(三)</title>
      <link href="/2019/10/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%89)/"/>
      <url>/2019/10/28/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h1 id="Kafka生产者源码浅析-三"><a href="#Kafka生产者源码浅析-三" class="headerlink" title="Kafka生产者源码浅析(三)"></a>Kafka生产者源码浅析(三)</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在doSend方法中，最后几行代码是在消息添加进内存缓冲区之后，判断是否有可发送的消息，并唤醒了Sender线程<br>batchIsFull的判断依据有两个：deque.size() &gt; 1 || last.isFull()，意思是队列中至少有一个ProducerBatch已满，或者原来一个满的都没有，添加完这条消息就满了，两个条件满足其一就说明可以发送了<br>newBatchCreated表示新创建了一个ProducerBatch就发送，这里确实以前不知道<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">    log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</span><br><span class="line">    <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么sender线程又是如何发送的呢</p><p>猜想：</p><ol><li>先拿到缓冲区中待发送的所有消息，找到每个partitions leader所在的broker</li><li>然后按broker的地址分组</li><li>和broker建立连接，发送消息</li></ol><p>这样请求按broker分组合并，提升了效率，但是kafka有一个限定，同一个client对一个broker只能一个一个发请求，不能同时发送多个请求，这也是为了缓解broker端的压力<br>为了实现该方式，必然有个先进先出的请求队列，前一个请求拿到响应之后，才能出队，进行第二个请求</p><h2 id="sender发送消息"><a href="#sender发送消息" class="headerlink" title="sender发送消息"></a>sender发送消息</h2><p>Sender类实现了Runnable接口，那么主逻辑就应该在run方法中了，关于一些判断，事务先不用管，来到Sender重载的run(long)方法，其中的两行关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main run loop for the sender thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"Starting Kafka producer I/O thread."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main loop, runs until close is called</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            run(time.milliseconds());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Uncaught error in kafka producer I/O thread: "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略关闭后的处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入到run方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略事务相关代码 ....</span></span><br><span class="line">    <span class="keyword">long</span> pollTimeout = sendProducerData(now);</span><br><span class="line">    client.poll(pollTimeout, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendProducerData方法主要分以下三个步骤</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</span><br></pre></td></tr></table></figure><p>这行代码内部实现虽然有点复杂，但就一个作用，获取所有要发送分区的leader副本所在节点<br>然后就是对结果的处理及过滤, 不知道leader副本的topic交给metadata去更新，然后又根据NetworkClient过滤连接异常的节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if there are any partitions whose leaders are not known yet, force metadata update</span></span><br><span class="line"><span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// The set of topics with unknown leader contains topics with leader election pending as well as</span></span><br><span class="line">    <span class="comment">// topics which may have expired. Add the topic again to metadata to ensure it is included</span></span><br><span class="line">    <span class="comment">// and request metadata update, since there are messages to send to the topic.</span></span><br><span class="line">    <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">        <span class="keyword">this</span>.metadata.add(topic);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"Requesting metadata update due to unknown leader topics from the batched records: &#123;&#125;"</span>, result.unknownLeaderTopics);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove any nodes we aren't ready to send to</span></span><br><span class="line">Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line"><span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Node node = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">        notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.pollDelayMs(node, now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>主要根据缓冲区对象的drain方法，把所有分区消息，按照Node id分组</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速学习scala语言及常用语法汇总</title>
      <link href="/2019/10/27/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0scala%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2019/10/27/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0scala%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<blockquote><p>阅读kafka源码的一大障碍就是scala语言，本文的目的是罗列kakfa源码中涉及到的基础源码知识，一些不常用的东西不会涉及，同时我也会不断总结遇到的语法特性，因为极个别语法俺也不会！</p></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>和java一样，scala也需要sdk来运行程序，scala也是jvm语言，请事先保证本机上已安装java</p><h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><p>scala sdk的安装我强烈推荐sdkman(mac用户)，windows用户自己百度安装即可<br>sdk安装scala命令： sdk i scala 2.12.10</p><h2 id="ide"><a href="#ide" class="headerlink" title="ide"></a>ide</h2><p>ide依然选择idea，安装scala插件即可</p><h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><h2 id="启动类定义"><a href="#启动类定义" class="headerlink" title="启动类定义"></a>启动类定义</h2><p>main方法只能定义在object中，object中所有的方法和变量都是静态的</p><h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><p>一些小知识点提前说明</p><ol><li>scala中句尾不用写分号</li><li>scala中的Unit就是java中的void</li></ol><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>var是变量，val是常量，常量利于jvm的GC回收，因此kafka中几乎都是val</p><p>同时scala中变量是不要定义类型的，会进行自动推断<br>这种语法比较恶心的是方法调用后的返回值类型不能一眼看出，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val obj = fun()</span><br></pre></td></tr></table></figure></p><p>obj的类型通常要进入fun方法定义，看它的返回值</p><h2 id="if-else对变量赋值"><a href="#if-else对变量赋值" class="headerlink" title="if/else对变量赋值"></a>if/else对变量赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = if(size &gt; 0) true else false</span><br></pre></td></tr></table></figure><p>看到这里是不是感觉神清气爽，想想java里要如何实现这个功能，真是省了不少事</p><h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2><p>scala中打印时拼接字符串极为方便<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(s<span class="string">"request size is: $&#123;request.size&#125;"</span>)</span><br></pre></td></tr></table></figure></p><p>s开头，后面跟字符串，打印变量，用${}包裹即可，java中几乎没有比这种方法更好的，即使String.format也很丑陋，更不要说加号拼接了</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>首先记住一点，看见def就是方法定义，它的大概形式如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fun</span><span class="params">(参数名 :参数类型)</span> :返回值类型 </span>= &#123;</span><br><span class="line"><span class="comment">// 方法体...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>scala中的方法千变万化，但是都是以上形式，鉴于篇幅，本文只介绍kafka中常用的一些形式</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>scala中方法返回值不用写return，最后一行代码就是返回值，遇到if/else,case也不要慌，慢慢看即可</p><h4 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h4><p>java中的方法不能有多个返回值，一直是我很耿耿于怀的地方<br>假如要返回方法中的一个List对象和一个Map对象，只能定义一个对象来保存</p><p>而scala的多返回值完全没有这种麻烦，还可以自行指定要哪个返回值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fun</span><span class="params">()</span>:<span class="params">(Int, Int)</span> </span>= &#123;</span><br><span class="line">(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要fun方法的第一个返回值</span></span><br><span class="line">var result = fun()._1</span><br></pre></td></tr></table></figure></p><p>以上用法在kafka源码中也会见到</p><h3 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h3><p>scala中的方法有各种省略。只有一行代码可以省略{}，返回值类型用自动推断也可以省略。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def getSize = size</span><br></pre></td></tr></table></figure></p><h3 id="嵌套方法"><a href="#嵌套方法" class="headerlink" title="嵌套方法"></a>嵌套方法</h3><p>嵌套方法的意思是说方法里可以定义方法，常见的格式如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">handle</span><span class="params">()</span> :Unit </span>= &#123;</span><br><span class="line"><span class="function">def <span class="title">callback</span><span class="params">()</span> :Unit</span>=&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">read(args..., callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上例子是kafka中常见的一种用法：将回调方法先定义好，然后作为参数传给另一个方法<br>这种特性的好处也是显而易见的，配合函数传参使方法调用以及定义更优雅，想想java中要实现类似的功能，得要定义一个接口<br>坏处在于滥用该特性，嵌套多层或者定义太多嵌套方法，使代码阅读性变差</p><h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p>听上去高大上的一个名字，其实既简单又实用，kafka中常见的定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">inLock</span><span class="params">(lock :Lock)</span><span class="params">(fun :Any)</span></span>&#123;</span><br><span class="line">lock.lock()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fun</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是kafka中的一个加锁方法的大概源码，它是一个公共方法，作用是传入一个锁和一个方法对象，然后在方法执行前后加锁和释放锁，这有些类似java中aop的思想</p><h4 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h4><p>以上的柯里化函数调用方式在kafka源码中也采取了一定的简化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inLock(readLock) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到第二个参数的方法对象，直接用花括号</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>scala中的集合默认是不可变的，所以经常看到mutabl开头的初始化，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val map = mutable.HashMap[String, Integer]</span><br></pre></td></tr></table></figure><h2 id="Option与match…case"><a href="#Option与match…case" class="headerlink" title="Option与match…case"></a>Option与match…case</h2><p>kafka源码中充斥着大量的这种结果，Option和java中的Optional类似，都是为了避免空指针而引入的<br>在scala中Option有2个子类：Some和None，就是元素是否为空的2种类型</p><p>以下是从kafka源码中复制的一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">partition.getReplica(replicaId) match &#123;</span><br><span class="line"><span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(replica)</span> </span>=&gt;</span><br><span class="line">  partition.updateReplicaLogReadResult(replica, readResult)</span><br><span class="line"><span class="keyword">case</span> None =&gt;</span><br><span class="line">  updatedReadResult = readResult.withEmptyFetchInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释如下：</p><ol><li>partition.getReplica(replicaId)的返回值类型是Option[Replica]</li><li>match…case类似于java中的switch…case</li><li>Some(replica)中的replica变量名是可以随便起的<br>总的来说类似 if(replica != null) … else …</li></ol><h1 id="特殊语法汇总"><a href="#特殊语法汇总" class="headerlink" title="特殊语法汇总"></a>特殊语法汇总</h1><p>scala中求多个集合的并集，有3个List集合，list1，list2，list3<br>val all = list1 ++ list2 ++ list3</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ElasticSearch7.2 实现数据自动冷热分离</title>
      <link href="/2019/10/25/ElasticSearch7-2-Hot-warm%E4%B8%8Erollover-API%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%87%AA%E5%8A%A8%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/"/>
      <url>/2019/10/25/ElasticSearch7-2-Hot-warm%E4%B8%8Erollover-API%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%87%AA%E5%8A%A8%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/</url>
      <content type="html"><![CDATA[<h1 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h1><p>在基于时序数据中，我们总是关心最近产生的数据，例如查询订单通常只会查询最近三天，至多到最近一个月的，查询日志也是同样的情形，很少会去查询历史数据，也就是说类似的时序数据随着时间推移，价值在逐渐弱化。在es中经常按日或按月建立索引，我们很容易想到，历史索引被查询命中的概率越来越低，不应该占用高性能的机器资源(比如大内存，SSD)，可以将其迁移到低配置的机器上，从而实现冷热数据分离存储。</p><h1 id="分片分配规则-shard-allocation-filtering"><a href="#分片分配规则-shard-allocation-filtering" class="headerlink" title="分片分配规则(shard allocation filtering)"></a>分片分配规则(shard allocation filtering)</h1><p>假设我们有三个es节点，一台高性能机器(hot)和2个低配置机器(warm)，通常索引分片会均匀分布在集群节点中，但我们希望最新的数据由于其写入和查询频繁的特性，只能保存在hot节点上，而过期的数据保存在warm节点上。<br>实现该功能，首先要对节点人为的打个标签，然后在索引创建时指定要把分片分配给hot节点，在索引不再写入后，迁移到warm节点上</p><h2 id="节点tag"><a href="#节点tag" class="headerlink" title="节点tag"></a>节点tag</h2><p>依次启动三个节点，同时加入box_type和resource_level标签，box_type标记node1、node2为warm节点，node3为hot节点，resource_level标记机器资源的性能，分为高，中，低<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -d -p pid -E node.name=node1 -E node.max_local_storage_nodes=3 -E path.data=node1_data -E path.logs=node1_logs -E node.attr.box_type=warm -E node.attr.resource_level=high</span><br><span class="line"></span><br><span class="line">bin/elasticsearch -d -p pid -E node.name=node2 -E node.max_local_storage_nodes=3 -E path.data=node2_data -E path.logs=node2_logs -E node.attr.box_type=warm -E node.attr.resource_level=mdeium</span><br><span class="line"></span><br><span class="line">bin/elasticsearch -d -p pid -E node.name=node3 -E node.max_local_storage_nodes=3 -E path.data=node3_data -E path.logs=node3_logs -E node.attr.box_type=hot -E node.attr.resource_level=high</span><br></pre></td></tr></table></figure></p><h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><p>kibana中输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/indices?v</span><br></pre></td></tr></table></figure></p><p>得到以下结果，可以看到box_type和resource_level标签在每个节点的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node  host      ip        attr              value</span><br><span class="line">node3 127.0.0.1 127.0.0.1 ml.machine_memory 17179869184</span><br><span class="line">node3 127.0.0.1 127.0.0.1 ml.max_open_jobs  20</span><br><span class="line">node3 127.0.0.1 127.0.0.1 box_type          hot</span><br><span class="line">node3 127.0.0.1 127.0.0.1 xpack.installed   true</span><br><span class="line">node3 127.0.0.1 127.0.0.1 resource_level    high</span><br><span class="line">node1 127.0.0.1 127.0.0.1 ml.machine_memory 17179869184</span><br><span class="line">node1 127.0.0.1 127.0.0.1 box_type          warm</span><br><span class="line">node1 127.0.0.1 127.0.0.1 xpack.installed   true</span><br><span class="line">node1 127.0.0.1 127.0.0.1 ml.max_open_jobs  20</span><br><span class="line">node1 127.0.0.1 127.0.0.1 resource_level    high</span><br><span class="line">node2 127.0.0.1 127.0.0.1 ml.machine_memory 17179869184</span><br><span class="line">node2 127.0.0.1 127.0.0.1 ml.max_open_jobs  20</span><br><span class="line">node2 127.0.0.1 127.0.0.1 box_type          warm</span><br><span class="line">node2 127.0.0.1 127.0.0.1 xpack.installed   true</span><br><span class="line">node2 127.0.0.1 127.0.0.1 resource_level    mdeium</span><br></pre></td></tr></table></figure></p><h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p>假设当前时间为2019年9月1日，作为最新的数据存储在hot节点上，只需要在建立索引时指定allocation策略即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT api_log_2019-09-01</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 3, </span><br><span class="line">    &quot;number_of_replicas&quot;: 0, </span><br><span class="line">    &quot;index.routing.allocation.require.box_type&quot;: &quot;hot&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="index-routing-allocation详解"><a href="#index-routing-allocation详解" class="headerlink" title="index.routing.allocation详解"></a>index.routing.allocation详解</h3><p>该配置支持include，require，exclude三种选项，它们的值都可以是多个，用逗号分隔<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index.routing.allocation.include.&#123;attribute&#125;：将索引分配给具有至少一个值的节点。</span><br><span class="line">index.routing.allocation.require.&#123;attribute&#125;：将索引分配给具有所有值的节点。</span><br><span class="line">index.routing.allocation.exclude.&#123;attribute&#125;：将索引分配给没有该值的节点</span><br></pre></td></tr></table></figure></p><p>es还提供了以下内置字段</p><ul><li>_name： 节点名称匹配</li><li>_host_ip：主机名ip地址匹配</li><li>_publish_ip：publish ip匹配，参考network.publish_host配置</li><li>_ip：_host_ip或者_publish_ip匹配</li><li>_host：主机名匹配</li></ul><p>假设建立索引时没有配置该选项也不要紧，动态修改即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT api_log_2019-09-01/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index.routing.allocation.require.box_type&quot;: &quot;hot&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="迁移索引"><a href="#迁移索引" class="headerlink" title="迁移索引"></a>迁移索引</h2><p>迁移历史索引到warm节点的方式也是采用动态修改请求的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT api_log_2019-09-01/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index.routing.allocation.require.box_type&quot;: &quot;warm&quot;,</span><br><span class="line">    &quot;index.routing.allocation.include.resource_level&quot;: &quot;mdeium&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将api_log_2019-09-01迁移到了box_type为warm，resource_level为mdeium的节点，即node2<br>通过查询索引分片的分布情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/shards/api_log_2019-09-01?v</span><br></pre></td></tr></table></figure></p><p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index          shard prirep state   docs store ip        node</span><br><span class="line">api_log_2019-09-01 1     p      STARTED 4711 4.1mb 127.0.0.1 node2</span><br><span class="line">api_log_2019-09-01 2     p      STARTED 4656   4mb 127.0.0.1 node2</span><br><span class="line">api_log_2019-09-01 0     p      STARTED 4707 4.1mb 127.0.0.1 node2</span><br></pre></td></tr></table></figure></p><h1 id="Rollover-API"><a href="#Rollover-API" class="headerlink" title="Rollover API"></a>Rollover API</h1><p>大家应该也注意到了，迁移索引的步骤是手动完成的，有没有更智能的方式呢，答案是肯定的，rollover API可以很好地实现这个功能</p><h2 id="rollover"><a href="#rollover" class="headerlink" title="rollover"></a>rollover</h2><p>首先为索引建立别名, 由于多个index可以对应一个alias，为了让es知道往哪个索引中写，标记其中一个索引is_write_index为true<br>同时需要注意索引名以横杠+数字结尾的形式命名，这是为了让es自动生成索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST _aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;remove&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;api_log_2019-09-01&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;api_logs&quot;,</span><br><span class="line">        &quot;is_write_index&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>rollover API会根据设置的条件(conditions)来生成新的索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST api_logs/_rollover</span><br><span class="line">&#123;</span><br><span class="line">  &quot;conditions&quot;: &#123;</span><br><span class="line">    &quot;max_age&quot;: &quot;1d&quot;,</span><br><span class="line">    &quot;max_docs&quot;: 10000,</span><br><span class="line">    &quot;max_size&quot;: &quot;5gb&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>conditions的详细解释：</p><ul><li>max_age：索引是否创建大于1天</li><li>max_docs：索引文档数是否超过10000</li><li>max_size：索引大小是否超过5GB<br>max_size正在进行中的合并会产生大量的临时分片大小增长，而当合并结束后这些增长会消失掉，不稳定，max_age每个时间内不一定均衡，max_docs比较合适<br>即以上三个条件满足其一就会自动rollover</li></ul><h3 id="新索引配置"><a href="#新索引配置" class="headerlink" title="新索引配置"></a>新索引配置</h3><p>rollover也支持索引的settings设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST api_logs/_rollover</span><br><span class="line">&#123;</span><br><span class="line">  &quot;conditions&quot;: &#123;</span><br><span class="line">    &quot;max_age&quot;: &quot;1d&quot;,</span><br><span class="line">    &quot;max_docs&quot;: 10000,</span><br><span class="line">    &quot;max_size&quot;: &quot;5gb&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;index.number_of_shards&quot;: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义索引名称"><a href="#自定义索引名称" class="headerlink" title="自定义索引名称"></a>自定义索引名称</h3><p>生成的索引名称为api_log_2019-09-000002, 以长度为6，序号+1，左填充0的格式命名，但es支持自定义名称，只需要在_rollover端点加入名称即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST api_logs/_rollover/api_log_2019-09-02</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>shard allocation filtering赋予了索引选择节点的能力，但在迁移过程中需要手动触发，因此rollover API应运而生，它可以在索引满足一定的条件下自动迁移索引到warm节点，index lifecycle management从更高的角度定义了索引的声明周期，把每个节点定义为一个phase，在每个阶段要做的事定义为action，这个action可以让我们对索引rollover，delete等，这一系列的功能，都是为了更智能的管理时序数据，典型的场景就是每天产生的日志</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/getting-started-index-lifecycle-management.html#ilm-gs-apply-policy" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/getting-started-index-lifecycle-management.html#ilm-gs-apply-policy</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/indices-rollover-index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/indices-rollover-index.html</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/shard-allocation-filtering.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/shard-allocation-filtering.html</a><br><a href="https://www.elastic.co/cn/blog/managing-time-based-indices-efficiently" target="_blank" rel="noopener">https://www.elastic.co/cn/blog/managing-time-based-indices-efficiently</a><br><a href="https://juejin.im/post/5a990cdbf265da239b40de65" target="_blank" rel="noopener">https://juejin.im/post/5a990cdbf265da239b40de65</a></p>]]></content>
      
      <categories>
          
          <category> ELK Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> X-pack </tag>
            
            <tag> kibana </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka生产者源码浅析(二)</title>
      <link href="/2019/10/16/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%BA%8C)/"/>
      <url>/2019/10/16/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h1 id="Kafka生产者源码浅析-二"><a href="#Kafka生产者源码浅析-二" class="headerlink" title="Kafka生产者源码浅析(二)"></a>Kafka生产者源码浅析(二)</h1><blockquote><p>上篇文章中对Spring-kafka源码做了追踪，也对原生的KafkaProducer做了部分解析，对关键类事先说明，帮助读者理解源码，克服对源码的恐惧心理</p></blockquote><p>doSend的方法很长，我们分部拆解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码，catch处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">    TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        throwIfProducerClosed();</span><br><span class="line">        <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">        ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">        clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">        <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">        Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] serializedKey;</span><br><span class="line">        serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">byte</span>[] serializedValue;</span><br><span class="line">        serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">        tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line"></span><br><span class="line">        setReadOnly(record.headers());</span><br><span class="line">        Header[] headers = record.headers().toArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">        ensureValidRecordSize(serializedSize);</span><br><span class="line">        <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">        Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional())</span><br><span class="line">            transactionManager.maybeAddPartitionToTransaction(tp);</span><br><span class="line"></span><br><span class="line">        RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line">        <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Part-one"><a href="#Part-one" class="headerlink" title="Part one"></a>Part one</h2><p>首先吐槽下这个tp变量，定义在外边没什么卵用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    throwIfProducerClosed();</span><br><span class="line">    <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">    ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">    clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">    <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">    Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>throwIfProducerClosed做的很简单，看看Sender线程是否活着</p></li><li><p>waitOnMetadata返回一个ClusterAndWaitTime对象，里面是broker集群的元信息和获取信息的耗时，这个耗时算在了max.block.ms中，它控制这send方法的最大执行时间</p></li><li><p>waitOnMetadata通过唤醒sender线程，依靠NetworkClient.poll()方法来更新元数据</p></li></ol><p>Cluster 类信息如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBootstrapConfigured;</span><br><span class="line">    <span class="comment">// 所有的broker节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Node&gt; nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; unauthorizedTopics;</span><br><span class="line">    <span class="comment">// 内部topic，如_consumer_offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; internalTopics;</span><br><span class="line">    <span class="comment">// controller节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node controller;</span><br><span class="line">    <span class="comment">// 每个分区对应的分区信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TopicPartition, PartitionInfo&gt; partitionsByTopicPartition;</span><br><span class="line">    <span class="comment">// 每个topic所有分区的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic;</span><br><span class="line">    <span class="comment">// topic所有可用分区的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;PartitionInfo&gt;&gt; availablePartitionsByTopic;</span><br><span class="line">    <span class="comment">// 每个broker节点的所有分区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, List&lt;PartitionInfo&gt;&gt; partitionsByNode;</span><br><span class="line">    <span class="comment">// 按照nodeId组成map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; nodesById;</span><br><span class="line">    <span class="comment">// 里面只有一个clusterId熟悉</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResource clusterResource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体是如何初始化的，可以看一下Cluster构造函数的源码</p><p>上面出现的PartitionInfo, 这些信息想必大家已经很熟悉<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;</span><br><span class="line">    <span class="comment">// leader分区所在broker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node leader;</span><br><span class="line">    <span class="comment">// 副本所在broker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] replicas;</span><br><span class="line">    <span class="comment">// ISR副本所在broker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] inSyncReplicas;</span><br><span class="line">    <span class="comment">// 离线副本所在broker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] offlineReplicas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Part-two"><a href="#Part-two" class="headerlink" title="Part two"></a>Part two</h2><p>这一部分比较简单，对key和value序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] serializedKey;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">   <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] serializedValue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>接下来关注kafka是如何根据key为消息计算分区的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br></pre></td></tr></table></figure><p>第二行代码是将topic和分区包装成一个TopicPartition类，重点关注第一行代码</p><p>partition方法会尝试获取消息中的partition，如果用户指定了分区，此时就不用计算了，否则使用partitioner计算分区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="keyword">byte</span>[] serializedKey, <span class="keyword">byte</span>[] serializedValue, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    Integer partition = record.partition();</span><br><span class="line">    <span class="keyword">return</span> partition != <span class="keyword">null</span> ?</span><br><span class="line">            partition :</span><br><span class="line">            partitioner.partition(</span><br><span class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultPartitioner"><a href="#DefaultPartitioner" class="headerlink" title="DefaultPartitioner"></a>DefaultPartitioner</h4><p>partitioner.partition的具体实现在DefaultPartitioner#partition，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾前文，Cluster封装了broker的很多信息，其中就用一个Map封装了topic的partition信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic</span><br></pre></td></tr></table></figure><p>此时要分区，首先要获取这个topic的PartitionInfo，第一行代码的作用就是这个，map.get(topic)，很简单</p><p>接下分两种情况：用户指定了key，和未指定key，我们知道旧版本的kafka在用户未指定key的情况下会默认将消息分配到某一个分区，<br>但这样会造成数据倾斜，官方后来对此作了优化，采用轮询(round-robin)的方式，简单提一下这块的代码</p><h4 id="随机分配"><a href="#随机分配" class="headerlink" title="随机分配"></a>随机分配</h4><p>kafka会初始化一个很大的伪随机数放在AtomicInteger中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextValue</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">    AtomicInteger counter = topicCounterMap.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == counter) &#123;</span><br><span class="line">        counter = <span class="keyword">new</span> AtomicInteger(ThreadLocalRandom.current().nextInt());</span><br><span class="line">        AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);</span><br><span class="line">        <span class="keyword">if</span> (currentCounter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            counter = currentCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以topic为key保存在一个ConcurrentHashMap中，每次用完counter自增并返回，这就是nextValue方法的作用</p><p>接下来从Cluster中获取可用的分区信息，获取分区数，使用counter对其取模，然后从可用分区列表中获取一个分区，由于counter的自增，达到了轮询(round-robin)的效果。但如果没有可用的分区，则从所有分区中挑选(有种破罐子破摔的味道)</p><p>Utils.toPositive用于取绝对值，kafka选择了一个cheap way: 与运算</p><p>以上是对消息中没有key的情况下如何分配分区的分析，至于有key的情况就比较简单了：对key做<a href="https://sites.google.com/site/murmurhash/" target="_blank" rel="noopener">murmur2 hash</a>运算，然后对分区数取模</p><h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><p>实现Partitioner接口即可，配置方式参考拦截器，二者同理，参数名称为: partitioner.class</p><h2 id="Part-three"><a href="#Part-three" class="headerlink" title="Part three"></a>Part three</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setReadOnly(record.headers());</span><br><span class="line">Header[] headers = record.headers().toArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                    compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">ensureValidRecordSize(serializedSize);</span><br><span class="line"><span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">log.trace(<span class="string">"Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;"</span>, record, callback, record.topic(), partition);</span><br><span class="line">Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br></pre></td></tr></table></figure><p>先把不重要的说了，这几行代码的可读性很好，设置消息头只读，然后<strong>估算</strong>消息的总大小，确保不会超出max.request.size和buffer.memory的大小，获取消息的时间戳，用户指定的优先，最后构建一个InterceptorCallback回调对象，它会先指定拦截器的onAcknowledgement回调，然后执行用户指定的Callback#onCompletion</p><h3 id="追加至缓存并发送"><a href="#追加至缓存并发送" class="headerlink" title="追加至缓存并发送"></a>追加至缓存并发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line"><span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">    log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</span><br><span class="line">    <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.future;</span><br></pre></td></tr></table></figure><p>首先思考下缓存区的数据结构是什么：它应该有个先来后到的顺序，即先进先出(FIFO)，用一个队列实现即可，而kafka真正使用的是一个双端队列</p><p>RecordAccumulator为topic的每一个分区都创建了一个ArrayDeque(thread unsafe)，里面存放的元素是ProducerBatch，它就是待批量发送的消息。<br>kafka使用一个CopyOnWriteMap保存分区和队列的关系，即只有在修改该map时把内容Copy出去形成一个新的map，然后配合volatile改变引用，这也是COW机制的常见用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches = <span class="keyword">new</span> CopyOnWriteMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>该map的模型如下<br><img src="https://ae01.alicdn.com/kf/H409e050f5b184f7ebad5ecc5f12d9e41V.png" alt="模型"></p><p>append方法返回一个RecordAppendResult，它是消息在添加进内存缓冲区后的结果：Deque队列中是否有元素，是否有新的ProducerBatch创建，两个条件都可以去通知sender线程发送消息</p><p>完整的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Header[] headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// We keep track of the number of appending thread to make sure we do not miss batches in</span></span><br><span class="line">    <span class="comment">// abortIncompleteBatches().</span></span><br><span class="line">    appendsInProgress.incrementAndGet();</span><br><span class="line">    ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (headers == <span class="keyword">null</span>) headers = Record.EMPTY_HEADERS;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check if we have an in-progress batch</span></span><br><span class="line">        Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we don't have an in-progress record batch try to allocate a new batch</span></span><br><span class="line">        <span class="keyword">byte</span> maxUsableMagic = apiVersions.maxUsableProduceMagic();</span><br><span class="line">        <span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));</span><br><span class="line">        log.trace(<span class="string">"Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;"</span>, size, tp.topic(), tp.partition());</span><br><span class="line">        buffer = free.allocate(size, maxTimeToBlock);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="comment">// Need to check if producer is closed again after grabbing the dequeue lock.</span></span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line"></span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 万一这个时候又有了可用的ProducerBatch呢，我们就不用新建了呀，唉~这就很舒服</span></span><br><span class="line">                <span class="comment">// Somebody else found us a batch, return the one we waited for! Hopefully this doesn't happen often...</span></span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">            ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">            FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">            dq.addLast(batch);</span><br><span class="line">            incomplete.add(batch);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't deallocate this buffer in the finally block as it's being used in the record batch</span></span><br><span class="line">            buffer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer != <span class="keyword">null</span>)</span><br><span class="line">            free.deallocate(buffer);</span><br><span class="line">        appendsInProgress.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码看似很多，其实并不难，我们还是逐步分析下</p><h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the deque for the given topic-partition, creating it if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Deque&lt;ProducerBatch&gt; <span class="title">getOrCreateDeque</span><span class="params">(TopicPartition tp)</span> </span>&#123;</span><br><span class="line">    Deque&lt;ProducerBatch&gt; d = <span class="keyword">this</span>.batches.get(tp);</span><br><span class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    d = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Deque&lt;ProducerBatch&gt; previous = <span class="keyword">this</span>.batches.putIfAbsent(tp, d);</span><br><span class="line">    <span class="keyword">if</span> (previous == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches</code>中获取该主题分区对应的队列,如果不为空说明已经有了，直接返回，否者创建一个新的ArrayDeque，并放到map中，方便下次使用，<br>至于putIfAbsent方法，就是map中之前没有这个key，插入并返回新value，已经有了，就返回之前的value，即Deque</p><p>然后就是一行很久我没看懂的代码，细心的同学可能发现了，tryAppend方法一共出现了2次，但不要和batch.tryAppend()方法搞混<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line">    RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">    <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendResult;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>先看看tryAppend方法源码, 然后appendResult为null真正想表达的意思是队列里没有ProducerBatch，得先创建一个，如果不为null，就说明队列里有并且添加消息成功了，直接返回</p><h4 id="RecordAccumulator-tryAppend方法源码："><a href="#RecordAccumulator-tryAppend方法源码：" class="headerlink" title="RecordAccumulator#tryAppend方法源码："></a>RecordAccumulator#tryAppend方法源码：</h4><p>其实文档写的很清楚了，就是把消息追加到最后一个ProducerBatch中，但要是队列中一个都没有呢？ 很简单，直接返回null，在外层方法中会判断不为null在结束，否则会分配<br>吐槽下：一开始就看岔了，好几个tryAppend，如果是我，我会写成tryAppendInternal之类的方法名<br>RecordAppendResult构造方法的最后一个参数表示是否是新建的ProducerBatch，这里返回时也确实返回了false<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Try to append to a ProducerBatch.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  If it is full, we return null and a new batch is created. We also close the batch for record appends to free up</span></span><br><span class="line"><span class="comment"> *  resources like compression buffers. The batch will be fully closed (ie. the record batch headers will be written</span></span><br><span class="line"><span class="comment"> *  and memory records built) in one of the following cases (whichever comes first): right before send,</span></span><br><span class="line"><span class="comment"> *  if it is expired, or when the producer is closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RecordAppendResult <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Callback callback, Deque&lt;ProducerBatch&gt; deque)</span> </span>&#123;</span><br><span class="line">    ProducerBatch last = deque.peekLast();</span><br><span class="line">    <span class="keyword">if</span> (last != <span class="keyword">null</span>) &#123;</span><br><span class="line">        FutureRecordMetadata future = last.tryAppend(timestamp, key, value, headers, callback, time.milliseconds());</span><br><span class="line">        <span class="keyword">if</span> (future == <span class="keyword">null</span>)</span><br><span class="line">            last.closeForRecordAppends();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, deque.size() &gt; <span class="number">1</span> || last.isFull(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建新的ProducerBatch并发送"><a href="#创建新的ProducerBatch并发送" class="headerlink" title="创建新的ProducerBatch并发送"></a>创建新的ProducerBatch并发送</h4><p>然后又出现了一次tryAppend，注释写道：<br>Need to check if producer is closed again after grabbing the dequeue lock<br>我暂时没看懂意图，大概意思是在极端情况下，检查线程在获取到dequeue锁之后，producer又关闭</p><p>接下来的代码就很清晰了，新建一个ProducerBatch，然后追加消息，然后添加到队列尾部，而incomplete对象就是个Set<producerbatch>, 用来保存还没有发送完成的，包括还没发送的<br>最后释放buffer资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">dq.addLast(batch);</span><br><span class="line">incomplete.add(batch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't deallocate this buffer in the finally block as it's being used in the record batch</span></span><br><span class="line">buffer = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></producerbatch></p><p>ProducerBatch的写入主要由MemoryRecordsBuilder完成，底层写入到DataOutputStream appendStream流对象, 也就是nio的ByteBuffer中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Long checksum = <span class="keyword">this</span>.recordsBuilder.append(timestamp, key, value, headers);</span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(),</span><br><span class="line">                recordsBuilder.compressionType(), key, value, headers));</span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;</span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                               timestamp, checksum,</span><br><span class="line">                                                               key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                               value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length);</span><br><span class="line">        <span class="comment">// we have to keep every future returned to the users in case the batch needs to be</span></span><br><span class="line">        <span class="comment">// split to several new batches and resent.</span></span><br><span class="line">        thunks.add(<span class="keyword">new</span> Thunk(callback, future));</span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>append方法的具体实现过程还是很复杂的，这里说下笔者对这个过程的理解：</p><ol><li>尝试获取该TopicPartition下的队列，如果没有则创建</li><li>获取队列的最后一个ProducerBatch元素，将消息添加至该ProducerBatch，该过程会对Deque加锁</li><li>如果队列里没有ProducerBatch，或是最后一个ProducerBatch已经满了，就需要新建一个ProducerBatch</li><li>分配一个ByteBuffer空间，该空间大小在batch.size和消息大小中取较大值</li><li>再重新尝试步骤2一次，万一这时候刚好又有了呢(这时候Deque已经释放锁了)</li><li>创建好ProducerBatch之后，继续尝试append，添加成功之后将future和callback放入一个Thunk对象中，并且添加到一个List<thunk>集合，这是因为一批消息需要发送之后才有回调，所以先把回调统一放入一个集合中</thunk></li><li>添加成功之后，返回future对象，将ProducerBatch添加至Deque队列，同时用一个集合IncompleteBatches持有住了ProducerBatch</li><li>清理buffer空间，封装RecordAppendResult结果：Deque队列大小，新建的ProducerBatch对象是否已满</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kafka发送消息的步骤大致如下：</p><ol><li>更新broker上的元信息</li><li>key, value的序列化</li><li>计算分区</li><li>添加到缓存区<ol><li>获取该分区对应的队列</li><li>尝试添加</li><li>如果添加成功返回</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka生产者源码浅析(一)</title>
      <link href="/2019/10/16/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%80)/"/>
      <url>/2019/10/16/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h1 id="Kafka生产者源码浅析-一"><a href="#Kafka生产者源码浅析-一" class="headerlink" title="Kafka生产者源码浅析(一)"></a>Kafka生产者源码浅析(一)</h1><blockquote><p>本文并没有直接使用原生的kafka-client，而是spring-kafka，版本为2.2.3.RELEASE。在当前以Spring-boot为首的潮流中，有必要学习Spring是如何集成kafka客户端的</p></blockquote><h1 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h1><p>以KafkaTemplate#send方法为入口，使用debug方式跟进源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, K key, <span class="meta">@Nullable</span> V data) &#123;</span><br><span class="line">  ProducerRecord&lt;K, V&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, key, data);</span><br><span class="line">  <span class="keyword">return</span> doSend(producerRecord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将消息封装为ProducerRecord对象，这是kafka-client原生对象，接下来进行发送操作<br>在doSend方法中，有很多事务相关，日志相关的代码，我们的目的是理清楚主流程，因此省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码 ... </span></span><br><span class="line"><span class="keyword">protected</span> ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; doSend(<span class="keyword">final</span> ProducerRecord&lt;K, V&gt; producerRecord) &#123;</span><br><span class="line">  <span class="keyword">final</span> Producer&lt;K, V&gt; producer = getTheProducer();</span><br><span class="line">  <span class="keyword">final</span> SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future = <span class="keyword">new</span> SettableListenableFuture&lt;&gt;();</span><br><span class="line">  producer.send(producerRecord, buildCallback(producerRecord, producer, future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先通过getTheProducer获取生产者对象，那么Spring-kafka是如何创建该对象的呢？</p><h2 id="构建生产者"><a href="#构建生产者" class="headerlink" title="构建生产者"></a>构建生产者</h2><p>代码只有一行，通过DefaultKafkaProducerFactory创建生产者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Producer&lt;K, V&gt; <span class="title">getTheProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码 ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.producerFactory.createProducer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入到DefaultKafkaProducerFactory#createProducer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Producer&lt;K, V&gt; <span class="title">createProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.producer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.producer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.producer = <span class="keyword">new</span> CloseSafeProducer&lt;K, V&gt;(createKafkaProducer());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道kafka生产者是单例并且线程安全的，这里spring使用double-check构建了一个CloseSafeProducer对象，而它被volatile修饰，经典的懒汉单例模式<br>平常我们使用的都是KafkaProducer，这个CloseSafeProducer又是什么呢？<br>该类实现了Producer接口，这也是KafkaProducer的父接口，细心的同学发现了CloseSafeProducer在创建是调用了createKafkaProducer方法，该方法源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Producer&lt;K, V&gt; <span class="title">createKafkaProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> KafkaProducer&lt;K, V&gt;(<span class="keyword">this</span>.configs, <span class="keyword">this</span>.keySerializer, <span class="keyword">this</span>.valueSerializer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坑爹呢这是，这个不还是KafkaProducer对象吗，那么传入一个KafkaProducer是要干吗，对装饰者模式和代理模式熟悉的同学已经明白是怎么回事，spring也确实这样做的：具体功能实现都委托给KafkaProducer对象实现，spring对记录事务id等日志信息做了增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseSafeProducer</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Producer</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Producer&lt;K, V&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;CloseSafeProducer&lt;K, V&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;CloseSafeProducer&lt;K, V&gt;&gt; removeConsumerProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String txId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> txFailed;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>CloseSafeProducer的分析至此结束，在获取到包装后的KafkaProducer后，便是发送流程了</p><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>回到doSend方法，发送的代码只有两行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码...</span></span><br><span class="line"><span class="keyword">protected</span> ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; doSend(<span class="keyword">final</span> ProducerRecord&lt;K, V&gt; producerRecord) &#123;</span><br><span class="line">  <span class="keyword">final</span> Producer&lt;K, V&gt; producer = getTheProducer();</span><br><span class="line">  <span class="keyword">final</span> SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future = <span class="keyword">new</span> SettableListenableFuture&lt;&gt;();</span><br><span class="line">  producer.send(producerRecord, buildCallback(producerRecord, producer, future));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.autoFlush) &#123;</span><br><span class="line">    flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略部分代码...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Callback <span class="title">buildCallback</span><span class="params">(<span class="keyword">final</span> ProducerRecord&lt;K, V&gt; producerRecord, <span class="keyword">final</span> Producer&lt;K, V&gt; producer,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (metadata, exception) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">        future.set(<span class="keyword">new</span> SendResult&lt;&gt;(producerRecord, metadata));</span><br><span class="line">        <span class="keyword">if</span> (KafkaTemplate.<span class="keyword">this</span>.producerListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">          KafkaTemplate.<span class="keyword">this</span>.producerListener.onSuccess(producerRecord, metadata);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        future.setException(<span class="keyword">new</span> KafkaProducerException(producerRecord, <span class="string">"Failed to send"</span>, exception));</span><br><span class="line">        <span class="keyword">if</span> (KafkaTemplate.<span class="keyword">this</span>.producerListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// producerListener 默认是LoggingProducerListener，仅在错误是打印日志</span></span><br><span class="line">          KafkaTemplate.<span class="keyword">this</span>.producerListener.onError(producerRecord, exception);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!KafkaTemplate.<span class="keyword">this</span>.transactional) &#123;</span><br><span class="line">        closeProducer(producer, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SettableListenableFuture是一个可设置，可监听的Future对象，用它构建异步发送消息后的Callback对象，大家可以认为Spring使用SettableListenableFuture对象对返回结果和异常进行了封装，Callback的作用在下文揭晓。</p><p>ListenableFuture同样的也可以添加回调函数,使用方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture future = kafkaTemplate.send(record);</span><br><span class="line">future.addCallback(result -&gt; &#123;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;, error-&gt;&#123;</span><br><span class="line">    System.out.println(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>接着send方法由CloseSafeProducer委托给KafkaProducer执行，KafkaProducer的send方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);</span><br><span class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProducerInterceptor通过for循环遍历依次执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProducerRecord&lt;K, V&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span> </span>&#123;</span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptRecord = record;</span><br><span class="line">    <span class="keyword">for</span> (ProducerInterceptor&lt;K, V&gt; interceptor : <span class="keyword">this</span>.interceptors) &#123;</span><br><span class="line">      interceptRecord = interceptor.onSend(interceptRecord);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interceptRecord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>send方法的官方文档翻译如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">异步发送一条消息到一个topic，并且在应答之后立即调用已提供的回调</span><br><span class="line">发送是异步的，一旦消息存储到了等待发送的缓冲区，该方法会立即返回。这样就不用阻塞在等待每一次发送消息的响应，允许并行的发送大量消息。</span><br><span class="line">发送后的结果对象RecordMetadata具体说明了消息被发送到了哪个分区，被分配的位移和时间戳。</span><br><span class="line">如果topic使用了TimestampType#CREATE_TIME，那么使用用户指定的时间，如果未指定，则使用发送时间。</span><br><span class="line">如果使用了TimestampType#LOG_APPEND_TIME，则使用消息在broker端追加到日志的时间</span><br><span class="line">send方法会为RecordMetadata对象返回一个Future对象，调用Future#get将会阻塞到请求完成，返回消息的元数据，或者返回在发送请求期间的任何异常</span><br><span class="line">如果你想模拟一下，你可以send之后立即调用get</span><br><span class="line">producer.send(record).get()</span><br><span class="line">完全非阻塞的用法是用Callback参数来提供一个回调，它将在请求结束之后被调用</span><br><span class="line">producer.send(myRecord, <span class="keyword">new</span> Callback()&#123;...&#125;)</span><br><span class="line"></span><br><span class="line">Callback将在producer的I/O线程中触发，所以它必须轻量，快速，否则其他线程的消息会延迟发送。如果你在Callback中有耗时的逻辑处理，建议使用你自己的Executor，在Callback体中并发的执行</span><br></pre></td></tr></table></figure></p><p>Spring同样支持同步和异步，将结果和异常都保存在了SettableListenableFuture中<br>这里再提一下Callback和Producerinterceptor的使用</p><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>这里提一下Callback类，这是一个函数式接口，仅有一个onCompletion方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span></span>;</span><br></pre></td></tr></table></figure></p><p>两个参数分别为成功之后的消息元数据对象，和失败之后的异常对象，两者总是只有一个不为空(要么成功，要么失败)，而Exception分为两类异常：可重试异常，不可重试异常<br>可重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CorruptRecordException</span><br><span class="line">InvalidMetadataException</span><br><span class="line">NotEnoughReplicasAfterAppendException</span><br><span class="line">NotEnoughReplicasException</span><br><span class="line">OffsetOutOfRangeException</span><br><span class="line">TimeoutException</span><br><span class="line">UnknownTopicOrPartitionException</span><br></pre></td></tr></table></figure><p>不可重试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvalidTopicException</span><br><span class="line">OffsetMetadataTooLargeException</span><br><span class="line">RecordBatchTooLargeException</span><br><span class="line">RecordTooLargeException</span><br><span class="line">UnknownServerException</span><br></pre></td></tr></table></figure></p><p>可重试异常都继承自RetriableException，常见的判断方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> RetriableException)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在发送消息之前，开发者都可以自定义拦截器，实现Producerinterceptor即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每条消息发送之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProducerRecord&lt;K, V&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span>;</span><br><span class="line"><span class="comment">//发送请求应答之后调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="添加拦截器"><a href="#添加拦截器" class="headerlink" title="添加拦截器"></a>添加拦截器</h4><p>kafka原生配置方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">interceptors.add(<span class="string">"your class"</span>); </span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br></pre></td></tr></table></figure><p>在spring-kafka中配置更加简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.producer.properties.interceptor.classes=your class</span><br></pre></td></tr></table></figure></p><h3 id="消息发送-doSend"><a href="#消息发送-doSend" class="headerlink" title="消息发送(doSend)"></a>消息发送(doSend)</h3><p>经过拦截器拦截后，发送消息的流程又是如何呢</p><p><img src="https://ae01.alicdn.com/kf/H0d7dcdd1533945eda1d032ad9b7b7c5e8.png" alt="发送流程"></p><p>上图摘自胡夕老师的《Apache kafka实战》，十分形象的描绘了消息发送流程，正如上图所示，doSend方法只有有一个入参ProducerRecord，用于封装消息，一个出参RecordMetadata，它是broker应答之后的返回信息。二者的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key长度，value长度可计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordMetadata</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedKeySize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serializedValueSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TopicPartition topicPartition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Long checksum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提一下ProducerRecord的timestamp，取决于message.timestamp.type的配置<br>CreateTime：客户端发送消息时的时间戳，默认值。<br>LogAppendTime：消息在broker追加日志时的时间戳。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>为了便于理解接下来的流程，有几个类需要为大家介绍清楚</p><p>在KafkaProducer的构造函数中初始化了以下几个关键类，有兴趣的读者可自行研究，可省略JMX和事务相关的内容</p><ul><li><p>Partitioner：分区选择器，你要发送的这条消息应该分配到哪个分区？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.partitioner = </span><br><span class="line">        config.getConfiguredInstance(ProducerConfig.PARTITIONER_CLASS_CONFIG,Partitioner.class);</span><br></pre></td></tr></table></figure></li><li><p>KafkaClient：用于和broker做网络交互的客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KafkaClient client = kafkaClient != null ? kafkaClient : new NetworkClient(...);</span><br></pre></td></tr></table></figure></li><li><p>Sender：用于批量发送消息的I/O线程，也称sender线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sender = <span class="keyword">new</span> Sender(...);</span><br></pre></td></tr></table></figure><p>sender.wakeup()的作用是：消息达到了batch.size了，起来干活</p></li><li><p>KafkaThread：继承了Thread，构造函数可以传入线程名，和设置守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ioThread = <span class="keyword">new</span> KafkaThread(ioThreadName, <span class="keyword">this</span>.sender, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">this</span>.ioThread.start();</span><br></pre></td></tr></table></figure></li><li><p>RecordAccumulator：消息累加器，其实也就是常说的消息的内存缓冲区</p></li></ul><p>在前期基本工作做好后，kafka便可以开始发送了，发送过程比较复杂，首先要获取broker端集群信息，broker到底是个什么情况，地址是什么，有几台服务器，里面已有的topic，topic已有的分区，分区在broker的分布，ISR列表，OLR列表等等信息，这些都是发送之前要关心的</p><ul><li>Metadata：这些元信息都封装在了Metadata类中，Metadata还负责这些元信息的缓存及刷新</li><li><p>Cluster: Metadata中持有一个Cluster对象，kafka每一个broker都保存了topic的leader副本分区信息，producer只需要随机向一个broker发送请求就可以获取获取到，同时该对象还有每一个kafka broker节点的元信息，如ip端口等</p></li><li><p>TopicPartition：将topic和计算好的分区封装到一起</p></li><li>InterceptorCallback：如果没有拦截器，它就是Callback回调</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来文章主要介绍了spring对kafka-client生产者做了哪些封装，spring使用ProducerFactory来创建KafkaProducer对象，将其传给CloseSafeProducer作为委托对象<br>ListenableFuture作为send方法的返回值，在buildCallback方法中对Kafka原生的Callback做了封装，并加入了spring自己的producerListener</p><p>本文至此结束，剥离spring的封装，接下来发送的具体源码将在下文揭晓</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC源码分析</title>
      <link href="/2019/10/05/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/05/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>曾经debug了一次SpringMVC的源码，但是平时比较忙(lan)，一直没有放在博客上，现在忙里偷闲整理上来</p></blockquote><h1 id="DispatcherServlet-doDispatch方法分析"><a href="#DispatcherServlet-doDispatch方法分析" class="headerlink" title="DispatcherServlet#doDispatch方法分析"></a>DispatcherServlet#doDispatch方法分析</h1><p>查找HandlerExecutionChain，它的名称为mappedHandler</p><p><img src="https://ae01.alicdn.com/kf/H16c856f002a54ed2978dc4b1d33f2a6bD.png" alt=""></p><p>遍历HandlerMapping集合handlerMappings, 根据HandlerMapping的getHandler方法查找HandlerExecutionChain</p><p><img src="https://ae01.alicdn.com/kf/H67d3c69356214afa9c0e7c328d1badedW.png" alt=""></p><p>HandlerMapping 接口的实现类AbstractHandlerMapping提供getHandler方法</p><p><img src="https://ae01.alicdn.com/kf/H71b8c8a53ce94783a7c9b8a34676915e3.png" alt=""></p><p>HandlerMapping，AbstractHandlerMapping和AbstractHandlerMethodMapping三者之间的关系如下</p><p><img src="https://ae01.alicdn.com/kf/Hc152e4b7c20e433b8cc4a74a3935115ef.png" alt=""></p><p>其主要实现流程如下：<br>1&gt; 依靠getHandlerInternal方法获取对应的handler，handler指的就是Controller类中的方法，它处理接口请求<br>该方法由AbstractHandlerMapping 的子类AbstractHandlerMethodMapping提供</p><p><img src="https://ae01.alicdn.com/kf/H3025ea329acb4328a6415047a3da6a6fD.png" alt=""></p><p>2&gt; 由lookupHandlerMethod方法查找HandlerMethod</p><p><img src="https://ae01.alicdn.com/kf/Hbe25bad47d0845d98b9f659464346fa8N.png" alt=""></p><p>找到合适的HandlerMethod并组装成一个Match对象，包装了url，请求方式和HandlerMethod对象</p><p><img src="https://ae01.alicdn.com/kf/H7fc9dfd40f724de6b0ed432a0d9e017fA.png" alt=""></p><p>MappingRegistry中的<em>mappingLookup</em>是所有url和HandlerMethod的映射关系，最终组成了Match对象，如果发现有多个就取第一个作为bestMatch，并返回HandlerMethod</p><p><img src="https://ae01.alicdn.com/kf/Ha2630f9cebab45678ef9e84e6247eff7e.png" alt=""></p><p>3&gt; getHandlerInternal方法的最后，createWithResolvedBean方法是在初始化HandlerMethod中的Handler，它定义为Object bean，如果是String类型，就从BeanFactory中获取，最后（new HandlerMethod(this,handler)</p><p>getHandler方法执行完getHandlerInternal获取到HandlerMethod之后，获取HandlerExecutionChain<br><code>HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request)</code>，</p><p>getHandlerExecutionChain在HandlerExecutionChain里填充了所有的HandlerInterceptor</p><h1 id="继续doDispatch"><a href="#继续doDispatch" class="headerlink" title="继续doDispatch"></a>继续doDispatch</h1><p>找到HandlerExecutionChain后，然后查找HandlerAdapter，实现抽象类为AbstractHandlerMethodAdapter<br><img src="https://ae01.alicdn.com/kf/Hb81c2ffa03154ba09a88839a6e2e357eh.png" alt=""><br>接下来判断请求方式为GET或HEAD，满足<em>Last-Modified</em>的请求直接返回<br>前文提到过HandlerExecutionChain里包含了所有的HandlerInterceptor，HandlerExecutionChain的applyPreHandle方法用于执行每个HandlerInterceptor的preHandle方法<br>如果有一个没通过，返回了false，同时出发afterCompletion，那么整个请求结束<br>最后HandlerAdapter的实现类RequestMappingHandlerAdapter调用handle开始处理请求，注释里也说明了”真正开始调用handler“</p><p>HandlerAdapter类图如下<br><img src="https://ae01.alicdn.com/kf/Hac81cd901f654da69db0976c91765d6fw.png" alt=""><br>HandlerAdapter ha调用handle的流程如下，核心处理过程在其子类RequestMappingHandlerAdapter的handleInternal方法中调用的invokeHandlerMethod中(红框处)<br><img src="https://ae01.alicdn.com/kf/H14d4d6d09b8d4716ad79def79ddd48d3D.png" alt=""><br><img src="https://ae01.alicdn.com/kf/Hcfc0a4cb73f24d6ea49d169831f5c2dbx.png" alt=""><br><img src="https://ae01.alicdn.com/kf/Ha5a165c031ff4de897937582f4e25dbd8.png" alt=""></p><h2 id="invokeHandlerMethod方法解析"><a href="#invokeHandlerMethod方法解析" class="headerlink" title="invokeHandlerMethod方法解析"></a>invokeHandlerMethod方法解析</h2><p><img src="https://ae01.alicdn.com/kf/H870bfbf42e454aa9aafb69c8d7fbe459A.png" alt=""></p><p>invokeHandlerMethod的方法很长，但重点关注红框内的代码,首先HandlerMethod类图的某一条类分支如下</p><p><img src="https://ae01.alicdn.com/kf/H4b768a2b8d0b4806b3c6c9a277759ae2A.png" alt=""></p><p>InvocableHandlerMethod翻译为可调用的HandlerMethod，里面有三个字段</p><ol><li>WebDataBinderFactory： 用于创建 WebDataBinder的工厂，而WebDataBinder主要用于请求数据和方法参数的绑定</li><li>HandlerMethodArgumentResolverComposite：一组HandlerMethodArgumentResolver的集合，HandlerMethodArgumentResolver主要用于参数解析</li><li>ParameterNameDiscoverer：用于获取方法或者构造方法的参数名称(很有意思的东西，普通反射等手段是获取不到的)</li></ol><p>ServletInvocableHandlerMethod:多了个HandlerMethodReturnValueHandlerComposite，里面是一组HandlerMethodReturnValueHandler，而HandlerMethodReturnValueHandler用于处理返回值</p><p>第二处红框内的ServletInvocableHandlerMethod invocableMethod.invokeAndHandle(webRequest, mavContainer) 方法为入口<br>第一行代码就已经处理结束，获取了返回值，可以预料它的处理过程很长，注意上层没有providedArgs参数<br><img src="https://ae01.alicdn.com/kf/H8230848f16fb403f907332bb61261ea8U.png" alt=""></p><p>而真正的调用过程都在ServletInvocableHandlerMethod的父类InvocableHandlerMethod中，过程只有两行代码，解析参数，调用方法，最后返回结果<br><img src="https://ae01.alicdn.com/kf/Hcc1af06c535c469b90a0cd21e322dac1I.png" alt=""></p><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>承接上文，getMethodParameters请request中获取参数，那么具体过程是如何的呢<br><img src="https://ae01.alicdn.com/kf/H0cc6db5534574e20a2a71375af5e4cedM.png" alt=""></p><ol><li>首先MethodParameter是spring对方法参数的抽象封装， 可以理解为Method或者Constructor(二者共同父类为Executable) + Parameter，以及参数index，所在的class，参数类型，参数的泛型类型，参数的注解，参数名称</li><li>遍历参数数组，由于providedArgs为空，所以暂时忽略args[i] = resolveProvidedArgument(parameter, providedArgs);</li><li>判断是否可以解析这个参数，HandlerMethodArgumentResolver可以是多个，但是每个参数都有对应的Resolver解析，具体就由supportsParameter方法判断，前文提到HandlerMethodArgumentResolverComposite(即argumentResolvers)是一个HandlerMethodArgumentResolver集合，Composite的supportsParameter就是遍历里面的HandlerMethodArgumentResolver，通过Resolver的supportsParameter方法找到合适Resolver，如果找不到就说明不支持<br><img src="https://ae01.alicdn.com/kf/H30c46b35c7244e81b925361a300f5608F.png" alt=""><br><img src="https://ae01.alicdn.com/kf/H3e58404a2dd7408bb633d5123cbd96aaR.png" alt=""></li><li>resolveArgument也是在HandlerMethodArgumentResolverComposite中执行的<br> <code>args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, *this*.*dataBinderFactory*);</code><br>视为过渡代码<br><img src="https://ae01.alicdn.com/kf/Hfb9706db3fb74f708636a8a40ad2fe4cN.png" alt=""></li></ol><p>接下来就是HandlerMethodArgumentResolver的解析了，其关键实现类为RequestResponseBodyMethodProcessor，它同时继承了ReturnValueHandler和ArgumentResolver接口，之后的很多地方都用到了它和它的Abstractxxx父类<br><img src="https://ae01.alicdn.com/kf/H9045100b3ee1498cadf9ae26a09db0dem.png" alt=""></p><p>RequestResponseBodyMethodProcessor解析过程如下，首先就是MessageConverters解析，这里spring用了三个readWithMessageConverters，看得我眼晕，吐槽<br><img src="https://ae01.alicdn.com/kf/H18b244aea3614aa3993484b20e0e9f83m.png" alt=""></p><p>第二个红框出的readWithMessageConverters是在RequestResponseBodyMethodProcessor的父类AbstractMessageConverterMethodArgumentResolver中<br>该方法有点长，只截取关键代码部分，简单来说就是遍历所有的messageConverter，根据messageConverter 的canRead方法判断是否要解析参数，然后根据getAdvice方法返回的RequestResponseBodyAdviceChain分别在解析前后执行<br>RequestResponseBodyAdviceChain比较简单，里面是一组RequestBodyAdvice集合和一组ResponseBodyAdvice集合，它们允许用户对请求参数和响应结果做修改(希望统一封装项目请求参数和返回值的童鞋看黑板)<br>最后返回的body就是方法参数对象<br><img src="https://ae01.alicdn.com/kf/H9381d3a466414d969964de3795b8bb44A.png" alt=""></p><p>获取到参数后，回到RequestResponseBodyMethodProcessor的resolveArgument方法，这里的arg就是刚才返回的body，然后我们要把这个Object绑定到Controller方法里的参数对象上去，绑定之前要通过JSR303校验，因此validateIfApplicable主要就是做校验的，如果校验不通过，BindingResult就会携带着异常抛出，请求结束<br><img src="https://ae01.alicdn.com/kf/H81e2c8aa48924025bd24721318885302v.png" alt=""></p><p>校验过程<br><img src="https://ae01.alicdn.com/kf/Hca013c6334704efcbbefa03bb25a93beY.png" alt=""></p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>当解析，校验，绑定参数完成之后，便可以开始调用方法了，InvocableHandlerMethod#invokeForRequest继续执行<br><img src="https://ae01.alicdn.com/kf/H5b71d02a027e4dd4923fc58f5d32cde17.png" alt=""><br>调用过程十分简单</p><ol><li>如果方法不是public，就先setAccessible(<em>true</em>)</li><li>通过反射执行方法，getBean() 返回的是Controller对象<br><img src="https://ae01.alicdn.com/kf/H3792b5c8d7a14038bdda3a619411f329m.png" alt=""></li></ol><p>ServletInvocableHandlerMethod#invokeAndHandle在调用完父类InvocableHandlerMethod的invokeForRequest方法后，开始处理返回结果<br><img src="https://ae01.alicdn.com/kf/He14f1031b43c4275b7f0502e60853b792.png" alt=""></p><p>返回结果由HandlerMethodReturnValueHandlerComposite 中某一个的HandlerMethodReturnValueHandler处理，根据supportsReturnType决定谁处理<br>然后发现还是交给了RequestResponseBodyMethodProcessor处理，因为它不仅是HandlerMethodArgumentResolver<br>还是HandlerMethodReturnValueHandler的实现类，也就是说解析参数，处理返回值的活都是它干的<br><img src="https://ae01.alicdn.com/kf/Hc6518f793c654369a1a417e3f0b3a71dB.png" alt=""><br><img src="https://ae01.alicdn.com/kf/H3da3d4369222482fa6674e59eefc05beb.png" alt=""></p><p>RequestResponseBodyAdviceChain中的ResponseBodyAdvice集合，根据各自的supports方法，判断要不要处理这个返回结果<br>然后再有真正的messageConverter处理，这里由AbstractGenericHttpMessageConverter#write<br>交给AbstractJackson2HttpMessageConverter#writeInternal做json序列化处理<br><img src="https://ae01.alicdn.com/kf/H3ec8bbe3dbde4c779d60354c83735b9dP.png" alt=""></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>剩下的代码大部分都索然无味了，一路跳回到DispatcherServlet的doDispatch方法<br><img src="https://ae01.alicdn.com/kf/Had821ec5f1144629949b04a78dd6b6fdc.png" alt=""><br>这里执行了所有HandlerInterceptor的postHandle方法</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring 扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ElasticSearch7.2 父子文档</title>
      <link href="/2019/09/27/ElasticSearch7-2-%E7%88%B6%E5%AD%90%E6%96%87%E6%A1%A3/"/>
      <url>/2019/09/27/ElasticSearch7-2-%E7%88%B6%E5%AD%90%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<blockquote><p>写这篇文章的目的是为了帮助大家了解7.2版本中的父子文档，之前希望通过百度的博客快速了解一下，然而大失所望，建立索引的语法在7.2版本没有一个能通过，决定仔细看一遍<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/parent-join.html#_searching_with_parent_join" target="_blank" rel="noopener">官方文档</a></p></blockquote><h2 id="建立父-子文档语法"><a href="#建立父-子文档语法" class="headerlink" title="建立父-子文档语法"></a>建立父-子文档语法</h2><p>首先看一下如何建立父子文档，明显和网上”_parent”的方式不一样，说明es后期版本已经修改了语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;my_join_field&quot;: &#123; </span><br><span class="line">        &quot;type&quot;: &quot;join&quot;,</span><br><span class="line">        &quot;relations&quot;: &#123;</span><br><span class="line">          &quot;question&quot;: &quot;answer&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码建立了一个my_index的索引，其中my_join_field是一个用于join的字段，type为join，关系relations为：父为question, 子为answer<br>至于建立一父多子关系，只需要改为数组即可：<code>&quot;question&quot;: [&quot;answer&quot;, &quot;comment&quot;]</code></p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>插入两个父文档，语法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/_doc/1?refresh</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is a question&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;question&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时也可以省略name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/_doc/1?refresh</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is a question&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &quot;question&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插入子文档"><a href="#插入子文档" class="headerlink" title="插入子文档"></a>插入子文档</h3><p>子文档的插入语法如下，注意routing是父文档的id，平时我们插入文档时routing的默认就是id<br>此时name为answer，表示这是个子文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_doc/3?routing=1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is an answer&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;answer&quot;, </span><br><span class="line">    &quot;parent&quot;: &quot;1&quot; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="通过parent-id查询子文档"><a href="#通过parent-id查询子文档" class="headerlink" title="通过parent_id查询子文档"></a>通过parent_id查询子文档</h3><p>通过parent_id query传入父文档id即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;parent_id&quot;: &#123; </span><br><span class="line">      &quot;type&quot;: &quot;answer&quot;,</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="父-子文档的性能及限制性"><a href="#父-子文档的性能及限制性" class="headerlink" title="父-子文档的性能及限制性"></a>父-子文档的性能及限制性</h2><p>父-子文档主要适用于一对多的实体关系，将其反范式存入文档中</p><p>父-子文档主要由以下特性：</p><ul><li>Only one join field mapping is allowed per index.<br>每个索引只能有一个join字段</li><li>Parent and child documents must be indexed on the same shard. This means that the same routing value needs to be provided when getting, deleting, or updating a child document.<br>父-子文档必须在同一个分片上，也就是说增删改查一个子文档，必须使用和父文档一样的routing key(默认是id)</li><li>An element can have multiple children but only one parent.<br>每个元素可以有多个子，但只有一个父</li><li>It is possible to add a new relation to an existing join field.<br>可以为一个已存在的join字段添加新的关联关系</li><li>It is also possible to add a child to an existing element but only if the element is already a parent.<br>可以在一个元素已经是父的情况下添加一个子</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>es中通过父子文档来实现join，但在一个索引中只能有一个一父多子的join</p><h2 id="关系字段"><a href="#关系字段" class="headerlink" title="关系字段"></a>关系字段</h2><p>es会自动生成一个额外的用于表示关系的字段：field#parent<br>我们可以通过以下方式查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> &quot;script_fields&quot;: &#123;</span><br><span class="line">    &quot;parent&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">         &quot;source&quot;: &quot;doc[&apos;my_join_field#question&apos;]&quot; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部分响应为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;_index&quot; : &quot;my_index&quot;,</span><br><span class="line">&quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">&quot;_id&quot; : &quot;8&quot;,</span><br><span class="line">&quot;_score&quot; : 1.0,</span><br><span class="line">&quot;fields&quot; : &#123;</span><br><span class="line">  &quot;parent&quot; : [</span><br><span class="line">    &quot;8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot; : &quot;my_index&quot;,</span><br><span class="line">&quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">&quot;_id&quot; : &quot;4&quot;,</span><br><span class="line">&quot;_score&quot; : 1.0,</span><br><span class="line">&quot;_routing&quot; : &quot;10&quot;,</span><br><span class="line">&quot;fields&quot; : &#123;</span><br><span class="line">  &quot;parent&quot; : [</span><br><span class="line">    &quot;10&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有_routing字段的说明是子文档，它的parent字段是父文档id，如果没有_routing就是父文档，它的parent指向当前id</p><h2 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h2><p>父-子文档的join查询使用一种叫做全局序列(Global ordinals)的技术来加速查询，它采用预加载的方式构建，防止在第一次查询或聚合时出现太长时间的延迟，但在索引元数据改变时重建，父文档越多，构建时间就越长，重建在refresh时进行，这会造成refresh大量延迟时间(在refresh时也是预加载).<br>如果join字段很少用，可以关闭这种预加载模式:<code>&quot;eager_global_ordinals&quot;: false</code></p><h3 id="全局序列的监控"><a href="#全局序列的监控" class="headerlink" title="全局序列的监控"></a>全局序列的监控</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 每个索引</span><br><span class="line">curl -X GET &quot;localhost:9200/_stats/fielddata?human&amp;fields=my_join_field#question&amp;pretty&quot;</span><br><span class="line"># 每个节点上的每个索引</span><br><span class="line">curl -X GET &quot;localhost:9200/_nodes/stats/indices/fielddata?human&amp;fields=my_join_field#question&amp;pretty&quot;</span><br></pre></td></tr></table></figure><h2 id="一父多子的祖孙结构"><a href="#一父多子的祖孙结构" class="headerlink" title="一父多子的祖孙结构"></a>一父多子的祖孙结构</h2><p>考虑以下结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   question</span><br><span class="line">    /    \</span><br><span class="line">   /      \</span><br><span class="line">comment  answer</span><br><span class="line">           |</span><br><span class="line">           |</span><br><span class="line">          vote</span><br></pre></td></tr></table></figure></p><p>建立索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;my_join_field&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;join&quot;,</span><br><span class="line">        &quot;relations&quot;: &#123;</span><br><span class="line">          &quot;question&quot;: [&quot;answer&quot;, &quot;comment&quot;],  </span><br><span class="line">          &quot;answer&quot;: &quot;vote&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插入孙子节点"><a href="#插入孙子节点" class="headerlink" title="插入孙子节点"></a>插入孙子节点</h3><p>注意这里的routing和parent值不一样,routing指的是祖父字段，即question,而parent指的就是字面意思answer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/_doc/3?routing=1&amp;refresh </span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is a vote&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;vote&quot;,</span><br><span class="line">    &quot;parent&quot;: &quot;2&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="has-child查询"><a href="#has-child查询" class="headerlink" title="has-child查询"></a>has-child查询</h2><p>查询包含特定子文档的父文档，这是一种很耗性能的查询，尽量少用。它的查询标准格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;has_child&quot; : &#123;</span><br><span class="line">            &quot;type&quot; : &quot;child&quot;,</span><br><span class="line">            &quot;query&quot; : &#123;</span><br><span class="line">                &quot;match_all&quot; : &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;max_children&quot;: 10, //可选，符合查询条件的子文档最大返回数</span><br><span class="line">            &quot;min_children&quot;: 2, //可选，符合查询条件的子文档最小返回数</span><br><span class="line">            &quot;score_mode&quot; : &quot;min&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>部分测试代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">DELETE my_index</span><br><span class="line"></span><br><span class="line">PUT /my_index?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;my_join_field&quot;: &#123; </span><br><span class="line">        &quot;type&quot;: &quot;join&quot;,</span><br><span class="line">        &quot;relations&quot;: &#123;</span><br><span class="line">          &quot;question&quot;: &quot;answer&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 插入父</span><br><span class="line">PUT /my_index/_doc/8?refresh&amp;pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is a question&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;question&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/_doc/10?refresh&amp;pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is a new question&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;question&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/_doc/12?refresh&amp;pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is a new question&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;question&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 插入子</span><br><span class="line">PUT /my_index/_doc/3?routing=8&amp;refresh&amp;pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is an answer&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;answer&quot;, </span><br><span class="line">    &quot;parent&quot;: &quot;8&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT /my_index/_doc/4?routing=10&amp;refresh&amp;pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;This is another answer&quot;,</span><br><span class="line">  &quot;my_join_field&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;answer&quot;,</span><br><span class="line">    &quot;parent&quot;: &quot;10&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 通过parent_id查询子文档</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;parent_id&quot;: &#123; </span><br><span class="line">      &quot;type&quot;: &quot;answer&quot;,</span><br><span class="line">      &quot;id&quot;: &quot;8&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 查询relation</span><br><span class="line">POST my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> &quot;script_fields&quot;: &#123;</span><br><span class="line">    &quot;parent&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">         &quot;source&quot;: &quot;doc[&apos;my_join_field#question&apos;]&quot; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> ELK Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring-boot原理之@EnableXxx注解的实现</title>
      <link href="/2019/09/25/spring-boot%E5%8E%9F%E7%90%86%E4%B9%8B-EnableXxx%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/25/spring-boot%E5%8E%9F%E7%90%86%E4%B9%8B-EnableXxx%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>Spring boot各种领人眼花缭乱的starter层出不穷，它实现了各种组件与spring的集成，本文以spring-cloud-openfeign 2.2.0版本为例，介绍@EnableXxx注解的实现原理</p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><em>注 由于有包扫描相关，本文约定包名为com.ttyc，启动类名为MainApplication</em></p><p>@EnableFeignClients的源码大致如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line"><span class="comment">// value和basePackages的作用一样，互为别名</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它引入了FeignClientsRegistrar，而FeignClientsRegistrar实现了ImportBeanDefinitionRegistrar接口</p><h2 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h2><p>@Import注解通常用于导入@Configuration注解的配置类，但在它的文档描述中也明确说明了支持ImportSelector和ImportBeanDefinitionRegistrar的实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;Provides functionality equivalent to the &#123;@code &lt;import/&gt;&#125; element in Spring XML.</span><br><span class="line">* Allows for importing &#123;@code @Configuration&#125; classes, &#123;@link ImportSelector&#125; and</span><br><span class="line">* &#123;@link ImportBeanDefinitionRegistrar&#125; implementations</span><br></pre></td></tr></table></figure></p><p>ImportBeanDefinitionRegistrar接口提供import类的注解元信息，下文将会解释它是什么，以及一个BeanDefinition的注册表用于注册<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="FeignClientsRegistrar"><a href="#FeignClientsRegistrar" class="headerlink" title="FeignClientsRegistrar"></a>FeignClientsRegistrar</h2><p>FeignClientsRegistrar实现的registerBeanDefinitions调用了2个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">registerDefaultConfiguration(metadata, registry);</span><br><span class="line">registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="registerDefaultConfiguration"><a href="#registerDefaultConfiguration" class="headerlink" title="registerDefaultConfiguration"></a>registerDefaultConfiguration</h3><p>registerDefaultConfiguration注册了一个FeignClientSpecification的bean，它的beanName经过一系列字符串拼接，最终是default.com.ttyc.MainApplication<br>用于Feign的同学都知道Feign可以自定义一些配置，如Decoder，Encoder，Contract，这里是注册了一个默认的配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 拿到EnableFeignClients注解的配置项</span></span><br><span class="line">Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 肯定包含defaultConfiguration</span></span><br><span class="line"><span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="comment">// 有没有标注在内部类上</span></span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 基本都走这 name = default.com.ttyc.MainApplication</span></span><br><span class="line">name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册bean</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AnnotationMetadata"><a href="#AnnotationMetadata" class="headerlink" title="AnnotationMetadata"></a>AnnotationMetadata</h4><p>至此可以看出AnnotationMetadata其实就是EnableFeignClients注解所在类的元信息，通过AnnotationMetadata的getAnnotationAttributes方法可以很方便的获到一个注解所有属性和值的map。但EnableFeignClients注解不是随便什么类都可以写的，通常标注在启动类上也是原因的。</p><h3 id="registerFeignClients"><a href="#registerFeignClients" class="headerlink" title="registerFeignClients"></a>registerFeignClients</h3><p>我们写的FeignClient接口由ClassPathScanningCandidateComponentProvider负责扫描，它需要指定路径，以及过滤器<br>过滤器的作用是在扫描是获取匹配的类，在这里就是有FeignClient注解的类，最终组装成BeanDefinition集合<br>registerFeignClients的源码主要分为：获取basePackages，扫码到所有类封装为BeanDefinition，注册到spring IOC容器中</p><h4 id="获取basePackages流程"><a href="#获取basePackages流程" class="headerlink" title="获取basePackages流程"></a>获取basePackages流程</h4><p>这一部分代码主要是希望大家不要随意设置clients属性，它会获取clients数组里每一个类所在的包，添加到basePackages集合中，实际开发中维护性并不是很好<br>那么在没有设置clients属性时，执行basePackages = getBasePackages(metadata)，它会依次添加用户在@EnableFeignClients中设置的value，basePackages以及basePackageClasses中每一个类所在的包路径，<br>如果这三个属性你都没有设置，就获取@EnableFeignClients注解所在类的包路径作为basePackages<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">FeignClient.class);</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">: (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line"><span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">basePackages = getBasePackages(metadata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// @EnableFeignClients可以设置clients属性，如果设置了FeignClient类，就以它所在包为路径扫描</span></span><br><span class="line"><span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">&#125;</span><br><span class="line">AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line"><span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">scanner.addIncludeFilter(</span><br><span class="line"><span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 见下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注册FeignClient到IOC容器"><a href="#注册FeignClient到IOC容器" class="headerlink" title="注册FeignClient到IOC容器"></a>注册FeignClient到IOC容器</h3><p>在获取到所有的basePackages后，对其进行遍历，scanner扫描每一个路径，获取所有带有@FeignClient的类，并解析为BeanDefinition集合，<br>第二个for循环对BeanDefinition集合遍历，通过registerFeignClient方法注册到IOC容器中<br>而registerClientConfiguration是为每一个FeignClient的configuration注册bean，它的beanName为：@FeignClient的name值 + .FeignClientSpecification<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">// 扫描包下所有类，把满足TypeFilter的类解析为BeanDefinition返回</span></span><br><span class="line"><span class="comment">// 通常情况下scanner只addIncludeFilter一个annotationTypeFilter</span></span><br><span class="line"><span class="comment">// TypeFilter: AnnotationTypeFilter过滤有FeignClient注解的类</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">.findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// verify annotated class is an interface</span></span><br><span class="line">AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line"><span class="comment">// 获取FeignClient类上的所有注解及其配置项，除了@FeignClient，还会有别的注解</span></span><br><span class="line">AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line"><span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独获取@FeignClient的配置项</span></span><br><span class="line">Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">.getAnnotationAttributes(</span><br><span class="line">FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从attributes中获取@FeignClient的name</span></span><br><span class="line">String name = getClientName(attributes);</span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line"></span><br><span class="line">registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="registerFeignClient"><a href="#registerFeignClient" class="headerlink" title="registerFeignClient"></a>registerFeignClient</h4><p>registerFeignClient方法就比较简单了，就是组装BeanDefinition，然后注册成一个FeignClientFactoryBean，它的beanName为FeignClient的类全名，里面还有一些别名，primary的设置，内部细节见源码里的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">String className = annotationMetadata.getClassName();</span><br><span class="line">BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">validate(attributes);</span><br><span class="line">definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">String name = getName(attributes);</span><br><span class="line">definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line"><span class="comment">// contextId新版本加入的，用于自定义bean的别名，以前总是用name作为别名</span></span><br><span class="line">String contextId = getContextId(attributes);</span><br><span class="line">definition.addPropertyValue(<span class="string">"contextId"</span>, contextId);</span><br><span class="line">definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置bean的别名</span></span><br><span class="line">String alias = contextId + <span class="string">"FeignClient"</span>;</span><br><span class="line">AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> primary = (Boolean) attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">String qualifier = getQualifier(attributes);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line"><span class="comment">// qualifier属性也是新加的，它会覆盖contextId的别名</span></span><br><span class="line">alias = qualifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类全名来作为beanName来注册bean</span></span><br><span class="line">BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line"><span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@EnableFeignClients依赖了@Import可以导入ImportBeanDefinitionRegistrar实现类的特性，将FeignClient的接口类，配置注册到spring容器中，而在注册之前，需要对用户配置的一系列包扫描路径解析，获取到FeignClient的BeanDefinition，最终完成注册<br>FeignClientSpecification表示每一个FeignClient对应的配置，FeignClientFactoryBean表示每一个FeignClient</p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring-boot原理之AutoConfiguration</title>
      <link href="/2019/09/24/spring-boot%E5%8E%9F%E7%90%86%E4%B9%8BAutoConfiguration/"/>
      <url>/2019/09/24/spring-boot%E5%8E%9F%E7%90%86%E4%B9%8BAutoConfiguration/</url>
      <content type="html"><![CDATA[<blockquote><p>承接上篇，本文分析@Import的另一种引入方式，通过实现ImportSelector的方式来引入bean</p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>@SpringBootApplication的源码如下，它是一个组合注解的事实想必大家已经知道，其中@EnableAutoConfiguration实现了主要的自动配置逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackageClasses"</span>)</span><br><span class="line">Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@EnableAutoConfiguration注解又使用了熟悉的@Import注解，它的作用在<a href="">spring-boot原理之@EnableXxx注解的实现</a>中已经说过了，它是可以通过ImportSelector引入bean的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h2><p>ImportSelector的逻辑很简单，你告诉它要引入bean的类名即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br></pre></td></tr></table></figure></p><h2 id="META-INF目录下的两个文件"><a href="#META-INF目录下的两个文件" class="headerlink" title="META-INF目录下的两个文件"></a>META-INF目录下的两个文件</h2><p>spring.factories: 定义所有的AutoConfiguration<br>spring-autoconfigure-metadata.properties: AutoConfiguration的元信息，例如Conditional条件，加载顺序等</p>]]></content>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跳表的研究与实现</title>
      <link href="/2019/09/20/%E8%B7%B3%E8%A1%A8%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/20/%E8%B7%B3%E8%A1%A8%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>跳表的基本原理介绍我是从极客学院王争老师的课程中了解到的，由于其实现相比红黑树简单，并且有与之媲美的性能，便想要实现一下，但纸上得来终觉浅，实际编码过程中遇到了不少的困难，希望本文对大家实现跳表有所帮助。</p></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>待补充，可先移步至csdn<a href="https://blog.csdn.net/pcwl1206/article/details/83512600" target="_blank" rel="noopener">相关博客</a>，内容和王争老师文章差别不大</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>本文采用java语言实现，为了让删除的时间复杂度达到O(1),采用了双链表结构，代码地址在我的Github<a href="https://github.com/GreedyPirate/data-structure/blob/master/src/com/ttyc/algorithm/SkipList.java" target="_blank" rel="noopener">数据结构专栏</a>。</p><h2 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h2><p>首先说下节点的数据结构代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用双链表存储</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node[] forwards;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为删除等操作提供O(1)</span></span><br><span class="line">    <span class="keyword">private</span> Node[] previous;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer data, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="comment">// ++level , level层有level+1个后继节点</span></span><br><span class="line">        forwards = <span class="keyword">new</span> Node[level];</span><br><span class="line">        previous = <span class="keyword">new</span> Node[level];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data == <span class="keyword">null</span> ? <span class="string">""</span> : String.valueOf(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点在level层的下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">boyNextDoor</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> forwards[level];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">previous</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> previous[level];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到有两个数组，相信一开始很多人和我一样百思不得解两个数组是干什么的，相信大家见到的跳表差不多是这样的<br><img src="https://ae01.alicdn.com/kf/Hc2f9c6a99fb84d59ac89ea21ec23a564S.png" alt="跳表1"><br>上图红线给出了查找20的路径，一开始我也觉得很好理解，但随即两个问题困扰了我很久</p><ol><li>图中有必要每层都存数据域吗，比如图中的10，为什么有5个？一个数据域+N和前后指针就可以了啊</li><li>向下的箭头怎么表示？ 再来个down指针？</li></ol><p>在找跳表相关文章时，看到一位作者引用了跳表的论文，点进去一看有种恍然大悟的感觉，跳表其实应该是这样的<br><img src="https://ae01.alicdn.com/kf/H4e6846925103438a96ec7b9c8b908655K.png" alt="跳表2"></p><p>于是我又手绘了一张跳表的结构图(省略了前驱指针)，一边画一边思考，发现问题1和问题2解决之后变得很简单<br><img src="https://ae01.alicdn.com/kf/H2b256f768e5b4e4189df038dfbf4fb16i.png" alt="跳表3"><br>最终得到了上面的代码，而forwards正是红色部分表示的后驱指针，这个后驱指针数组的长度完全取决于它所在的层数，但HEAD节点默认初始化为最大层数</p><p>可以看到previous和boyNextDoor(手动斜眼)两个方法提供了获取一个节点在x层上获取前驱和后继节点的能力</p><h2 id="初始化及成员变量介绍"><a href="#初始化及成员变量介绍" class="headerlink" title="初始化及成员变量介绍"></a>初始化及成员变量介绍</h2><h4 id="成员变量如下"><a href="#成员变量如下" class="headerlink" title="成员变量如下"></a>成员变量如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最高16层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * head节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳表高度, 从1开始算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于随机节点所在层数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, MAX_LEVEL);</span><br><span class="line">    height = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公共方法findFirstGreater"><a href="#公共方法findFirstGreater" class="headerlink" title="公共方法findFirstGreater"></a>公共方法findFirstGreater</h2><p>在讲解插入，删除，查找之前，先介绍findFirstGreater方法，这是一个简单且重要的公共方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data    要查找的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> current 查询的起始节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level   要查找的层数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果当前节点的下一个节点比data大(不能包含等于)，返回当前节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findFirstGreater</span><span class="params">(<span class="keyword">int</span> data, Node current, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    Node nextDoor = current.boyNextDoor(level);</span><br><span class="line">    <span class="comment">// current在后，nextDoor在前，两个同时往右走， 就像两个快慢指针</span></span><br><span class="line">    <span class="comment">// 只要发现nextDoor比data大，直接返回current</span></span><br><span class="line">    <span class="keyword">while</span> (nextDoor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个if写到while里也可以</span></span><br><span class="line">        <span class="keyword">if</span> (data &lt; nextDoor.data) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往前走一个</span></span><br><span class="line">        current = nextDoor;</span><br><span class="line">        nextDoor = current.boyNextDoor(level); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前层没有比data大的，但是下一层可能有</span></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>无论是查找，插入，删除，我们都要找到第一个比data大的节点的前一个节点,假设data=5，链表为 2 3(5) 7, 第一个大于5的是7，则返回3(5)，该值&lt;=5</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入的思路是这样的，首先通过随机函数决定节点有多高，当然最高不超过MAX_LEVEL，这个随机算法直接从redis源码里拿过来的，然后在每一层通过findFirstGreater方法找到第一个比data大的节点的前一个节点，剩下的就是双链表的插入了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先判断是否已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (contains(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造节点</span></span><br><span class="line">    <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(data, level);</span><br><span class="line">    <span class="comment">// 必须先赋值，下面开始--了，或者用临时变量保存</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; height) &#123;</span><br><span class="line">        height = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// level-1， 下面的leve都用做forwards数组的下标了</span></span><br><span class="line">    level--;</span><br><span class="line">    <span class="comment">// 从上往下插入</span></span><br><span class="line">    Node current = head;</span><br><span class="line">    <span class="keyword">while</span> (level &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 最关键的一行代码</span></span><br><span class="line">        current = findFirstGreater(data, head, level);</span><br><span class="line">        <span class="comment">// 双链表插入</span></span><br><span class="line">        Node nextDoor = current.boyNextDoor(level);</span><br><span class="line">        newNode.forwards[level] = nextDoor;</span><br><span class="line">        newNode.previous[level] = current;</span><br><span class="line">        current.forwards[level] = newNode;</span><br><span class="line">        <span class="keyword">if</span> (nextDoor != <span class="keyword">null</span>)</span><br><span class="line">            nextDoor.previous[level] = newNode;</span><br><span class="line">        <span class="comment">// 体会level-1对findFirstGreater方法影响，是不是达到了节点向下一层的目的？问题2搞定</span></span><br><span class="line">        level--;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h3><p>contains的实现很简单，就是调用了查找方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node node = find(data);</span><br><span class="line">    <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.data != <span class="keyword">null</span> &amp;&amp; data == node.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><p>返回1到MAX_LEVEL之间的随机数，符合正态分布<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the following implementation is basically as same as Redis ZSET implementation</span></span><br><span class="line">    <span class="comment">// see https://github.com/antirez/redis/blob/4.0/src/t_zset.c</span></span><br><span class="line">    <span class="keyword">int</span> newLevel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random.nextInt() &amp; <span class="number">0xFFFF</span>) &lt; (<span class="number">0xFFFF</span> &gt;&gt; <span class="number">2</span>)) &#123;</span><br><span class="line">        newLevel++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newLevel &lt; MAX_LEVEL) ? newLevel : MAX_LEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找就是我们所熟知的跳表查询方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node node = head;</span><br><span class="line">    <span class="keyword">int</span> level = height - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 必须找到最后一层</span></span><br><span class="line">    <span class="keyword">while</span> (level &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        node = findFirstGreater(data, node, level);</span><br><span class="line">        level--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除相比查找，需要判断findFirstGreater返回的节点值等于data才能删，然后就是简单的双链表删除操作，过程也很简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!contains(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node current = head;</span><br><span class="line">    <span class="keyword">int</span> level = height - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (level &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        current = findFirstGreater(data, current, level);</span><br><span class="line">        <span class="keyword">if</span> (current != head &amp;&amp; current.data == data) &#123;</span><br><span class="line">            <span class="comment">// 双链表删除</span></span><br><span class="line">            Node previous = current.previous(level);</span><br><span class="line">            Node nextDoor = current.boyNextDoor(level);</span><br><span class="line">            System.out.println(previous.data + <span class="string">"--&gt;"</span> + current.data + <span class="string">"--&gt;"</span> + (nextDoor == <span class="keyword">null</span> ? <span class="string">""</span> : nextDoor.data));</span><br><span class="line"></span><br><span class="line">            previous.forwards[level] = nextDoor;</span><br><span class="line">            <span class="keyword">if</span> (nextDoor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextDoor.previous[level] = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一层</span></span><br><span class="line">        level--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>说实话最耽误时间的反而是这个打印功能，我希望打印出如下形式，这我心目中这是最直观的，但这就要考虑两个节点间的空格数量，看我的代码会比较复杂，但只要自己沉下心来认真想一下，相信大家都能很快有思路<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">level 2:         29                                                                                                                                                                                                                               </span><br><span class="line">level 1:         29          57         148                                                                                                         </span><br><span class="line">level 0: 2 13 18 29 48 50 51 57 131 132 148</span><br></pre></td></tr></table></figure></p><p>我的方式不一定适合每个人，遇到两个节点只是简单的从level0遍历，大数据量不适合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">easyPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = height - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        System.out.print(<span class="string">"level "</span> + i + <span class="string">": "</span>);</span><br><span class="line">        Node current = head.forwards[i];</span><br><span class="line">        Node next = current.boyNextDoor(i);</span><br><span class="line"></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (current.data != head.forwards[<span class="number">0</span>].data) &#123;</span><br><span class="line">            builder.append(whiteSpaceHelper(current.data));</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(current.data);</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.append(whiteSpaceHelper(current.data, next.data)).append(next.data);</span><br><span class="line">            current = current.boyNextDoor(i);</span><br><span class="line">            next = next.boyNextDoor(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">whiteSpaceHelper</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    Node current = head.boyNextDoor(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.data == pre) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.boyNextDoor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = current.boyNextDoor(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (node.data == next) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += node.data.toString().length();</span><br><span class="line">        node = node.boyNextDoor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">whiteSpaceHelper</span><span class="params">(<span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    Node node = head.forwards[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.data == next) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += node.data.toString().length();</span><br><span class="line">        count++;</span><br><span class="line">        node = node.boyNextDoor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>依次对跳表的插入，删除，打印查找做测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SkipList skipList = <span class="keyword">new</span> SkipList();</span><br><span class="line">    <span class="comment">/*skipList.insert(300);</span></span><br><span class="line"><span class="comment">    skipList.insert(54);</span></span><br><span class="line"><span class="comment">    skipList.insert(14);</span></span><br><span class="line"><span class="comment">    skipList.insert(1010);</span></span><br><span class="line"><span class="comment">    skipList.insert(23);</span></span><br><span class="line"><span class="comment">    skipList.insert(8);</span></span><br><span class="line"><span class="comment">    skipList.insert(325);</span></span><br><span class="line"><span class="comment">    skipList.find(325);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> number = skipList.random.nextInt(<span class="number">1000</span>);</span><br><span class="line">        skipList.insert(number);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">15</span>) &#123;</span><br><span class="line">            skipList.insert(<span class="number">666</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    skipList.easyPrint();</span><br><span class="line">    skipList.remove(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"===================split line================="</span>);</span><br><span class="line">    skipList.easyPrint();</span><br><span class="line"></span><br><span class="line">    System.out.println(skipList.find(<span class="number">666</span>));</span><br><span class="line">    System.out.println(skipList.find(<span class="number">1024</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>纵观跳表的插入，查找，删除操作，只涉及了简单的查找，双链表的增加，删除节点等基本操作，比起红黑树的实现简单太多，但红黑树在java中有jdk实现，跳表却没有，有些遗憾</p><h2 id="跳表与红黑树"><a href="#跳表与红黑树" class="headerlink" title="跳表与红黑树"></a>跳表与红黑树</h2><p>跳表与红黑树相比有以下特性</p><ol><li>跳表采用的是空间换时间策略，也就是多了两个指针数组，如果对内存空间十分敏感的场景不太适合，即使是redis也是基于大内存+分布式</li><li>跳表和红黑树都有O(logN)的时间复杂度，并且跳表更易于维护</li><li>跳表适合做区间查找，且十分高效</li></ol>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>层级时间轮的研究与实现</title>
      <link href="/2019/09/19/%E5%B1%82%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/19/%E5%B1%82%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ElasticSearch7.2 X-pack安全认证</title>
      <link href="/2019/08/12/ElasticSearch7-2-X-pack%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/"/>
      <url>/2019/08/12/ElasticSearch7-2-X-pack%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ElasticSearch于6.8及7.1版本开始提供免费的x-pack, 并已默认集成，只需通过简单的配置即可开启。 <a href="https://www.elastic.co/cn/blog/security-for-elasticsearch-is-now-free" target="_blank" rel="noopener">官方链接</a>，主要包含以下特性:</p><ol><li>TLS 功能，可对通信进行加密</li><li>文件和原生 Realm，可用于创建和管理用户</li><li>基于角色的访问控制，可用于控制用户对集群 API 和索引的访问权限；通过针对 Kibana Spaces 的安全功能，还可允许在 Kibana 中实现多租户</li></ol><p>安全是个很大的话题,本章只针对用户权限方面做初步尝试，旨在为kibana添加用户认证。<br>通常我们的ES节点部署在内网当中，不对外暴露9200等端口，kibana是一款非常强大的可视化工具(由衷赞叹)，devTools使开发人员可以方便的操作集群，索引，<br>但是这个页面非开发人员也是可以看到的，因此第一步就是先要屏蔽非es使用方，提供一个登录认证功能。</p><h2 id="ES配置"><a href="#ES配置" class="headerlink" title="ES配置"></a>ES配置</h2><p>首先在<em>elasticsearch.yml</em>中加入以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.license.self_generated.type: basic</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br></pre></td></tr></table></figure></p><p>然后在bin目录执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure></p><p>为各个组件设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./elasticsearch-setup-passwords interactive</span><br><span class="line">future versions of Elasticsearch will require Java 11; your Java version from [/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre] does not meet this requirement</span><br><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter password for [elastic]:</span><br><span class="line">passwords must be at least [6] characters long</span><br><span class="line">Try again.</span><br><span class="line">Enter password for [elastic]:</span><br><span class="line">Reenter password for [elastic]:</span><br><span class="line">Enter password for [apm_system]:</span><br><span class="line">Reenter password for [apm_system]:</span><br><span class="line">Enter password for [kibana]:</span><br><span class="line">Reenter password for [kibana]:</span><br><span class="line">Enter password for [logstash_system]:</span><br><span class="line">Reenter password for [logstash_system]:</span><br><span class="line">Enter password for [beats_system]:</span><br><span class="line">Reenter password for [beats_system]:</span><br><span class="line">Enter password for [remote_monitoring_user]:</span><br><span class="line">Reenter password for [remote_monitoring_user]:</span><br><span class="line">Changed password for user [apm_system]</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [remote_monitoring_user]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure><p>ES的设置结束，接下来是kibana，切换至kibana/bin目录</p><h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><h3 id="删除原有"><a href="#删除原有" class="headerlink" title="删除原有"></a>删除原有</h3><p>先查看是否已经设置过，新安装的同学可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kibana-keystore list</span><br></pre></td></tr></table></figure></p><p>如果发现已安装，但忘记了密码，可以删除原有的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./kibana-keystore remove elasticsearch.username</span><br><span class="line">./kibana-keystore remove elasticsearch.password</span><br></pre></td></tr></table></figure></p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>最后添加ES密码，虽然可以在kibana.yml中配置，但是不安全，要考虑该目录的Linux权限，增加了复杂性，这也是官方提供keystore工具的原因之一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./kibana-keystore add elasticsearch.username</span><br><span class="line">./kibana-keystore add elasticsearch.password</span><br></pre></td></tr></table></figure></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>打开kibana，输入账号密码，账号为elastic<br>效果图如下<br><img src="https://ae01.alicdn.com/kf/H8359357d94e24907b332a72a2054dde4e.jpg" alt="登录"></p>]]></content>
      
      <categories>
          
          <category> ELK Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> X-pack </tag>
            
            <tag> kibana </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[译]Kafka Consumer介绍:使用新的0.9版本kafka消费者</title>
      <link href="/2019/01/21/%E8%AF%91-Kafka-Consumer%E4%BB%8B%E7%BB%8D-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%840-9%E7%89%88%E6%9C%ACkafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2019/01/21/%E8%AF%91-Kafka-Consumer%E4%BB%8B%E7%BB%8D-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%840-9%E7%89%88%E6%9C%ACkafka%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0-9-consumer-client/" target="_blank" rel="noopener">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a></p></blockquote><p>Kafka创建之初，自带了用Scala编写的生产者和消费者客户端，随着时间的推移，我们开始认识到这些API的许多局限性。例如，我们有一个”high-level”消费者API，它支持消费者组和故障转移，但却不支持更多更复杂的使用场景。我们还有一个”简版”消费者API，它提供了完全的控制，但需要用户自己处理故障转移和错误。因此我们开始重新设计这些客户端，以开启许多旧客户端难以支持甚至不可能支持的用例，并建立一组我们能够长期支持的API</p><p>第一阶段是在0.8.1版本重写了的生产者API，最近发布的0.9版本完成了第二阶段，引入了新版消费者API，建立在一个kafka自身提供的新的组协调者协议之上，新的消费者带来了以下优势：</p><ul><li>新的消费者结合了”简版”和”高级”API的功能，同时提供了组协调者和低级别访问，以构建你自己的消费策略</li><li>减少依赖：新版消费者API使用原生java，不依赖Scala运行时环境或者Zookeeper，这使得它以一个轻量库包含在你的项目中</li><li>更安全：kafka 0.9中的安全扩展只支持新版消费者</li><li>新的消费者还增加了一组用于管理消费者进程组容错的协议。以前这个功能在java客户端中的实现很笨重(有许多和ZooKeeper的重量交互)，这种复杂的逻辑使得用其他语言构建时变得十分困难，随着新协议的引进，这变得容易的多，实际上我们已经将C client迁移到新协议上了</li></ul><p>即使消费者使用了重新设计的API和组协调者协议，这些概念并没有变，因此熟悉老消费者的用户理解它应该没有太多问题。但是，在组管理和线程模型方面有一些细微的细节需要特别注意。这篇教程的目的是覆盖new consumer的基本用法，并解释这些细节</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>深入代码之前，我们回顾一下基本概念。在kafka中，topic以partition为维度划分为一组日志，producer追加写入这些日志的尾部，消费者按自己的速度读取日志，kafka在消费者组间通过分布式分区扩展消息消费，消费者组是一组消费者共享的组标识，下图展示了一个topic，它有三个分区，还有一个消费者组，它有两个消费者成员，topic里的每一个分区只分配给组内的一个成员<br><img src="https://www.confluent.io/wp-content/uploads/2016/08/New_Consumer_figure_1.png" alt=""></p><p>老的消费者依赖Zookeeper管理组，新消费者用一个建立在kafka本身之上的组协调者协议。对每一个消费者组，一个kafka broker被选为组协调者。该协调者负责管理消费者组的状态，它主要的工作是在新消费者加入组时，原有消费者离开时，和topic元信息发生改变时调节分区分配，重新分配分区的行为称之为重平衡组</p><p>当组首次初始化，消费者通常会从分区的最早或最近位移开始读取消息，然后按顺序读取每个分区。随着消费者的运行，它会提交它已经成功处理的消息的位移，如下图，消费者消费的位置在6，它上一次提交的位移是1<br><img src="https://www.confluent.io/wp-content/uploads/2016/08/New_Consumer_Figure_2.png" alt=""></p><p>当一个分区重新分配给了组内的另一个消费者，初始的位移被设置到上一次提交的位移。如果上图中的消费者突然挂了，消费者组成员接管这个分区，位移从1开始消费。这种情况下，必须重新处理崩溃消费者分区的第6个位置</p><p>这张图里还展示了日志里的2个重点，日志末端位移(LEO)表示最后一条被写入日志的消息的位移，high watermark是最后一条被成功复制到副本的消息的位移。从消费者的角度来看，最重要的事情是你只能从high watermark的位置处开始读取，防止了消费者读取副本未同步完成，有可能丢失的消息</p><h1 id="配置与初始化"><a href="#配置与初始化" class="headerlink" title="配置与初始化"></a>配置与初始化</h1><p>在开始消费者学习之前，添加kafka-client依赖到你的项目，maven片段如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0-cp1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>和其它kafka-client一样，使用properties文件构造consumer，在下面的例子中，我们提供了一个使用消费者组的最小配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span><br><span class="line">props.put(&quot;group.id&quot;, &quot;consumer-tutorial&quot;);</span><br><span class="line">props.put(&quot;key.deserializer&quot;, StringDeserializer.class.getName());</span><br><span class="line">props.put(&quot;value.deserializer&quot;, StringDeserializer.class.getName());</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);</span><br></pre></td></tr></table></figure></p><p>和原来的消费者，生产者一样，我们需要为consumer配置一个broker初始化列表，让consumer发现集群的其余部分, 不需要提供集群里的所有server地址，消费者会从给定列表的broker中确定所有存活的broker集合，这里我们假设broker运行在本地。consumer还需要知道如何反序列化key和value。最终为了加入一个消费者组，我们需要指定gruop id。在接下来的学习中，我们将介绍更多的配置</p><h1 id="topic-订阅"><a href="#topic-订阅" class="headerlink" title="topic 订阅"></a>topic 订阅</h1><p>开始消费之前，你必须首先订阅你的应用要读取的topic，在下面的例子中，我们订阅了主题”foo”和”bar”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(“foo”, “bar”));</span><br></pre></td></tr></table></figure></p><p>订阅之后，消费者可以和组内其它成员协调以获取分区分配，这些都是在你消费数据之后自动处理的，之后我们会展示如何通过assign API手动分配，但要记住不能自动和手动混合分配。</p><p>订阅方法是不可增加的：你必须在列表中包含所有的你想消费的topic。你可以随时改变你已经订阅过的topic，以前订阅的topic都会在你重新调用subscribe方法之后覆盖</p><h1 id="基本的轮询"><a href="#基本的轮询" class="headerlink" title="基本的轮询"></a>基本的轮询</h1><p>消费者需要能够并行的获取数据，可能来自多个broker上的多个topic的多个分区。consumer使用类似unix poll或select风格的API来做这件事：一旦topic被注册，所有以后的协调，重平衡和数据获取都由一个基于在事件循环调用的poll方法来驱动的，这是一个能够用单线程处理IO的简单，高效的实现。</p><p>订阅topic之后，你需要开始时间循环，以分配到一个分区并开始获取数据，这听起来很复杂，但你只需要在循环里调用poll方法，然后consumer处理剩下的事情。每次调用poll方法，它会返回一组来自分配的分区里的消息(可能为空)，下面的例子展示了poll循环的基本用法，打印了offset和vlaue：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll方法基于当前位置获取数据，当消费者组首次创建，会根据reset策略设置位置(通常为每个分区设置成earliest或latest位移)。一旦消费者开始提交位移，然后每次rebalance会重置到上次提交的位置。poll方法的参数控制了当前位置的消息消费者需要阻塞的最大时间，一旦有消息可用，消费者立即返回，但如果没有任何消息，则会等待到给定的超时时间后返回</p><p>consumer对象被设计成在自己的线程中允许，这在内部没有同步机制的情况下对于多线程是不安全的，这也不是个好主意，在这个例子中，我们使用一个标志位，当应用关闭时终止poll循环。当标志位在另一个线程中被设置为false时，一旦poll返回就会终止，不管返回了什么消息，应用也会停止处理。</p><p>你应该在完成消费后关闭它，不仅仅是清理它使用的socket连接，它还提醒了消费者组它要从组中离开了</p><p>这里例子使用了一个相对较小的超时时间，来保证关闭consumer时没有太多的延迟。可选的，你可以使用一个很大的超时时间，并用wakeup方法结束循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) </span><br><span class="line">            System.out.println(record.offset() + <span class="string">": "</span>+record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;   </span><br><span class="line">    <span class="comment">// ignore for shutdown</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">consumer.close(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br></pre></td></tr></table></figure><p>我们将超时时间改为Long.MAX_VALUE，这基本意味着consumer无限的阻塞，直到返回下一批消息。不像前面的例子设置一个标志位那样，线程可以通过consumer.wakeup()触发一个shutdown事件来中断运行中的poll，并抛出WakeupException，这个方法是线程安全的。注意如果当前没有运行中的poll，这个异常将会延续到下次请求，在这个例子中我们捕获了这个异常防止它传播</p><h1 id="汇总到一起"><a href="#汇总到一起" class="headerlink" title="汇总到一起"></a>汇总到一起</h1><p>接下来的例子，我们将所有东西都放在一起构建一个简单的Runnable任务，该任务初始化消费者，订阅一组topic，无限循环地执行poll，直到在外面关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; topics;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConsumerLoop</span><span class="params">(<span class="keyword">int</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String groupId, </span></span></span><br><span class="line"><span class="function"><span class="params">                      List&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.topics = topics;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    props.put(“group.id”, groupId);</span><br><span class="line">    props.put(“key.deserializer”, StringDeserializer.class.getName());</span><br><span class="line">    props.put(“value.deserializer”, StringDeserializer.class.getName());</span><br><span class="line">    <span class="keyword">this</span>.consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      consumer.subscribe(topics);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">          Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          data.put(<span class="string">"partition"</span>, record.partition());</span><br><span class="line">          data.put(<span class="string">"offset"</span>, record.offset());</span><br><span class="line">          data.put(<span class="string">"value"</span>, record.value());</span><br><span class="line">          System.out.println(<span class="keyword">this</span>.id + <span class="string">": "</span> + data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">      <span class="comment">// ignore for shutdown </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    consumer.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试这个用例，你要运行release 0.9.0.0版本的kafka，和一个用字符串数据的topic，最简单的方式使用kafka-verifiable-producer.sh监本写一批数据到一个topic。为了更有意思，我们应该确保topic有多个分区，这样一个消费者就不需要做所有事（？？）。例如，一个broker和Zookeeper都运行在本地，你可能会做以下的事：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-topics.sh --create --topic consumer-tutorial --replication-factor 1 --partitions 3 --zookeeper localhost:2181</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-verifiable-producer.sh --topic consumer-tutorial --max-messages 200000 --broker-list localhost:9092</span></span><br></pre></td></tr></table></figure><p>然后我们创建一个小的驱动来创建一个含有三个消费者的消费者组，都订阅了我们刚刚创建的topic<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> numConsumers = <span class="number">3</span>;</span><br><span class="line">  String groupId = <span class="string">"consumer-tutorial-group"</span></span><br><span class="line">  List&lt;String&gt; topics = Arrays.asList(<span class="string">"consumer-tutorial"</span>);</span><br><span class="line">  ExecutorService executor = Executors.newFixedThreadPool(numConsumers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;ConsumerLoop&gt; consumers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numConsumers; i++) &#123;</span><br><span class="line">    ConsumerLoop consumer = <span class="keyword">new</span> ConsumerLoop(i, groupId, topics);</span><br><span class="line">    consumers.add(consumer);</span><br><span class="line">    executor.submit(consumer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (ConsumerLoop consumer : consumers) &#123;</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">      &#125; </span><br><span class="line">      executor.shutdown();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.awaitTermination(<span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子向线程池提交了3个consumer线程，每个线程都分配了一个id，这样你可以观察到是哪个线程在接收数据，当你关闭应用时，将会执行shutdown hook，它会用wakeup暂停三个线程，并等待它们关闭。运行之后，你讲看到许多来自线程中的数据，下面是一个样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">928</span>, value=<span class="number">2786</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">929</span>, value=<span class="number">2789</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">297</span>, value=<span class="number">891</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">930</span>, value=<span class="number">2792</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">298</span>, value=<span class="number">894</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">931</span>, value=<span class="number">2795</span>&#125;</span><br><span class="line"><span class="number">0</span>: &#123;partition=<span class="number">1</span>, offset=<span class="number">278</span>, value=<span class="number">835</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">932</span>, value=<span class="number">2798</span>&#125;</span><br><span class="line"><span class="number">0</span>: &#123;partition=<span class="number">1</span>, offset=<span class="number">279</span>, value=<span class="number">838</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">299</span>, value=<span class="number">897</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">300</span>, value=<span class="number">900</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">301</span>, value=<span class="number">903</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">302</span>, value=<span class="number">906</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">303</span>, value=<span class="number">909</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;partition=<span class="number">2</span>, offset=<span class="number">304</span>, value=<span class="number">912</span>&#125;</span><br><span class="line"><span class="number">0</span>: &#123;partition=<span class="number">1</span>, offset=<span class="number">280</span>, value=<span class="number">841</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;partition=<span class="number">0</span>, offset=<span class="number">933</span>, value=<span class="number">2801</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这些展示了三个分区交叉消费情况，每个分区分配给了一个消费者线程，在每个分区里，正如预期的显示了offset的增加，你可以用Ctrl+C或者通过你的IDE来终止进程。</p><h1 id="消费者活力-求生欲"><a href="#消费者活力-求生欲" class="headerlink" title="消费者活力(求生欲?)"></a>消费者活力(求生欲?)</h1><p>当作为消费者组的一部分时，每个消费者都会从其订阅的主题中分配分区的一个子集。通常是分区上的一组锁，只要持有锁，就没有其他消费者读取它们。当你的消费者是健康的，这就是你想要的结果。这是你避免重复消费的唯一方式。但如果消费者由于机器或应用死亡，你需要锁被释放，以便分配给其它的健康消费者</p><p>笔者解读：对于一个消费者组来说，一个分区只能被一个消费者消费，作者想表达的是读取时加锁，防止别的消费者读取，实现了消费者之间避免重复消费</p><p>kafka的组协调者协议使用心跳机制来解决这个问题，每次rebalance之后，当代所有的消费者开始发送周期性的心跳给组协调者，只要协调者继续接收心跳，它就会假定消费者是健康的，每收到一次心跳，协调者就会开启或重置一个计时器，如果计时器过期了还没有心跳，协调者就会标记这个消费者死亡了，给组内其余成员发送重新入组的信号，以便分区被重新分配，这个计时器的间隔被称为session timeOut，在客户端通过以下方式配置：session.timeout.ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(“session.timeout.ms”, “<span class="number">60000</span>”);</span><br></pre></td></tr></table></figure></p><p>会话过期保证在机器，应用崩溃，或消费者与协调者之间的网络被隔离的情况下释放锁，但是应用失败有点棘手，因为消费者仍在发送心跳给协调者，并不表明应用时健康的</p><p>consumer的poll方法旨在解决这个问题，当你调用poll或者其它阻塞API时，所有的网络IO都在前台完成(？？)。consumer从不使用后台线程，这表示在你调用poll时只有心跳发送给了协调者，当你的应用停止poll(抛出异常或是下有系统挂了)时，就不再发送心跳，会话就会过期，组内开始rebalance。<br>唯一的问题是如果消费者处理消息的时间超过了会话过期时间就会触发一次假的rebalance，你应该因此将session timeout设置的足够大，来使这不太可能发送，默认是30秒，但设置成几分钟也是没道理的。更大的session timeout的缺点是，协调者将会更多的时间检测到消费者真的挂了的情况</p><h1 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h1><p>当消费者组首次创建，根据auto.offset.reset设置的值来初始化位移，一旦消费者开始执行，它会根据应用需要定期的提交位移。在每个后来的rebalance之后，分区的位移会被设置到上一次组提交的位置上，如果consumer在成功处理消息，却又在提交之前崩溃了，结果是另一个consumer会重复复工作。你提交的越频繁，你在崩溃期间看到的重复消费就越少。</p><p>在目前为止的例子中，我们假设自动提交是开启的。当前enable.auto.commit为true(默认值),consumer会根据auto.commit.interval.ms设置的值，周期性的自动提交位移。通过较少提交间隔的方式，你可以限制在consumer崩溃时的重复消费数量。</p><p>为了使用提交的API，首先你应该禁止位移自动提交，设置enable.auto.commit为false</p>]]></content>
      
      <categories>
          
          <category> Kafka Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> kafka </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 8日期类学习</title>
      <link href="/2019/01/18/java-8%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/01/18/java-8%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<blockquote><p>最近开发过程中遇到了很多时间类处理，由于对Calender类不熟悉，我说这个类设计的烂，谁赞成，谁反对？也被推荐过joda-time类库，鉴于项目用的都是java 8了，是时候了解一下java.time包下的类了</p></blockquote><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><h2 id="java-8-日期类的优势"><a href="#java-8-日期类的优势" class="headerlink" title="java 8 日期类的优势"></a>java 8 日期类的优势</h2><p>用完java 8的API之后，只有一个感觉：爽，没有啰嗦的方法，很多静态工厂方法，of，from见名知意，用到后面，一些api自己都可以猜出来了，同时api更人性化，例如对比之前的获取月份方法，是从0开始，机械化的思维，反观java 8，我能通过getMonthValue直接获取，无须+1</p><p>对于joda-time，从个人角度讲，实在不想再去记忆一套api，同时从项目角度来说，我能用jdk实现的，为什么要依赖第三方jar包，这点对于实际开发来说更重要。但对于还在使用java 8以下版本的同学joda-time还是值得推荐的</p><h2 id="API的记忆方法"><a href="#API的记忆方法" class="headerlink" title="API的记忆方法"></a>API的记忆方法</h2><p>在Effective java读书笔记一文中，静态方法相较构造方法有更多的优势，尤其是在提供给开发者使用时。java 8这方面做得很好，of，from，parse，format，minus，plus等等都是见名知意的方法</p><h2 id="时间分类"><a href="#时间分类" class="headerlink" title="时间分类"></a>时间分类</h2><p>java 8提供了3个基础时间类：LocalDate, LocalDateTime, LocalTime，分别代表日期，日期+时间，时间(时分秒)</p><p>同时三者之间可以部分转换，之所以称之为部分，很简单的例子是日期无法直接转换为具体的日期+时间，因为它缺少时分秒，这可以理解为一种精度损失，当然你可以通过默认值来补全</p><p>Instant表示瞬时时间，精确到毫秒，可用于记录时间戳</p><p>java 8支持通过时区id，时区偏移量来获取时间</p><p>在实际开发中我们关注的有以下几个方面的时间：</p><ol><li>时间戳，既有毫秒，也有秒，秒主要是PHP等服务返回的标准时间戳</li><li>Date，不要忘了数据库对应的实体中，使用的时间对象仍是Date</li><li>待格式化的字符串，很常见的需求，将字符串解析为时间，或是将时间格式化为文本<br>这几个方面时间的互相转换也需要关注</li></ol><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="now"><a href="#now" class="headerlink" title="now"></a>now</h3><p>now方法用于获取日期类的当前值，例如LocalDate获取当前日期，LocalTime获取当前时间的时分秒等信息</p><h3 id="获取年月日"><a href="#获取年月日" class="headerlink" title="获取年月日"></a>获取年月日</h3><p>根据常识，仅LocalDate, LocalDateTime可以获取年月日，分别由getYear,getMonthValue,getDayOfMonth获取，时分秒的获取方式同理LocalDateTime</p><h3 id="获取自1970-01-01T00-00-00的毫秒数，秒数，天数"><a href="#获取自1970-01-01T00-00-00的毫秒数，秒数，天数" class="headerlink" title="获取自1970-01-01T00:00:00的毫秒数，秒数，天数"></a>获取自1970-01-01T00:00:00的毫秒数，秒数，天数</h3><p>不用死记硬背，只要想清楚这几个类分别代表了什么类型的时间即可推断出api<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant.now().toEpochMilli();</span><br><span class="line">LocalDateTime.now().toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">LocalDate.now().toEpochDay();</span><br></pre></td></tr></table></figure></p><p>ZoneOffset.ofHours(8)可以理解为北京时间位于东八区</p><h3 id="获取前一天，一个月，一年等等"><a href="#获取前一天，一个月，一年等等" class="headerlink" title="获取前一天，一个月，一年等等"></a>获取前一天，一个月，一年等等</h3><p>记住两个单词即可，minus表示减，plus表示加<br>至于你想加减些什么，首先要确定要加减的单位是什么，比如分钟，那肯定是在LocalDateTime，LocalTime里找，加年，加月同理，剩下的api就不啰嗦了，授人以鱼不如授人以渔，读者有兴趣自己探索。</p><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="文本与时间之间的相互转换"><a href="#文本与时间之间的相互转换" class="headerlink" title="文本与时间之间的相互转换"></a>文本与时间之间的相互转换</h3><p>parse用于处理从文本到日期的转换，根据DateTimeFormatter的格式解析成日期<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2019-01-11"</span>, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>))</span><br></pre></td></tr></table></figure></p><p>yyyy-MM-dd是默认的格式，可以省略第二个参数，类似的HH:mm:ss在转换为时分秒时也可以省略</p><p>将日期格式化为文本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String text = LocalDate.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>))</span><br></pre></td></tr></table></figure></p><h3 id="时间戳与时间之间的转换"><a href="#时间戳与时间之间的转换" class="headerlink" title="时间戳与时间之间的转换"></a>时间戳与时间之间的转换</h3><p>注意两点：</p><ol><li><p>Instant用于表示瞬时值，它和秒，毫秒是相关联的，再将Instant转换为LocalDateTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = <span class="number">1548154964271L</span>;</span><br><span class="line">Instant instant = Instant.ofEpochMilli(time);</span><br><span class="line">LocalDateTime dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());</span><br></pre></td></tr></table></figure></li><li><p>需要判断时间戳是毫秒还是秒，PHP等语言只能精确到秒，请求这类接口时需注意<br>给出一个转换方法示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_TIME_STAMP = <span class="number">10000_000_000L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MIN_TIME_STAMP = <span class="number">1000_000_000L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Instant <span class="title">transToInstant</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; MAX_TIME_STAMP &amp;&amp; time &gt; MIN_TIME_STAMP) &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochSecond(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; MAX_TIME_STAMP * <span class="number">1000</span> &amp;&amp; time &gt; MIN_TIME_STAMP * <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal time value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="与Date类的转换"><a href="#与Date类的转换" class="headerlink" title="与Date类的转换"></a>与Date类的转换</h3><p>记住一点，旧版的Date与java 8中的日期类的转换桥梁是Instant<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date date = Date.from(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br></pre></td></tr></table></figure></p><h2 id="获取时间段"><a href="#获取时间段" class="headerlink" title="获取时间段"></a>获取时间段</h2><p>Period和ChronoUnit都可以做到计算时间段，但又有区别，下面以计算两个时间时间的天数为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.between(LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">19</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">long</span> days = ChronoUnit.DAYS.between(LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">19</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure></p><p>Period返回的是两个日期之间相差几年几月几日，以上面两个日期为例，以下三个方法分别返回: 2年, 3个月, 21天<br>period.getYears(),period.getMonths(),period.getDays()</p><p>ChronoUnit则计算出了两个日期直接具体的天数，结果为841天</p><h2 id="与周相关的几个API"><a href="#与周相关的几个API" class="headerlink" title="与周相关的几个API"></a>与周相关的几个API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line"><span class="comment">// 今天是周几</span></span><br><span class="line">DayOfWeek dayOfWeek = now.getDayOfWeek();</span><br><span class="line"><span class="comment">// 获取下周一</span></span><br><span class="line">LocalDate nextMonday = now.with(TemporalAdjusters.next(DayOfWeek.MONDAY));</span><br><span class="line"><span class="comment">// 获取本月最后一天</span></span><br><span class="line">LocalDate lastDayofMonth = now.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line"><span class="comment">// 获取本周属于当月第几周</span></span><br><span class="line"><span class="keyword">int</span> weekth = now.get(ChronoField.ALIGNED_WEEK_OF_MONTH);</span><br></pre></td></tr></table></figure><p>打印输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayOfWeek = TUESDAY</span><br><span class="line">nextMonday = 2019-05-06</span><br><span class="line">lastDayofMonth = 2019-04-30</span><br><span class="line">weekth = 5</span><br></pre></td></tr></table></figure></p><p>以前是笔者开发中遇到的api，还有很多有用的api未介绍，大家可以用到时查阅文档</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>java 8时间类的使用写到这里告一段落，关于时区的使用，也见缝插针的介绍了下，写这篇文章对笔者最大的挑战是表达能力，api很多，我想表达的是有规律的使用api，而不是死记硬背，最后分享一个自己写的DateUtils</p><h1 id="DateUtils"><a href="#DateUtils" class="headerlink" title="DateUtils"></a>DateUtils</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 舍弃对Calendar，joda-time的依赖，用java 8重写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangjie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2019/1/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERAL_PATTERN = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERAL_DATE_PATTERN = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_TIME_STAMP = <span class="number">10000_000_000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MIN_TIME_STAMP = <span class="number">1000_000_000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 分别获取年月日的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;L, M, R&gt; <span class="function">Triple&lt;Integer, Integer, Integer&gt; <span class="title">getYearMonthDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableTriple.of(today.getYear(), today.getMonthValue(), today.getDayOfMonth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取日期文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> today.format(DateTimeFormatter.ofPattern(GENERAL_DATE_PATTERN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取时间本文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateTimeText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.format(DateTimeFormatter.ofPattern(GENERAL_PATTERN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据毫秒数获取时间文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateTimeText</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.format(DateTimeFormatter.ofPattern(GENERAL_PATTERN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定日期是否是今日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(String time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(time).isEqual(today);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前时间戳是否是今天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        LocalDate date = LocalDateTime.ofInstant(transToInstant(time), ZoneId.systemDefault()).toLocalDate();</span><br><span class="line">        <span class="keyword">return</span> date.isEqual(today);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取n天之前至今的时间段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;Long, Long&gt; <span class="title">getDaysAgoTime</span><span class="params">(Integer days)</span> </span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.now().minusDays(days);</span><br><span class="line">        <span class="keyword">long</span> begin = localDate.atTime(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">long</span> end = localDate.atTime(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">return</span> ImmutablePair.of(begin, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段区间 00:00:00 - 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;Long, Long&gt; <span class="title">getDurationPair</span><span class="params">(String beginStr, String endStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = LocalDate.parse(beginStr, DateTimeFormatter.ofPattern(GENERAL_DATE_PATTERN)).atTime(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">long</span> end = LocalDate.parse(endStr, DateTimeFormatter.ofPattern(GENERAL_DATE_PATTERN)).atTime(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>).toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">return</span> ImmutablePair.of(begin, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段之间的天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getBetweenDays</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChronoUnit</span><br><span class="line">                .DAYS</span><br><span class="line">                .between(</span><br><span class="line">                        LocalDateTime.ofInstant(transToInstant(start), ZoneId.systemDefault()),</span><br><span class="line">                        LocalDateTime.ofInstant(transToInstant(end), ZoneId.systemDefault())</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段之间的天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getBetweenDays</span><span class="params">(String start, String end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChronoUnit.DAYS.between(LocalDate.parse(start), LocalDate.parse(end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个时间段之间的所有日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getBetweenDates</span><span class="params">(String start, String end)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LocalDate startDate = LocalDate.parse(start);</span><br><span class="line">        LocalDate endDate = LocalDate.parse(end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> distance = ChronoUnit.DAYS.between(startDate, endDate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (distance &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (distance == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(start);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream.iterate(startDate, d -&gt; d.plusDays(<span class="number">1</span>)).limit(distance + <span class="number">1</span>).forEach(f -&gt; &#123;</span><br><span class="line">            list.add(f.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Guava实现大数据量sql分段批量插入</title>
      <link href="/2019/01/18/Guava%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8Fsql%E5%88%86%E6%AE%B5%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"/>
      <url>/2019/01/18/Guava%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8Fsql%E5%88%86%E6%AE%B5%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>最近做一个数据拉取的需求，由于有上万的数据量，想到分段批量插入数据库，经同事推荐，Guava有好的工具类，特此记录并分享给大家</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>一开始在网上搜索，基本用到的都是List接口的sublist方法，第一版自己实现了一遍，功能没问题，但很啰嗦，下面介绍guava的partition方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分段批量插入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticketLists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batchSegmentInsertList</span><span class="params">(List&lt;TicketList&gt; ticketLists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(ticketLists))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;TicketList&gt;&gt; lists = Lists.partition(ticketLists,<span class="number">1000</span>);</span><br><span class="line">    lists.forEach(tickets -&gt;&#123;</span><br><span class="line">        ticketListDao.batchInsert(tickets);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是笔者实际开发中的代码，首先需要自己在mybatis中实现批量插入，然后使用Lists.partition方法对原有的集合做分段，1000代表分段大小</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>进入partition源码，省略中间多余过程，最终发现一个静态类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Partition</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>其实现了AbstractList，有趣的是泛型参数是List<t>，结合ArrayList类的实现，该泛型参数代表集合的一个元素，说明Partition本身是一个集合，里面的元素是一个个的小集合，结合我们要实现的功能，说明这就是我们要的对大集合切割之后的每一个小集合，而下面的get方法也佐证了我们的猜想</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index, size());</span><br><span class="line">  <span class="keyword">int</span> start = index * size;</span><br><span class="line">  <span class="keyword">int</span> end = Math.min(start + size, list.size());</span><br><span class="line">  <span class="keyword">return</span> list.subList(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还可以看出Partition底层还是用的sublist方法，不过最后我想说的还是那句老话，不要重复造轮子，遇到这种大批量sql分段插入，你肯定不是第一个人遇到，多用大牛写好的轮子，同时去看看他们是如何实现的，解放生产力的同时，也提升自己的技术</p>]]></content>
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之自定义starter</title>
      <link href="/2019/01/16/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
      <url>/2019/01/16/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
      <content type="html"><![CDATA[<blockquote><p>为何要自定义starter，使用场景是什么，又该如何去自定义呢？本文围绕这几个方面展示自定义starter的过程</p></blockquote><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在Spring-Boot实践系列文章中，对日常开发中的许多功能做了统一封装，那么在分布式开发的组织架构下，开发组内个人单独使用是没有意义的，应该将其封装成一个SDK，发布到maven私服，供大家使用，分享精神先放一边，这样做的好处是统一标准，提升开发效率，同时又需要投入部分人力维护这个项目，不断更新和修复。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>项目是一个多模块结构，不同的公共模块封装各自的公用功能，例如可以把统一的接口请求，返回，日志等放到web模块，对监控有要求的可以抽取一个监控模块，依赖了中间件时，对该中间的公用配置抽取一个模块。</p><p>项目名称可参考spring-cloud组件，例如叫base-starter-web, base-start-logger等</p><h1 id="封装starter"><a href="#封装starter" class="headerlink" title="封装starter"></a>封装starter</h1>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之多数据源最佳实践</title>
      <link href="/2019/01/05/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/01/05/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<blockquote><p>多数据源主要用于mysql主从，多库等场景，笔者初始接触时也在网上找了很多资料如何配置，但做法百花齐放，有很多用到了ThreadLocal，注解，数据源路由等技术，最终选择了一个简单，易用，易理解的方式：每一个数据源只扫描自己的mapper</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基于以上思想，只需要以下步骤：</p><ol><li>配置文件中采用不同的前缀配置各个数据源</li><li>为每个数据源初始化DataSource，SqlSessionFactory，TransactionManager</li><li>每个数据源都有自己的配置，扫描自己的mapper.xml，DAO接口</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p>注意，笔者遇到的情况是多库，以订单库和用户库举例，如果是主从，可以起名master，slave<br>配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#db1</span><br><span class="line">spring.datasource.default.url = jdbc:mysql://localhost:3306/order?characterEncoding=utf-8&amp;connectTimeout=2000&amp;socketTimeout=2000&amp;zeroDateTimeBehavior=convertToNull</span><br><span class="line">spring.datasource.default.username = root</span><br><span class="line">spring.datasource.default.password = 123</span><br><span class="line"></span><br><span class="line">#db2</span><br><span class="line">spring.datasource.user.url = jdbc:mysql://localhost:3306/user?characterEncoding=utf-8&amp;connectTimeout=2000&amp;socketTimeout=2000&amp;zeroDateTimeBehavior=convertToNull</span><br><span class="line">spring.datasource.user.username = root</span><br><span class="line">spring.datasource.user.password = 123</span><br></pre></td></tr></table></figure><h3 id="配置数据源相关对象"><a href="#配置数据源相关对象" class="headerlink" title="配置数据源相关对象"></a>配置数据源相关对象</h3><h4 id="抽取公共类"><a href="#抽取公共类" class="headerlink" title="抽取公共类"></a>抽取公共类</h4><p>如果数据源很多，建议抽取公共类，封装一些公共方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource 数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location mapper.xml位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">(DataSource dataSource, String location)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setConfiguration(configuration());</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver()</span><br><span class="line">                .getResources(location));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置下划线转驼峰</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Configuration <span class="title">configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置主数据源"><a href="#配置主数据源" class="headerlink" title="配置主数据源"></a>配置主数据源</h4><p>将order库作为项目的主数据源,@MapperScan用于扫描DAO接口，MAPPER_LOCATION传入父类指定mapper.xml位置<br>同时@Primary标注这是我们项目的主数据源<br><code>@ConfigurationProperties(&quot;spring.datasource.default&quot;)</code> 表示数据源配置采用的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.ttyc.dao.order"</span>, sqlSessionFactoryRef = <span class="string">"defaultSqlSessionFactory"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataSourceConfig</span> <span class="keyword">extends</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_LOCATION = <span class="string">"classpath:mapper/order/*.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.default"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">defaultDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"defaultSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">defaultSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"defaultDataSource"</span>)</span> DataSource defaultDataSource)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSessionFactory(defaultDataSource, MAPPER_LOCATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"defaultTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">defaultTransactionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"defaultDataSource"</span>)</span> DataSource defaultDataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(defaultDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理配置user库数据源，只不过去除@Primary注解，至此配置结束</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>正常编程即可，因为数据源已经按路径扫描了DAO接口和mapper.xml文件</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>以微服务的思想，多库是不应该存在的， 每个服务应该数据自治，职责单一，对于user库应该调用用户微服务接口，而不应该访问用户DB，造成耦合，目前笔者遇到的需求属于临时需求，并且将来会废弃该接口，所以从成本考虑，采用直接访问DB的形式，希望大家引以为戒！</p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-boot实践之请求日志切面</title>
      <link href="/2019/01/02/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97%E5%88%87%E9%9D%A2/"/>
      <url>/2019/01/02/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97%E5%88%87%E9%9D%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>记录请求日志切面的写法，和别人写的相比并无特殊之处</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h2><p>将controller中方法参数作为请求参数，返回值作为响应，这样做的前提是请求参数和返回值都已使用javabean封装，不一定适合每个人</p><h2 id="耗时统计"><a href="#耗时统计" class="headerlink" title="耗时统计"></a>耗时统计</h2><p>tomcat为每个请求分配一个线程，自然想到使用ThreadLocal保存计时器，最后不要忘了remove</p><h2 id="HttpServletRequest对象的获取"><a href="#HttpServletRequest对象的获取" class="headerlink" title="HttpServletRequest对象的获取"></a>HttpServletRequest对象的获取</h2><p>直接注入即可，Spring底层也是用ThreadLocal实现的，具体实现参考RequestContextHolder</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;StopWatch&gt; timer = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程安全，可直接注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.ttyc..controller.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"controller()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeRequest</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        timer.get().start(<span class="string">"requestTimeKeeperTask"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"request url: &#123;&#125;, \nparams are &#123;&#125;"</span>, request.getRequestURI(), JSON.toJSONString(joinPoint.getArgs()[<span class="number">0</span>]));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"转换请求参数时异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"controller()"</span>, returning = <span class="string">"response"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterResponse</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> latency = timer.get().getTotalTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"response &#123;&#125;\nlatency is &#123;&#125;ms"</span>, JSON.toJSONString(response), latency);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"转换结果时异常"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            timer.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"controller()"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrows</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> latency = timer.get().getTotalTimeMillis();</span><br><span class="line"></span><br><span class="line">        log.warn(<span class="string">"请求异常，错误信息为：&#123;&#125;\n 耗时&#123;&#125;ms"</span>, ex.getMessage(), latency);</span><br><span class="line"></span><br><span class="line">        timer.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective-java读书笔记(三)：类和接口</title>
      <link href="/2018/11/28/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/11/28/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="使类和接口的可访问性最小化"><a href="#使类和接口的可访问性最小化" class="headerlink" title="使类和接口的可访问性最小化"></a>使类和接口的可访问性最小化</h1><p>模块设计原则：对外隐藏内部数据和实现细节，把api和他的实现隔离开来，模块之间通过api通信，一个模块不需要知道其它模块的内部细节，这称之为封装。</p><p>封装有效地让各模块直接解耦，解耦之后模块可以独立的开发，测试，优化，使用及修改。</p><ol><li>尽可能地使每个类或者成员不被外界访问<ol><li>类或接口尽可能的做成包级私有的，在以后的版本中，可以对他修改</li><li>如果你把类做成公有的，你就有责任永远对它负责，保证后续版本的兼任性</li><li>如果一个类只在某个类中使用，则考虑使用嵌套类(nested-class)</li></ol></li></ol><p>如果</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective java读书笔记(二)：对象通用方法</title>
      <link href="/2018/11/26/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/26/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="对象通用方法"><a href="#对象通用方法" class="headerlink" title="对象通用方法"></a>对象通用方法</h1><h2 id="覆盖equals时的约定"><a href="#覆盖equals时的约定" class="headerlink" title="覆盖equals时的约定"></a>覆盖equals时的约定</h2><p>当类具有特有的”逻辑相等”概念时，必须覆盖equals方法，这样也可以使这个类作为map的key，或者set中的元素</p><p>当对象非null时，equals方法满足以下四个特性：</p><ol><li>自反性：<code>x.equals(x)=true</code></li><li>对称性：<code>x.equals(y)=true</code>时，<code>y.equals(x)</code>必须为true</li><li>传递性：x=y，y=z，则x=z</li><li>一致性：<code>x.equals(y)</code>在多次调用后返回相同的值</li></ol><p>理解即可，不必要记忆</p><h3 id="高效的编写equals方法"><a href="#高效的编写equals方法" class="headerlink" title="高效的编写equals方法"></a>高效的编写equals方法</h3><p>首先了解一个小知识点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span> <span class="keyword">instanceof</span> Object = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>null不属于任何一个类型，所以对equals方法传入的对象不必做空指针判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> MyClass) &#123;</span><br><span class="line">        MyClass castObj = (MyClass)anObject;</span><br><span class="line">    <span class="comment">// 自己的判断逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写步骤"><a href="#编写步骤" class="headerlink" title="编写步骤"></a>编写步骤</h4><ol><li>首先用==检查参数是否是当前对象</li><li>判断参数是否是要判断的类型，</li><li>将对象强转成要比较的对象类型</li><li>根据类中的字段编写自己的判断逻辑，返回相应的true或false</li></ol><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h3><p>相信很多新手同学分不清这二者的区别，以及使用场景，二者区别如下：</p><ol><li><p>先说基本类型的==判断：值相等就返回true</p></li><li><p>再说引用类型的==：指向同一个对象才返回true</p></li><li><p>最后是equals：在Object里，它和==时一样的，但是类可以有自己的判断依据，比如String类</p></li></ol><h4 id="包装类的比较"><a href="#包装类的比较" class="headerlink" title="包装类的比较"></a>包装类的比较</h4><p>问题：<code>Integer i = 1, Integer j = 1</code>,如何比较二者是否相等?</p><p>答案是<code>i.equals(j)</code>,切不可写成<code>i==j,因为Integer内部采用了缓存，-128至127之间的数字被视为同一个对象，此时是可以通过==判断两个数字是否相等，但这只是假象，超过这个区间的数字就会返回</code>false</p><h2 id="覆盖equals是同时覆盖hashcode"><a href="#覆盖equals是同时覆盖hashcode" class="headerlink" title="覆盖equals是同时覆盖hashcode"></a>覆盖equals是同时覆盖hashcode</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>Java规范中包含以下约定：</p><ol><li>只要equals中用来判断两个对象是否相等的字段没有发生改变，那么调用多少次返回的结果都应该相同</li><li>如果通过equals判断出两个对象相等，那么它们的hashcode方法的返回值一定相等；如果不相等，那么hashcode方法的返回值不一定不等，但这必然降低了散列表的性能</li></ol><h3 id="编写hashcode方法"><a href="#编写hashcode方法" class="headerlink" title="编写hashcode方法"></a>编写hashcode方法</h3><p>hashcode方法编写的好坏，直接影响对象能否在集合中均匀分布，具体的编写方法见书41页，这里记下注意的几点：</p><ol><li>冗余字段不参与计算与比较，例如单价，数量，总价三者的关系，很明显总价可以通过另外二者计算出来，那么总价不必参与计算hashcode的过程，同时必须也不能参数equals的比较过程</li></ol><h2 id="覆盖toString方法"><a href="#覆盖toString方法" class="headerlink" title="覆盖toString方法"></a>覆盖toString方法</h2><p>toString方法的作用显而易见，如果不覆盖Object中的toString方法，返回<code>类名@对象hashcode十六进制值</code>的表现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><p>在实际开发中，toString用于记录日志是必不可少，例如打印用户信息，如果输出原始形式，则毫无价值，我们更关系的是用户id，用户名等关键信息</p><h2 id="谨慎覆盖clone方法"><a href="#谨慎覆盖clone方法" class="headerlink" title="谨慎覆盖clone方法"></a>谨慎覆盖clone方法</h2><h2 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h2>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective java读书笔记(一)：对象的创建与销毁篇</title>
      <link href="/2018/11/23/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%AF%87/"/>
      <url>/2018/11/23/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="对象的创建与销毁篇"><a href="#对象的创建与销毁篇" class="headerlink" title="对象的创建与销毁篇"></a>对象的创建与销毁篇</h1><h2 id="使用静态工厂创建对象"><a href="#使用静态工厂创建对象" class="headerlink" title="使用静态工厂创建对象"></a>使用静态工厂创建对象</h2><p>创建一个对象最常用的方式是构造方法，但有时也要考虑使用静态工厂创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"tom"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态工厂的好处有三:</p><ol><li>有名称，不同于构造方法，静态工厂作为一个普通的静态方法，可以使用名称更清晰的表达作者的想法，对比多个构造方法的情况，往往读者看见多个不同参数类型，不同顺序的构造方法时，不知道它们是干什么的，静态工厂使用方法名提高了代码可读性，私以为在企业开发中，多人合作时，面对复杂的业务逻辑，可读性尤为重要</li><li>不必每次都创建一个对象，或者说对象可以被重复利用，例如初始化一个数据库连接对象，不必每次设置用户名密码创建这个对象</li><li>可以使用多态，返回子类类型的对象，例如通过参数来判断应该返回哪种子类型</li></ol><p>同时它也是有缺点的，在看到构造方法时，我们能一眼看出是用于创建对象，但是静态工厂则不一定，因此静态工厂的方法名遵从一些惯用名称：valueOf，getInstance，newInstance等等</p><h2 id="构造方法参数过多时，使用Builder"><a href="#构造方法参数过多时，使用Builder" class="headerlink" title="构造方法参数过多时，使用Builder"></a>构造方法参数过多时，使用Builder</h2><h3 id="Builder是什么"><a href="#Builder是什么" class="headerlink" title="Builder是什么"></a>Builder是什么</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User tom = User.builder().name(<span class="string">"tom"</span>).age(<span class="number">18</span>).build();</span><br></pre></td></tr></table></figure><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>静态工厂和构造方法都不能很好的解决参数过多时，参数是否必传问题，通常先写一个大而全的参数方法，然后提供多个部分参数方法。</p><p>以静态工厂为例，比如：有三个参数，其中address，age可不传，先写出一个三参数的，然后下面的方法传null来调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, Integer age, String address)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createUser(name,age, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createUser(name, <span class="keyword">null</span>,address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的弊端很明显，参数多了不利于扩展，不扩展又会导致调用者必须传一些无用的参数，并且代码难以阅读，调用方还容易出错</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-JavaBean"><a href="#1-JavaBean" class="headerlink" title="1.JavaBean"></a>1.JavaBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setXxx();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>通过setter可以很好的避免上述问题，但书中所说JavaBean本身时可变类，无法成为不可变类，在这set的过程中有可能会产生线程安全问题，笔者认为实际业务开发中JavaBean多用于方法形参，属于线程私有，除非定义在成员变量位置，否则线程安全问题极低</p><h4 id="2-Builder模式"><a href="#2-Builder模式" class="headerlink" title="2.Builder模式"></a>2.Builder模式</h4><p>由于Builder模式代码编写很多，我们在实际开发中使用lombok可以更快的达到目的，事先引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaBean类上加入<code>@Builder</code>注解，即可像开头那样调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果类的构造方法或者静态工厂有多个参数时，优先考虑Builder模式，特别是某些参数可选时</p><h2 id="使用枚举来创建单例模式"><a href="#使用枚举来创建单例模式" class="headerlink" title="使用枚举来创建单例模式"></a>使用枚举来创建单例模式</h2><p>使用工厂模式创建单例模式分为：懒汉式，饿汉式。使用枚举作为替代主要有以下两个原因</p><ol><li>懒汉式通常需要与double-check配合使用来保证线程安全，而枚举本身就是线程安全的</li><li>工厂模式在对象反序列化无法保证单例，需要重写readResolve，而枚举自动实现了反序列化</li></ol><h3 id="使用枚举创建User单例"><a href="#使用枚举创建User单例" class="headerlink" title="使用枚举创建User单例"></a>使用枚举创建User单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    UserSingleton() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的线程安全性"><a href="#枚举的线程安全性" class="headerlink" title="枚举的线程安全性"></a>枚举的线程安全性</h3><p>枚举类在反编译之后，是一个不可变类，因此它是线程安全的</p><h3 id="测试饿汉式的反序列化失效情况"><a href="#测试饿汉式的反序列化失效情况" class="headerlink" title="测试饿汉式的反序列化失效情况"></a>测试饿汉式的反序列化失效情况</h3><p>使用饿汉式创建User单例模式类,并为<code>User</code>类实现<code>Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserSingletonFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    User instance = UserSingletonFactory.getInstance();</span><br><span class="line">    User other = UserSingletonFactory.getInstance();</span><br><span class="line">    <span class="comment">// 此时单例模式的结果返回true</span></span><br><span class="line">    System.out.println(instance == other);</span><br><span class="line">    </span><br><span class="line">    ObjectOutputStream oos =</span><br><span class="line">            <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"obj.txt"</span>)));</span><br><span class="line">    oos.writeObject(instance);</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois =</span><br><span class="line">            <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"obj.txt"</span>)));</span><br><span class="line">    User user = (User) ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line"></span><br><span class="line">    System.out.println(instance == user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果最后的输出为false</p><h2 id="通过私有的构造方法让类不可实例化"><a href="#通过私有的构造方法让类不可实例化" class="headerlink" title="通过私有的构造方法让类不可实例化"></a>通过私有的构造方法让类不可实例化</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li>私有的构造方法，指用private修饰构造方法</li><li>不可实例化，通过私有的构造方法，让类无法产生对象</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>作为一些工具类，例如JDK中的<code>Math</code>类，只希望使用它的静态成员变量和静态方法，所以我们可以看到源码中的Math类构造方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Don't let anyone instantiate this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Math</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>原则：尽量重用对象，如果是不可变类产生的对象，那它始终可以被重用</p><p>典型的不可变类如<code>String</code>,只要是相同的字符串，内存中只有一个String对象</p><p>同时有静态工厂和构造器的不可变类，优先使用静态工厂创建对象，静态工厂不会重复创建对象，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean.valueOf(<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>优先于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Boolean(<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>除了不可变对象，还可以重用那些被认为不会被修改的可变对象，书中用一个日期类举例，将只需要初始化一次的对象放在静态代码块中，在实际开发中，诸如数据库连接池，http client请求线程池等重量级的对象，为了提高性能，必须重用</p><h2 id="清理过期的对象引用"><a href="#清理过期的对象引用" class="headerlink" title="清理过期的对象引用"></a>清理过期的对象引用</h2><p>为了防止内存泄漏，需要将不再使用的对象，解除引用，即obj = null，将引用指向空，让GC回收对象</p><p>例如List的remove方法中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br></pre></td></tr></table></figure><p>需要注意的是清除对象引用是在特殊情况下的处理，并不是一种规范，我们在实际开发中并不需要小心翼翼的处理</p><h3 id="何时清除对象引用"><a href="#何时清除对象引用" class="headerlink" title="何时清除对象引用"></a>何时清除对象引用</h3><p>如果类自己管理内存空间，如<code>ArrayList</code>内部使用<code>Object</code>数组存储，一旦其中的元素被删除，则需要清空对象引用</p><h3 id="避免使用finalize方法"><a href="#避免使用finalize方法" class="headerlink" title="避免使用finalize方法"></a>避免使用finalize方法</h3><p>老生常谈的<code>finalize</code>方法问题，不要尝试调用它，GC并不会立即回收对象，甚至不保证执行。经过测试，调用finalize还会降低性能，花费更多的时间销毁对象，书中后面讲解的内容实用性太低，不做记录</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>11.22日映客架构师讲座</title>
      <link href="/2018/11/22/11.22%E6%97%A5%E6%98%A0%E5%AE%A2%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%B2%E5%BA%A7/"/>
      <url>/2018/11/22/11.22%E6%97%A5%E6%98%A0%E5%AE%A2%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%B2%E5%BA%A7/</url>
      <content type="html"><![CDATA[<ol><li>不要把每一个单独的服务优化到极致，心中要有一个架构的演进方向，根据这个方向优化分散的点，如存储，mq，服务等，最终达到一个我们心中理想的架构。同时要融入到公司，理解业务，要有将产品带向好的方向的心态，不是完成上级的任务，产品的需求，常年下来没有进步</li><li>业务服务不要直连DB，应该抽取成基础服务，业务服务都是用基础服务拼接而成的，这样做利于基础服务的扩展</li><li>作为基础服务一定要考虑限流，服务的熔断和降级</li><li>要保证业务的关键路径高可用，其他服务挂了，不能影响它，例如淘宝，下单流程，确认收货流程一定是可用的，提高用户体验</li><li>服务的取舍，比如手机直播，100w用户在一个直播间，当前用户只关心自己送出的礼物，发出的评论有没有显示，这是我们一定要保证的<br>同时，别的用户评论，一秒只显示几百条都是没问题的，丢弃其余的消息，做到流量削峰，保证良好的用户体验</li><li>分布式事务：预占型和给予型。 预占型可以记录日志，重新请求时看有没有日志来判断上一次是否执行成功了；给予型具有延时特性，比如手机转账，总是过几秒才转过来</li><li>分库分表：如何从主从切换到分库分表，先用mysql binlog同步到分库分表中，并进行比对，一直到没有差异为止，ABA问题在多次比对后出现的几率已经很低了，此时线上业务可以将读操作切换到分库分表，因为读是不会产生脏数据的</li><li>云服务的好处：按流量计费，比如某天有秒杀活动，用户量激增，如果是自己的机房，需要增加服务器，等过了这个时间后，流量又下来了，而云服务是按流量计费的，增加缩减机器都十分方便。云服务的不足之处是要和别的企业共享资源，因为稳定性不高，还会有资源限制，如带宽限制，mysql连接数限制</li><li>对恶意用户的思考，比如刷金币，刷粉丝，刷广告等等，是否有必要赶尽杀绝，如果涉黄涉政，必然是要屏蔽的，而例如微博，用户是否也有刷粉丝的实际需要<br>如何防止恶意用户呢，可以用工具，例如内容识别，账号防刷等，但是有效期不长，建议用大数据进行行为特征分析</li><li>需求和开发：施行2周制，第一周产品和开发都是ready状态，产品准备好需求，开发人员开始开发，测试，直到第二周结束上线，同时从第一周开始并行地，开始准备下一轮新的需求，到第二周结束准备好下一轮新需求，以此往复</li><li>定期梳理自己的代码，线上服务正常运行很近，突然出现问题，说”我没动代码啊”，这样做是不对的，没动过并不代表没有隐患，可以每天上下班看一眼自己的业务指标监控(open-falcon)</li><li>线上出现问题的正确做法，立即采取一切手段修复故障，保障用户体验，及时止损，而不是在保护故障现场，排查问题。事后要对故障复盘，并且组内开会讨论，不要抱有职责，内疚的情绪，让组员都从这次问题中成长</li><li>语言和技术栈一定要统一，降低成本</li><li>抽取通用服务，如鉴权，不要每个服务都开发一套</li></ol>]]></content>
      
      <categories>
          
          <category> 架构随笔录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之Spring Cloud Consul项目接入</title>
      <link href="/2018/11/19/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8BSpring-Cloud-Consul%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5/"/>
      <url>/2018/11/19/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8BSpring-Cloud-Consul%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>本文主要介绍Spring Cloud对consul的支持，分为消费者和生产者两个客户端</p></blockquote><h2 id="应用详情"><a href="#应用详情" class="headerlink" title="应用详情"></a>应用详情</h2><p>分别新建两个spring-boot项目</p><table><thead><tr><th>应用名称</th><th>端口</th><th>consul注册地址</th></tr></thead><tbody><tr><td>consumer-service</td><td>8301</td><td>10.9.181.34:8500</td></tr><tr><td>producer-service</td><td>8302</td><td>10.9.117.128:8500</td></tr></tbody></table><h2 id="consul接入"><a href="#consul接入" class="headerlink" title="consul接入"></a>consul接入</h2><h3 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h3><p>除了通用的web模块，主要需要consul-discovery与actuator，前者用于consul客户端接入，后者提供健康检查接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulConsumerApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ConsulConsumerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8301</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer-service</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost #consul客户端地址</span><br><span class="line">      port: 8500</span><br><span class="line">      retry:</span><br><span class="line">        max-attempts: 3</span><br><span class="line">        initial-interval: 1000</span><br><span class="line">        max-interval: 2000</span><br><span class="line">        multiplier: 1.1</span><br><span class="line">      discovery:</span><br><span class="line">        health-check-interval: 10s #健康检查默认时间间隔</span><br><span class="line">        health-check-path: /actuator/health #健康检查默认请求路径</span><br><span class="line">        health-check-timeout: 5s #超时时间</span><br><span class="line">        #为服务生成一个32位随机字符作为实例名，并非最佳实践</span><br><span class="line">        #instance-id: $&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;</span><br><span class="line">        health-check-tls-skip-verify: true #跳过https校验</span><br><span class="line">        service-name: consumer-service</span><br><span class="line">        heartbeat: </span><br><span class="line">          enabled: true</span><br><span class="line">          ttl-value: 5</span><br><span class="line">          ttl-unit: s</span><br><span class="line">        prefer-ip-address: true #显示真实ip，而不是主机名</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之集群部署</title>
      <link href="/2018/11/18/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/11/18/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h1 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h1><p>根据上一章中的架构图，进行分布式部署</p><p>首先从<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">Consul官网</a>下载最新的安装包, 本文采用1.3.0版本</p><h2 id="服务器列表"><a href="#服务器列表" class="headerlink" title="服务器列表"></a>服务器列表</h2><table><thead><tr><th>节点类型</th><th>名称</th><th>ip</th></tr></thead><tbody><tr><td>server</td><td>server-01</td><td>10.9.188.187</td></tr><tr><td>server</td><td>server-02</td><td>10.9.171.147</td></tr><tr><td>server</td><td>server-03</td><td>10.9.39.37</td></tr><tr><td>client</td><td>client-01</td><td>10.9.181.34</td></tr><tr><td>client</td><td>client-02</td><td>10.9.117.128</td></tr></tbody></table><p>通过wget命令下载Consul到每台服务器中，可以在网页中右键”复制链接”获取下载地址</p><p>下载完成后，通过<code>unzip</code>命令解压</p><h2 id="启动server节点"><a href="#启动server节点" class="headerlink" title="启动server节点"></a>启动server节点</h2><p>启动的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span>=10.9.188.187 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=./data -datacenter=dc1 -node=server-01 &amp;</span><br></pre></td></tr></table></figure><p>新建<code>start.sh</code>，将以上命令拷贝进来，通过<code>sh start.sh</code>命令启动，接下来说明各个参数的含义</p><ol><li>-server：表示以server的身份启动agent</li><li>-bind：集群内部的通信地址，填写本机ip即可</li><li>-client：可以接受通信的客户端地址，<code>0.0.0.0</code>表示接收来自任意ip的客户端</li><li>-bootstrap-expect：预期的server节点数，只有达到了这个数目，才会形成server集群。注意所有server都应该配置一样的值</li><li>-data-dir：保存数据的目录，建议事先新建，server用它持久化集群状态</li><li>-datacenter：所在的数据中心，默认dc1</li><li>-node：节点名称，最终会显示在界面中</li></ol><h2 id="组建集群"><a href="#组建集群" class="headerlink" title="组建集群"></a>组建集群</h2><p>启动3个server节点之后，只是3个孤立的节点，需要用gossip协议互相告知，在Consul中，使用<code>join</code>命令加入集群</p><p>启动第二台server节点之后，就可以join到第一台server，第三台server节点加入任意一个即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul join 第一台的ip</span><br></pre></td></tr></table></figure><p>接着使用<code>members</code>检查集群成员</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul members</span><br></pre></td></tr></table></figure><p>显示3个Type为server的节点集群，同时3台服务的status为alive</p><p><img src="https://ae01.alicdn.com/kf/H7ac7051d086b432baf435d61590453e6K.png" alt=""></p><p>查看Server集群信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul operator raft list-peers</span><br></pre></td></tr></table></figure></p><p>可以看到Leader节点的信息<br><img src="https://ae01.alicdn.com/kf/H3da2a78581064c8aba013eb8ef48bbbfd.png" alt=""></p><h2 id="启动client节点"><a href="#启动client节点" class="headerlink" title="启动client节点"></a>启动client节点</h2><p>启动client的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -<span class="built_in">bind</span>=10.9.181.34 -data-dir=./data -client=0.0.0.0 -node=client-01 -ui &amp;</span><br></pre></td></tr></table></figure><p>参数说明</p><ol><li>-ui：启动ui界面，只需要有一个client加入这个参数即可</li><li>其他参数同 server，</li></ol><p>同样的使用join命令加入agent集群</p><h2 id="ui界面"><a href="#ui界面" class="headerlink" title="ui界面"></a>ui界面</h2><p>打开浏览器，输入10.9.181.34:8500，注意ip是添加了<code>-ui</code>参数的client地址</p><p><img src="https://ae01.alicdn.com/kf/Hea6df032802746ac90e1dea8db1f67632.png" alt="Consul控制台首页"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>Service显示我们的应用服务，其中默认显示了3个Server节点的Consul服务</li><li>Nodes显示所有的agent节点，包括server和client</li><li>K\V是一个key-vlaue存储，可用于分布式锁的实现</li><li>Consul提供了ACL功能，基于ip和port控制请求的畅通</li><li>Intention基于ACL，可以添加服务之间的通信规则，允许或者是禁止通信</li></ol><p>Services中Node Health的含义有些绕，指的是服务所在的agent节点中，通过检查(checks)的个数，check有三个状态：passing(通过), warning(警告),critical(危险)</p><p>节点中的checks包含且不限于健康检查，checks分为节点自身的健康状态检查，注册在节点上的服务的健康状态检查，以及自定义的健康状态检查</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Consul中的启动参数是非常多的，大多数参数都有默认值，完整的参数列表可在<a href="https://www.consul.io/docs/agent/options.html#command-line-options" target="_blank" rel="noopener">Consul 配置</a>中查到。</p><p>Consul按以下3个优先级接收参数：</p><ol><li>命令行参数</li><li>环境变量</li><li>配置文件</li></ol><p>Consul支持json和hcl格式的配置文件，同时也支持指定文件夹的方式，这将按照文件名的词法顺序加载配置文件，例如basic.json先于extra.json加载。后出现的配置项会覆盖前面的配置项</p><p>命令行参数的名称不一定完全和配置文件中的参数名称一样，例如：-node对应node_name</p><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><p>以下是一份配置文件的示例，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"datacenter"</span>: <span class="string">"dc1"</span>,</span><br><span class="line">    <span class="attr">"server"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"bootstrap_expect"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"node_name"</span>: <span class="string">"server-01"</span>,</span><br><span class="line">    <span class="attr">"bind_addr"</span>: <span class="string">"10.9.188.187"</span>,</span><br><span class="line">    <span class="attr">"client_addr"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"data_dir"</span>: <span class="string">"./data"</span>,</span><br><span class="line">    <span class="attr">"log_level"</span>: <span class="string">"INFO"</span>,</span><br><span class="line">    <span class="attr">"ports"</span>: &#123;</span><br><span class="line">        <span class="attr">"dns"</span>: <span class="number">8600</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="number">8500</span>,</span><br><span class="line">        <span class="attr">"server"</span>: <span class="number">8300</span>,</span><br><span class="line">        <span class="attr">"serf_lan"</span>: <span class="number">8301</span>,</span><br><span class="line">        <span class="attr">"serf_wan"</span>: <span class="number">8302</span>,</span><br><span class="line">        <span class="attr">"https"</span>: <span class="number">-1</span>,</span><br><span class="line">        <span class="attr">"grpc"</span>: <span class="number">-1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"start_join"</span>: [<span class="string">"10.9.181.34"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -config-dir=./config &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之初识</title>
      <link href="/2018/11/16/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%9D%E8%AF%86/"/>
      <url>/2018/11/16/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%9D%E8%AF%86/</url>
      <content type="html"><![CDATA[<blockquote><p>Consul是HashiCorp公司推出的开源工具，提供服务发现，健康检查，K/V存储，多数据中心，ACL等功能，同时也是Service Mesh解决方案。</p></blockquote><h1 id="与其它注册中心的对比"><a href="#与其它注册中心的对比" class="headerlink" title="与其它注册中心的对比"></a>与其它注册中心的对比</h1><p>参考博主纯洁的微笑的文章：<a href="http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html" target="_blank" rel="noopener">springcloud(十三)：注册中心 Consul 使用详解</a></p><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>为什么有这一小节呢，本人刚接触到Consul时，对代理(agent)，client, server三者之间的关系没有搞清楚，以下对这几个概念做梳理，帮助新人快速理解</p><ul><li>代理：从Consul官网下载的zip包中，解压后只有一个启动文件，启动之后会运行一个Consul服务，你可以把这个服务理解为agent。agent分为两种，server和client，在启动agent的时候，可以通过参数指定是server还是client</li><li>agent集群：所有server和client节点形成的集群</li><li>server：server主要维护应用服务信息，响应查询，参与一致性选举，与别的数据中心交换信息。</li><li>server集群：server集群中的节点包括一个leader和多个follower，通过raft算法选举leader，保证一致性。server官方推荐的个数是一个数据中心有3或5个节点，一是为了高可用，二是奇数个方便选举，同时要保证server节点的存活数不低于（N/2）+1个，如3个server组成的集群，必须保证2个server存活，5个保证3个存活，否则server集群处于不可用状态</li><li>client：agent的另一种，主要用于转发RPC请求，本身是无状态的，运行在后台维护gossip协议池</li><li>datacenter：笔者对数据中心的理解还十分简陋，大概是机房的意思吧，将Consul部署到多个dc中，增加了可用性</li><li>gossip协议：翻译为流言协议，取自人类社会中的谣言传播，在Consul中用于管理agent和广播消息，在一个agent集群中新加入一个节点，或离开一个节点时，会通过gossip协议告诉集群中的所有节点，Consul的这些gossip协议功能是通过自家的另一个开源产品Serf实现的，这里对Serf要有个印象</li><li>LAN gossip与WAN gossip：分别代表一个数据中心中agent集群之间的的gossip协议，和多个数据中心之间的gossip协议</li></ul><h1 id="Consul的架构"><a href="#Consul的架构" class="headerlink" title="Consul的架构"></a>Consul的架构</h1><p>官网给出了两个数据中心的<a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="noopener">俯视图</a>，为了方便理解，笔者自己画了一个单数据中心的架构图，帮助大家理解</p><p><img src="https://ae01.alicdn.com/kf/H019c969ef42548ed81a4e6c67792a7e34.png" alt="Consul架构"></p><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><ol><li>用3台服务器，部署3个server节点，形成server集群</li><li>每一台应用服务器上部署一个client节点，同时可以部署应用服务，可以是一个，可以是多个，视运维部署规则而定，一般生产环境每台服务器只部署一个应用</li><li>应用服务注册到本机的Consul client，通过它与server集群交互</li></ol><h1 id="Consul原理"><a href="#Consul原理" class="headerlink" title="Consul原理"></a>Consul原理</h1><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在写这一系列的文章时，笔者并不想一开始就实操，而是挈领提纲地介绍了Consul的原理，希望读者有个模糊的印象，在接下来的一步步操作中加深理解。</p>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之请求参数校验</title>
      <link href="/2018/10/14/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2018/10/14/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之请求参数校验"><a href="#Spring-boot实践之请求参数校验" class="headerlink" title="Spring boot实践之请求参数校验"></a>Spring boot实践之请求参数校验</h1><blockquote><p>本文讲述的是后端参数校验，在实际开发中，参数校验是前后端都要做的工作，因为请求接口的人除了普通用户，还有有各路神仙。</p></blockquote><h2 id="常规校验的痛楚"><a href="#常规校验的痛楚" class="headerlink" title="常规校验的痛楚"></a>常规校验的痛楚</h2><p>通常的校验代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入用户名"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还有n个接口需要校验username，你可能会抽取<code>if</code>语句到一个方法中，过段时间你又会发现，不光要校验username，还要password，adress等等一堆字段，总结起来</p><ol><li>重复劳动</li><li>代码冗长，不利于阅读业务逻辑</li><li>出现问题要去不同的接口中查看校验逻辑</li></ol><p>这无疑是件让人崩溃的事情，此时作为一个开发人员，你已经意识到需要一个小而美的工具来解决这个问题，你可以去google，去github搜索这类项目，而不是毫无作为，抑或者是自己去造轮子</p><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><p>JSR303规范应运而生，其中比较出名的实现就是Hibernate Validator，已包含在<code>spring-boot-starter-web</code>其中,不需要重新引入，<code>javax.validation.constraints</code>包下常用的注解有</p><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">@NotNUll</td><td style="text-align:left">值不能为空</td></tr><tr><td style="text-align:left">@Null</td><td style="text-align:left">值必须为空</td></tr><tr><td style="text-align:left">@Pattern(regex=)</td><td style="text-align:left">值必须匹配正则表达式</td></tr><tr><td style="text-align:left">@Size(min=,max=)</td><td style="text-align:left">集合的大小必须在min~max之间，如List，数组</td></tr><tr><td style="text-align:left">@Length(min=,max=)</td><td style="text-align:left">字符串长度</td></tr><tr><td style="text-align:left">@Range(min,max)</td><td style="text-align:left">数字的区间范围</td></tr><tr><td style="text-align:left">@NotBlank</td><td style="text-align:left">字符串必须有字符</td></tr><tr><td style="text-align:left">@NotEmpty</td><td style="text-align:left">集合必须有元素，字符串</td></tr><tr><td style="text-align:left">@Email</td><td style="text-align:left">字符串必须是邮箱</td></tr><tr><td style="text-align:left">@URL</td><td style="text-align:left">字符串必须是url</td></tr><tr><td style="text-align:left">@AssertFalse</td><td style="text-align:left">值必须是false</td></tr><tr><td style="text-align:left">@AssertTrue</td><td style="text-align:left">值必须是true</td></tr><tr><td style="text-align:left">@DecimalMax(value=,inclusive=)</td><td style="text-align:left">值必须小于等于(inclusive=true)/小于(inclusive=false) value属性指定的值。可以注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@DecimalMin(value=,inclusive=)</td><td style="text-align:left">值必须大于等于(inclusive=true)/大f (inclusive=false) value属性指定的值。可以注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@Digits(integer-,fraction=)</td><td style="text-align:left">数字格式检查。integer指定整 数部分的最大长度，fraction指定小数部分的最大长度</td></tr><tr><td style="text-align:left">@Future</td><td style="text-align:left">值必须是未来的日期</td></tr><tr><td style="text-align:left">@Past</td><td style="text-align:left">值必须是过去的日期</td></tr><tr><td style="text-align:left">@Max(value=)</td><td style="text-align:left">值必须小于等于value指定的值。不能注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@Min(value=)</td><td style="text-align:left">值必须大于等于value指定的值。不能注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><h2 id="校验实战"><a href="#校验实战" class="headerlink" title="校验实战"></a>校验实战</h2><p>接下来我们尝试一个入门例子,有一个User java bean, 为username字段加入@NotBlank注解，注意@NotBlank的包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"请输入用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表明将对username字段做非null，非空字符串校验，并为user参数添加@Valid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@RequestBody @Valid User user)</span></span></span><br></pre></td></tr></table></figure><p>按照<a href="">Spring boot实践之编写接口测试用例</a>编写一个测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBlankName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String params = <span class="string">"&#123;\"id\": 101,\"username\": \"\",\"password\": \"1234\"&#125;"</span>;</span><br><span class="line">    mockMvc.perform(post(<span class="string">"/user/login"</span>)</span><br><span class="line">    .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">    .content(params))</span><br><span class="line">    .andExpect(status().isBadRequest());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于参数为空，将返回BadRequest—400响应码，但是此时我们获取不到错误信息，由于spring的拦截，甚至你会发现不进方法断点，仅仅得到一个400响应码，对前端提示错误信息帮助不大，因此我们需要获取错误信息</p><h2 id="获取错误信息"><a href="#获取错误信息" class="headerlink" title="获取错误信息"></a>获取错误信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@Valid @RequestBody User user, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">        result.getFieldErrors().stream().forEach(error -&gt; &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们发现已经进入方法断点</p><p><img src="https://ae01.alicdn.com/kf/H954c71c251af4bbbb3b337fb595cdaa5c.png" alt="进入断点"></p><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>继续优化，想必大家也发现了，难道每个方法都要写<code>if</code>? 当然不用，ControllerAdvice不就是专门封装错误信息的吗，仿照<a href="">异常处理</a>中的处理方式，我们很容易写出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;MethodArgumentNotValidException.class&#125;)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseModel <span class="title">exception</span><span class="params">(MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">    ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">    model.setCode(HttpStatus.BAD_REQUEST.value());</span><br><span class="line">    model.setMsg(buildErrorMessage(ex));</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildErrorMessage</span><span class="params">(MethodArgumentNotValidException ex)</span></span>&#123;</span><br><span class="line">    List&lt;ObjectError&gt; objectErrors = ex.getBindingResult().getAllErrors();</span><br><span class="line">    StringBuilder messageBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    objectErrors.stream().forEach(error -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(error <span class="keyword">instanceof</span> FieldError)&#123;</span><br><span class="line">            FieldError fieldError = (FieldError) error;</span><br><span class="line">            messageBuilder.append(fieldError.getDefaultMessage()).append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    String message  = messageBuilder.deleteCharAt(messageBuilder.length() - <span class="number">1</span>).toString();</span><br><span class="line">    log.error(message);</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>除了使用<code>@ExceptionHandler</code>来捕获<code>MethodArgumentNotValidException</code>以外，还可以覆盖<code>ResponseEntityExceptionHandler</code>抽象类的handleMethodArgumentNotValid方法，但是二者不可以混用</p><h2 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h2><p>由于JSR303提供的注解有限，实际开发过程中校验往往需要结合实际需求，JSR303提供了自定义校验扩展接口</p><p>典型的一个请求场景是枚举类型参数，假设用户分为3类: 普通用户，VIP玩家，氪金玩家，分别用1，2，3表示，此时如何校验前端传入的值在范围内，抖机灵的朋友可能会想到@Range，万一是离散的不连续数呢？</p><p>自定义注解类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 指定校验类</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = InValidator.class)</span><br><span class="line"><span class="meta">@Target</span>( &#123; ElementType.METHOD, ElementType.FIELD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> In &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "必须在允许的数值内"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] values();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于分组校验</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的校验器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">In</span>, <span class="title">Number</span>&gt; </span>&#123;<span class="comment">// 校验Number类型 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; inValues;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(In in)</span> </span>&#123; </span><br><span class="line">    inValues = Sets.newHashSet();</span><br><span class="line">    <span class="keyword">int</span>[] arr = in.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">       inValues.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Number propertyValue, ConstraintValidatorContext cxt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyValue==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> inValues.contains(propertyValue.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，生产级别的参数校验基本完成</p><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>在不同接口中，指定不同的校验规则，如：</p><ol><li>不同的接口，校验不同的字段</li><li>同一个字段，在不同的接口中有不同的校验规则</li></ol><p>以下实现第一种情况</p><p>首先定义两个空接口，代表不同的分组，也就是不同的业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewUser</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RMBUser</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在指定校验规则时，指定分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(groups = &#123;NewUser.class&#125;, message = <span class="string">"请输入密码"</span>)   </span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@In</span>(groups = &#123;RMBUser.class&#125;, values = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, message = <span class="string">"非法的用户类型"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同的接口指定不同的校验分组"><a href="#不同的接口指定不同的校验分组" class="headerlink" title="不同的接口指定不同的校验分组"></a>不同的接口指定不同的校验分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略类定义...</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"normal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">normal</span><span class="params">(@Validated(&#123;NewUser.class&#125;)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"rmb"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">rmb</span><span class="params">(@Validated(&#123;RMBUser.class&#125;)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试用例</p><p>只检验密码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String params = <span class="string">"&#123;\"id\": 101,\"username\": \"tom\",\"password\": \"\",\"type\": \"5\"&#125;"</span>;</span><br><span class="line">       String result = mockMvc.perform(post(<span class="string">"/user/normal"</span>)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">               .content(params))</span><br><span class="line">               .andExpect(status().isBadRequest())</span><br><span class="line">               .andReturn().getResponse().getContentAsString();</span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：<code>{&quot;data&quot;:null,&quot;code&quot;:400,&quot;msg&quot;:&quot;请输入密码&quot;}</code><br>只检验用户类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRMB</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String params = <span class="string">"&#123;\"id\": 101,\"username\": \"tom\",\"password\": \"\",\"type\": \"5\"&#125;"</span>;</span><br><span class="line">       String result = mockMvc.perform(post(<span class="string">"/user/rmb"</span>)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">               .content(params))</span><br><span class="line">               .andExpect(status().isBadRequest())</span><br><span class="line">               .andReturn().getResponse().getContentAsString();</span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：<code>{&quot;data&quot;:null,&quot;code&quot;:400,&quot;msg&quot;:&quot;非法的用户类型&quot;}</code></p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之异常处理</title>
      <link href="/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之异常处理"><a href="#Spring-boot实践之异常处理" class="headerlink" title="Spring boot实践之异常处理"></a>Spring boot实践之异常处理</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一章<a href="">封装返回体</a>中，已经对请求成功的情况进行了封装，接下来便是处理异常，服务的生产者需要通过状态码此次请求是否成功，出现异常时，错误信息是什么，形如:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"FAILED"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常接口"><a href="#异常接口" class="headerlink" title="异常接口"></a>异常接口</h2><p>可以看出只需要<code>code</code>与<code>msg</code>, 参考 <code>org.springframework.http.HttpStatus</code>的实现，我们可以定义一个枚举来封装错误信息，对外暴露<code>getCode</code>，<code>getMsg</code>方法即可。由于异常属于一个基础模块，将这两个方法抽象到一个接口中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExceptionEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Integer <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常枚举"><a href="#异常枚举" class="headerlink" title="异常枚举"></a>异常枚举</h3><p>以用户模块为例，所有用户相关的业务异常信息封装到<code>UserError</code>中，例如用户不存在，密码错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserError implements ExceptionEntity &#123;</span><br><span class="line"></span><br><span class="line">    NO_SUCH_USER(<span class="number">1</span>, <span class="string">"用户不存在"</span>),</span><br><span class="line">    ERROR_PASSWORD(<span class="number">2</span>, <span class="string">"密码错误"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer MODULE = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    UserError(Integer code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MODULE + <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h4><p>需要注意的地方是笔者定义了一个<code>MODULE</code>字段，10000代表用户微服务，这样在拿到错误信息之后，可以很快定位报错的应用</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// lombok自动生成构造方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    ExceptionEntity error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是错误接口与自定义异常属于公共模块，而<code>UserError</code>属于用户服务</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>之后，便可以抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(UserError.ERROR_PASSWORD);</span><br></pre></td></tr></table></figure><p>目前来看，我们只是较为优雅的封装了异常，此时请求接口返回的仍然是Spring boot默认的错误体，没有错误信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="string">"2018-10-18T12:28:59.150+0000"</span>,</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"No message available"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/user/error"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>接下来的异常拦截方式，各路神仙都有自己的方法，笔者只说Spring boot项目中比较通用的<code>@ControllerAdvice</code>，由于是Restful接口，这里使用<code>@RestControllerAdvice</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这属于基础模块，扫描路径不要包含具体的模块，用..代替</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>(basePackages=<span class="string">"com.ttyc..controller"</span>,annotations=&#123;RestController.class&#125;)</span><br><span class="line"><span class="comment">// lombok的日志简写</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionAdvisor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;ServiceException.class&#125;)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseModel <span class="title">handleServiceException</span><span class="params">(ServiceException ex)</span></span>&#123;</span><br><span class="line">        Integer code = ex.getError().getCode();</span><br><span class="line">        String msg = ex.getError().getMsg();</span><br><span class="line">        log.error(msg);</span><br><span class="line"></span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(code);</span><br><span class="line">        model.setMsg(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其他错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;Exception.class&#125;)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseModel <span class="title">exception</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> code = HttpStatus.INTERNAL_SERVER_ERROR.value();</span><br><span class="line">        String msg = HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase();</span><br><span class="line">        log.error(msg);</span><br><span class="line"></span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(code);</span><br><span class="line">        model.setMsg(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具有争议的一点是捕获<code>ServiceExcption</code>之后，应该返回200还是500的响应码，有的公司返回200，使用<code>code</code>字段判断成功失败，这完全没有问题，但是按照Restful的开发风格，这里的<code>@ResponseStatus</code>笔者返回了500，请读者根据自身情况返回响应码</p><h3 id="测试接口与测试用例"><a href="#测试接口与测试用例" class="headerlink" title="测试接口与测试用例"></a>测试接口与测试用例</h3><h4 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抛出业务异常示例</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(UserError.NO_SUCH_USER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testError</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String result =</span><br><span class="line">            mockMvc.perform(get(<span class="string">"/user/error"</span>))</span><br><span class="line">                    .andExpect(status().isInternalServerError())</span><br><span class="line">                    .andReturn().getResponse().getContentAsString();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"code"</span>: <span class="number">10001</span>,</span><br><span class="line"><span class="attr">"msg"</span>: <span class="string">"用户不存在"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之编写接口测试用例</title>
      <link href="/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
      <url>/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之编写接口测试用例"><a href="#Spring-boot实践之编写接口测试用例" class="headerlink" title="Spring boot实践之编写接口测试用例"></a>Spring boot实践之编写接口测试用例</h1><blockquote><p> 测试用例对开发者降低bug率,方便测试人员回归测试有十分重要的意义。</p></blockquote><p>本文介绍如何使用<code>MockMvc</code>编写测试用例. </p><p>在Spring boot项目中编写测试用例十分简单，通常建立一个Spring boot项目都会test目录下生成一个Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以用户查询为例，通常有一个用户实体，以及<code>UserController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Data注解来自lombok</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getInfo方法是一个restful接口，模拟查询用户详情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"info"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getInfo</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>, required = <span class="keyword">true</span>)</span> String username)</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(username + <span class="string">"s"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下通过MockMvc对象，测试<code>/user/info}</code>请求是否成功，并符合预期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入上下文对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化mockMvc对象</span></span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result =</span><br><span class="line">                <span class="comment">//执行get请求，这里有个小坑，第一个/必须有</span></span><br><span class="line">                mockMvc.perform(get(<span class="string">"/user/info"</span>)</span><br><span class="line">                        <span class="comment">//设置content-type请求头</span></span><br><span class="line">                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                        <span class="comment">//设置参数  </span></span><br><span class="line">                        .param(<span class="string">"name"</span>, <span class="string">"jay"</span>))</span><br><span class="line">                        <span class="comment">//预期的相应码是200-ok</span></span><br><span class="line">                        .andExpect(status().isOk())</span><br><span class="line">                        <span class="comment">//预测username的值为jays</span></span><br><span class="line">                        .andExpect(jsonPath(<span class="string">"$.username"</span>).value(<span class="string">"jays"</span>))</span><br><span class="line">                        <span class="comment">//获取响应体</span></span><br><span class="line">                        .andReturn().getResponse().getContentAsString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过测试，并输出响应体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">101</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"jays"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"1234"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>$.id</code>jsonpath的使用，参考<a href="https://github.com/json-path/JsonPath" target="_blank" rel="noopener">JsonPath</a></p><p>同时付一段使用json参数的post请求方式，大同小异，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String params = <span class="string">"&#123;\"id\": 101,\"username\": \"jason\",\"password\": \"1234\"&#125;"</span>;</span><br><span class="line">mockMvc.perform(post(<span class="string">"/user/login"</span>)</span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">        .content(params))</span><br><span class="line">        .andExpect(status().isOk());</span><br></pre></td></tr></table></figure><p>注意后端接受json格式参数的方式：<code>方法名(@RequestBody User user)</code> </p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之封装返回体</title>
      <link href="/2018/10/11/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BD%93/"/>
      <url>/2018/10/11/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BD%93/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之封装返回体"><a href="#Spring-boot实践之封装返回体" class="headerlink" title="Spring boot实践之封装返回体"></a>Spring boot实践之封装返回体</h1><p>在实际开发中，一个项目会形成一套统一的返回体接口规范，常见的结构如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"SUCCESS"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: 真正的数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以根据自己的实际情况封装一个java bean，刑如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseModel</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring boot中，会将返回的实体类，通过jackson自动转换成json</p><p>Spring提供了<code>ResponseBodyAdvice</code>接口拦截响应体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseAdvisor</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Class aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MethodParameter methodParameter, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  MediaType mediaType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class aClass, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpRequest serverHttpRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpResponse serverHttpResponse)</span> </span>&#123;</span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(<span class="number">0</span>);</span><br><span class="line">        model.setData(body);</span><br><span class="line">        model.setMsg(<span class="string">"SUCCESS"</span>);</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是一个最初的功能，值得优化的地方有很多，读者应根据自己的情况进行扩展</p><p>根据笔者遇到的情况，抛砖引玉一下</p><ol><li>是否需要对所有的响应拦截，可以在supports方法中判断</li><li>下载返回的是字节数据，再进行包装必然得不到正确的文件，不应该进行包装</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列:微服务注册中心——Eureka入门</title>
      <link href="/2018/09/10/Spring-Cloud%E7%B3%BB%E5%88%97-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%94%E2%80%94Eureka%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/10/Spring-Cloud%E7%B3%BB%E5%88%97-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%94%E2%80%94Eureka%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>作为一个没有经验的开发人员(捂脸），在了解Eureka之前，我更想让读者带着问题去思考</p><ol><li>什么是微服务注册中心，微服务为什么需要注册中心</li><li>注册中心都实现了哪些功能</li><li>开源的注册中心有哪些，为什么要选Eureka，优缺点有哪些</li><li>生产环境中的注册中心如何部署</li></ol><p>这些想法都是我敲完代码想要思考的，搭建一个注册中心几分钟的事，实在没什么技术含量，感觉收获到的东西太少，需要沉下来多思考</p><p>以下是Eureka server单机伪集群的配置方式：</p><p>1.首先Spring boot项目，加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>2.配置文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line">spring:</span><br><span class="line">  profiles: master</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-master</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer2:8001/eureka/</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">  server:</span><br><span class="line">    eviction-interval-timer-in-ms: 10000 # 每10s就去清理无效的实例</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">spring:</span><br><span class="line">  profiles: slave</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-slave</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer1:8000/eureka/</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">  server:</span><br><span class="line">    eviction-interval-timer-in-ms: 10000 # 每10s就去清理无效的实例</span><br><span class="line">    enable-self-preservation: false</span><br></pre></td></tr></table></figure></p><p>虽然复制粘贴到你的项目是件易事，不过有几个配置点笔者还是想要详细说一下：</p><ol><li>hostname配置了peer1、peer2，这是在模拟集群环境，需要读者自己在hosts文件中添加映射，<br><code>127.0.0.1     localhost peer1 peer2</code>.如果你的内存够大，也可以用两台虚拟机</li><li>对于Eureka来说，无效的实例是通过定时任务去清除的，默认是60s，这里我设置为了10s</li><li>IDEA中通过一个项目启动Eureka集群,通过spring.profiles.active区分配置<br><img src="https://ae01.alicdn.com/kf/H4cb1c76c66ea4fedafb4c02b608c5934u.png" alt="点击Edit Configurations"><br><img src="https://ae01.alicdn.com/kf/Hf5c9b7738f2d41bbaee7716cb9545eadV.png" alt="点击加号新增Spring boot"></li></ol>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列: Spring Boot Admin</title>
      <link href="/2018/09/07/Spring-Cloud%E7%B3%BB%E5%88%97-Spring-Boot-Admin/"/>
      <url>/2018/09/07/Spring-Cloud%E7%B3%BB%E5%88%97-Spring-Boot-Admin/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了Spring Boot Admin的使用，参考Spring Boot Admin 2.0.2版本(以下简称SBA，来自官方)官方文档，主要实现了其中案例，也包括一些自己的想法</p><p>文档地址：<a href="http://codecentric.github.io/spring-boot-admin/current/" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/current/</a></p><p>以下文章内容的例子都可以在我的<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack" target="_blank" rel="noopener">GitHub</a>找到</p><h1 id="Spring-Boot-Admin介绍"><a href="#Spring-Boot-Admin介绍" class="headerlink" title="Spring Boot Admin介绍"></a>Spring Boot Admin介绍</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>SBA是一个用于管理和监控Spring Boot项目的工具，包括线程，内存，Spring bean加载情况，日志等一系列可视化界面</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>熟悉Spring Boot的读者都知道Spring Boot actuator这款组件，它使用HTTP端点或JMX来管理和监控应用程序，但是没有提供图形化界面，仅仅提供了JSON格式的数据，同时无法做到集中管理应用，对运维十分不友好，SBA基于actuator不但解决了这些痛点，并且通过扩展实现了很多强大的功能，如日志级别动态更改，查看实时日志，查看URL映射等等，对管理微服务十分有意义</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>环境的搭建将配合注册中心Eureka，当然也可以不使用注册中心，参考<a href="http://codecentric.github.io/spring-boot-admin/current/#set-up-admin-server" target="_blank" rel="noopener">Spring Boot Admin Server</a>一节,或使用别的注册中心，如<a href="http://cloud.spring.io/spring-cloud-consul/" target="_blank" rel="noopener">Consul</a>，Zookeeper，这些官方都已经在github给出了<a href="https://github.com/codecentric/spring-boot-admin/tree/master/spring-boot-admin-samples" target="_blank" rel="noopener">案例</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>服务端和客户端均加入了spring-security组件，同时都配置了关闭请求拦截和跨域防范，详见笔者的GitHub<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack" target="_blank" rel="noopener">Spring-Cloud-Stack</a>项目，<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-server" target="_blank" rel="noopener">admin-server</a>和<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-client" target="_blank" rel="noopener">admin-client</a>模块<br><strong>注意：</strong> 按常理IDEA在勾选依赖生成项目之后，会加入bom版本管理，可是笔者也遇到了没有自动生成的情况，请读者注意pom文件是否有以下内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="SBA-服务端"><a href="#SBA-服务端" class="headerlink" title="SBA 服务端"></a>SBA 服务端</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注册Eureka并添加-EnableAdminServer注解"><a href="#注册Eureka并添加-EnableAdminServer注解" class="headerlink" title="注册Eureka并添加@EnableAdminServer注解"></a>注册Eureka并添加@EnableAdminServer注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminServerApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(AdminServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-security配置"><a href="#spring-security配置" class="headerlink" title="spring-security配置"></a>spring-security配置</h3><p><code>anyRequest.permitAll</code>表示允许所有请求通过校验<br><code>csrf.disable</code>表示关闭跨域防范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityPermitAllConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().permitAll()  </span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><p>简要说明: 主要配置端口，eureka，必须暴露所有web actuator断点，生产环境考虑到安全性，应当酌情开放，最后配置了spring-security的用户名和密码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8115</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8000/eureka/,http://localhost:8001/eureka/</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">  endpoint:</span></span><br><span class="line"><span class="attr">    health:</span></span><br><span class="line"><span class="attr">      show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    user:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><h2 id="SBA-客户端"><a href="#SBA-客户端" class="headerlink" title="SBA 客户端"></a>SBA 客户端</h2><h2 id="pom依赖-1"><a href="#pom依赖-1" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-Security配置"><a href="#Spring-Security配置" class="headerlink" title="Spring-Security配置"></a>Spring-Security配置</h2><p><a href="#spring-security配置">同服务端</a></p><h2 id="yml配置-1"><a href="#yml配置-1" class="headerlink" title="yml配置"></a>yml配置</h2><p>这里提一个小坑点, server的地址必须加<strong>http://</strong> 前缀，否则会在启动日志中看到WARN，注册失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8116</span><br><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8115</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: user</span><br><span class="line">      password: admin</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: ALWAYS</span><br></pre></td></tr></table></figure><h1 id="最初效果"><a href="#最初效果" class="headerlink" title="最初效果"></a>最初效果</h1><p>在启动注册中心，以及服务端，客户端之后，打开<a href="http://localhost:8115" target="_blank" rel="noopener">http://localhost:8115</a>，输入配置的用户名和密码即可登录</p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>java.io.IOException: Broken pipe, SBA 的issue中有回复：</p><p>This is a quite normal. The browser does some long polling and keeps the tcp connection open. If the browser window is closed the tcp connection is aborted and on the next write the exception is thrown. there is nothing to do about this, except changing the loglevel.<br>这是很正常的。浏览器执行一些长轮询并保持TCP连接打开。如果浏览器窗口关闭，则中止TCP连接，并在下一次写入时抛出异常。除了更改日志级别之外，这没有什么可做的。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="UI配置"><a href="#UI配置" class="headerlink" title="UI配置"></a>UI配置</h2><h3 id="如何显示项目的版本号"><a href="#如何显示项目的版本号" class="headerlink" title="如何显示项目的版本号"></a>如何显示项目的版本号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  version: @project.version@</span><br></pre></td></tr></table></figure><p>此处的project.version引用了maven中的变量</p><p>效果图如下</p><p><img src="https://ae01.alicdn.com/kf/H333f7d74baad4ccc92a57ed4a6d88fa9u.png" width="65%" align="left"></p><h2 id="查看实时滚动日志"><a href="#查看实时滚动日志" class="headerlink" title="查看实时滚动日志"></a>查看实时滚动日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  file: client.log</span><br></pre></td></tr></table></figure><p>配置日志文件位置即可，根据官方文档说明，SBA可以自动检测出url链接，同时支持日志颜色配置，但是项目启动时报错，遂放弃之<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.pattern.file=%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr(%5p) %clr($&#123;PID&#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n%wEx</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>日志效果如下图：<br><img src="https://ae01.alicdn.com/kf/H61eae22c490944e195e0ed73a306cb62J.png" width="65%" align="left"></p><p>可以看到提供了下载按钮，其实是打开了一个网页页签，可复制出来，中文日志会出现乱码</p><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>tag可以给每一个客户端标识，有两种途径加入tag:</p><h3 id="1-元数据"><a href="#1-元数据" class="headerlink" title="1. 元数据"></a>1. 元数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8115</span><br><span class="line">        instance:</span><br><span class="line">          metadata:</span><br><span class="line">            tags:</span><br><span class="line">              content: mesh</span><br></pre></td></tr></table></figure><h3 id="2-info端点"><a href="#2-info端点" class="headerlink" title="2. info端点"></a>2. info端点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  tags:</span><br><span class="line">    title: mosi</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/H8f6d48f10cc04dc898df3e62d109b7258.png" width="65%" align="left"></p><p><strong>值得注意的是，两种方式的k-v表现形式, 第一个是tags.content为key，第二个是tags为key</strong></p><h2 id="静态配置客户端"><a href="#静态配置客户端" class="headerlink" title="静态配置客户端"></a>静态配置客户端</h2><p>这一小节的内容单独用了两个项目，分别是<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-static-client" target="_blank" rel="noopener">admin-static-client</a>，<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-static-server" target="_blank" rel="noopener">admin-static-server</a></p><p>通过Spring Cloud提供的静态配置，SBA支持静态配置client，首先建立客户端项目，只需要web，actuator两个依赖即可，</p><p>server端将Eureka依赖改为如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>接下来配置客户端的地址等信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    discovery:</span><br><span class="line">      client:</span><br><span class="line">        simple:</span><br><span class="line">          instances:</span><br><span class="line">            admin-static-client:</span><br><span class="line">              - uri: http://localhost:8117</span><br><span class="line">                metadata:</span><br><span class="line">                  management.context-path: /actuator</span><br></pre></td></tr></table></figure></p><p>admin-static-client将是在界面上显示的客户端地址</p><h1 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h1><h2 id="邮件提醒"><a href="#邮件提醒" class="headerlink" title="邮件提醒"></a>邮件提醒</h2><p>当注册在SBA server上的应用出现DOWN/OFFLINE等情况时，需要通过告警的方式告知运维人员，而邮件告警是常用的方式之一，SBA支持邮件告警，使用了spring-boot-mail组件来完成这一功能，需要在server端做以下工作：</p><p><strong>注: </strong> 以下邮件有关内容,通常情况需要获取授权码，以qq邮箱为例，请参照<a href="http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256" target="_blank" rel="noopener">http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256</a>获取授权码</p><h3 id="pom中加入依赖"><a href="#pom中加入依赖" class="headerlink" title="pom中加入依赖"></a>pom中加入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="需要的配置如下"><a href="#需要的配置如下" class="headerlink" title="需要的配置如下"></a>需要的配置如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">boot:</span><br><span class="line">  admin:</span><br><span class="line">    ui:</span><br><span class="line">      title: &quot;Spring Boot Admin监控管理中心&quot;</span><br><span class="line">    notify:</span><br><span class="line">      mail:</span><br><span class="line">        from: 发送方</span><br><span class="line">        to: 收件方，多个逗号分隔</span><br><span class="line">        cc: 抄送，多个逗号分隔</span><br><span class="line">        template: classpath:/META-INF/spring-boot-admin-server/mail/status-changed.html # 定制邮件模板，请参考官方实现</span><br><span class="line">mail:</span><br><span class="line">  host: smtp.qq.com</span><br><span class="line">  port: 25</span><br><span class="line">  username: 发送方用户名</span><br><span class="line">  password: 授权码</span><br><span class="line">  protocol: smtp</span><br><span class="line">  test-connection: false</span><br><span class="line">  properties:</span><br><span class="line">    mail:</span><br><span class="line">      smtp:</span><br><span class="line">        auth: true</span><br><span class="line">        starttls:</span><br><span class="line">          enable: true</span><br><span class="line">          required: true</span><br></pre></td></tr></table></figure><h3 id="最终收到的邮件如图"><a href="#最终收到的邮件如图" class="headerlink" title="最终收到的邮件如图"></a>最终收到的邮件如图</h3><p>将客户端下线之后，收到的邮件如下<br><img src="https://ae01.alicdn.com/kf/H20620d2d3d824685bbbe9970ca308c9e9.png" width="65%" align="left"></p><p>余下的第三方应用接入以及安全防护不再介绍，直接进入自定义通知</p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p>当应用(实例)宕机时，服务端应该主动通知运维人员，达到告警的作用，在SBA中提供了这样的扩展，可以继承<code>AbstractEventNotifier</code>或<code>AbstractStatusChangeNotifier</code>，由于二者属于继承关系，读者直接继承AbstractStatusChangeNotifier即可</p><p><strong>注: </strong>通知的方式有很多种，如钉钉，邮件，短信，大家按需扩展即可，以邮件举例，注入<code>JavaMailSender</code>对象即可实现邮件报警</p><p>下面给出一个告警样例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNotifier</span> <span class="keyword">extends</span> <span class="title">AbstractStatusChangeNotifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger LOGGER = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNotifier</span><span class="params">(InstanceRepository repositpry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(repositpry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">doNotify</span><span class="params">(InstanceEvent event, Instance instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> InstanceStatusChangedEvent) &#123;</span><br><span class="line">                StatusInfo statusInfo = ((InstanceStatusChangedEvent) event).getStatusInfo();</span><br><span class="line">                String status = statusInfo.getStatus();</span><br><span class="line">                Map&lt;String, Object&gt; details = statusInfo.getDetails();</span><br><span class="line">                String detailStr = details.toString();</span><br><span class="line">                <span class="keyword">boolean</span> isOffline = statusInfo.isOffline();</span><br><span class="line">                LOGGER.info(<span class="string">"status info are: status:&#123;&#125;, detail:&#123;&#125;, isOffline:&#123;&#125;"</span>, status, detailStr, isOffline);</span><br><span class="line"></span><br><span class="line">                String mavenVersion = instance.getBuildVersion().getValue();</span><br><span class="line">                String healthUrl = instance.getRegistration().getHealthUrl();</span><br><span class="line">                LOGGER.info(<span class="string">"instance build version is &#123;&#125;, health check url is &#123;&#125;"</span>, mavenVersion, healthUrl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取事件信息，instance(客户端)信息，包括前面说过的元信息，可用来发钉钉消息，短信等等的通知</span></span><br><span class="line">                LOGGER.info(<span class="string">"Instance &#123;&#125; (&#123;&#125;) is &#123;&#125;"</span>, instance.getRegistration().getName(), event.getInstance(),</span><br><span class="line">                        ((InstanceStatusChangedEvent) event).getStatusInfo().getStatus());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"Instance &#123;&#125; (&#123;&#125;) &#123;&#125;"</span>, instance.getRegistration().getName(), event.getInstance(),</span><br><span class="line">                        event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>最后聊聊一些细节内容，读者有需求的可深入了解</p><ol><li>对于监控的url请求，可以<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-headers" target="_blank" rel="noopener">添加header</a>，并对request，response<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-instance-filter" target="_blank" rel="noopener">拦截</a></li><li>使用2.0的服务端监控1.5版本的spring boot客户端，需要做一些<a href="http://codecentric.github.io/spring-boot-admin/current/#monitoring-spring-boot-1.5.x" target="_blank" rel="noopener">兼容处理</a></li><li>扩展UI，由于2.0使用了Vue.js重构，可以很方便的<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-custom-views" target="_blank" rel="noopener">扩展</a></li></ol><p>完结撒花</p>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 监控 </tag>
            
            <tag> 官方文档阅读 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud Sleuth 官方文档阅读</title>
      <link href="/2018/08/29/Spring-Cloud-Sleuth-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/"/>
      <url>/2018/08/29/Spring-Cloud-Sleuth-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>Spring Cloud Sleuth 版本 2.x</p><p>文档地址：<a href="http://cloud.spring.io/spring-cloud-sleuth/2.0.x/single/spring-cloud-sleuth.html" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-sleuth/2.0.x/single/spring-cloud-sleuth.html</a></p><h2 id="遇到的英文单词"><a href="#遇到的英文单词" class="headerlink" title="遇到的英文单词"></a>遇到的英文单词</h2><ul><li>reveals: 揭示</li><li>network latency: 网络延迟</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>一次请求中每个微服务的处理过程叫一个span，可以理解为一次请求链路中的最小单元，用一个64位的唯一ID标识，span中有若干描述信息，如：ID，产生的时间戳，IP地址，服务名等</p><p>如果是入口服务，那么span的id等于trace id</p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>一次请求经过若干个微服务，汇总每一个服务的span，最终形成一个树状的数据结构</p><h3 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h3><p>用来记录事件信息，表示请求的开始和结束，主要包含以下4个：</p><ol><li>cs:client send 客户端发起请求，标识一个span的开始</li><li><p>sr:server received 服务端接收请求，开始处理请求，此时产生的ts(时间戳，以下统称为ts)减去cs的ts，可以计算出网络传输时间</p></li><li><p>ss:server send 服务端处理结束，开始响应客户端，此时的ts减去sr的ts，就是服务端请求处理时间</p></li><li>cr:client received 客户端接收到服务端的响应，此时的ts减去cs的ts，就是一次请求所消耗的时间</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 监控 </tag>
            
            <tag> 官方文档阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux命令手记</title>
      <link href="/2018/08/27/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E8%AE%B0/"/>
      <url>/2018/08/27/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="从后往前查看日志"><a href="#从后往前查看日志" class="headerlink" title="从后往前查看日志"></a>从后往前查看日志</h2><ol><li>less 文件名</li><li>shift+g跳转到末尾，向上滑动</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>首先不推荐cat,vim等命令,大日志文件容易导致内存不足，线上排查问题时容易引起服务崩溃</p><p>有时想要查看最后五分钟内的日志，tail命令指定行数也可以大致做到，但是行数不好指定时，less会很方便</p><h2 id="查找进程命令如何排除自带的grep"><a href="#查找进程命令如何排除自带的grep" class="headerlink" title="查找进程命令如何排除自带的grep"></a>查找进程命令如何排除自带的grep</h2><p>这个技巧常用在编写shell脚本时，希望查找到某个进程的pid，但是grep命令本身也会产生一条数据，因此需要排除<br>例如查找xxx进程时<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep xxx |grep -v <span class="string">'grep'</span></span><br></pre></td></tr></table></figure></p><h2 id="查看前十个最占内存的应用"><a href="#查看前十个最占内存的应用" class="headerlink" title="查看前十个最占内存的应用"></a>查看前十个最占内存的应用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head</span><br></pre></td></tr></table></figure><h2 id="查看前十个最占CPU的应用"><a href="#查看前十个最占CPU的应用" class="headerlink" title="查看前十个最占CPU的应用"></a>查看前十个最占CPU的应用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep -v PID|sort -rn -k 3| head | awk <span class="string">'BEGIN&#123;print "USER PID %CPU %MEM VSZ RSS STAT"&#125; &#123;print $1,$2,$3,$4,$5,$6,$8&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="按端口终止进程"><a href="#按端口终止进程" class="headerlink" title="按端口终止进程"></a>按端口终止进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">PORT=2181</span><br><span class="line">PID=`lsof -i:<span class="variable">$&#123;PORT&#125;</span> |grep -v PID |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;PID&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"kill pid : <span class="variable">$&#123;PID&#125;</span>"</span></span><br><span class="line">        <span class="built_in">kill</span> <span class="variable">$&#123;PID&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"could not find process with port:<span class="variable">$&#123;PORT&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="生成UUID"><a href="#生成UUID" class="headerlink" title="生成UUID"></a>生成UUID</h2><p>uuidgen命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uuidgen</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d4586ba5-22da-42e5-9662-acad5942988d</span><br></pre></td></tr></table></figure><h2 id="启动shell脚本"><a href="#启动shell脚本" class="headerlink" title="启动shell脚本"></a>启动shell脚本</h2><p>编写shell脚本之后，可以通过<code>chmod +x</code>的方式，然后启动，不过用<code>sh 脚本名</code>的方式更加简洁，目前没有对比二者的优劣</p><h2 id="查找占用磁盘空间的文件"><a href="#查找占用磁盘空间的文件" class="headerlink" title="查找占用磁盘空间的文件"></a>查找占用磁盘空间的文件</h2><p>一层一层目录查找最占磁盘空间的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure><h2 id="top命令技巧"><a href="#top命令技巧" class="headerlink" title="top命令技巧"></a>top命令技巧</h2><p>shift+p: 按CPU使用率降序排序，用户查找CPU使用率最高的进程<br>shift+m: 按内存使用率降序排序<br>shift+h: 显示线程占用cpu情况</p><p>top -p <pid> -H ：查看进程中各线程详情</pid></p><h2 id="netstat命令技巧"><a href="#netstat命令技巧" class="headerlink" title="netstat命令技巧"></a>netstat命令技巧</h2><p>按pid统计连接数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -natp|awk <span class="string">'print $7'</span>|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure></p><h2 id="awk入门"><a href="#awk入门" class="headerlink" title="awk入门"></a>awk入门</h2><p>test.txt<br>red,10,jay<br>black,20,tom<br>yellow,30,jim</p><p>awk -F “,” ‘$3&gt;15 {print $1,$2}’ test.txt<br>持续积累中 ……</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列前言</title>
      <link href="/2018/08/10/Spring-Cloud%E7%B3%BB%E5%88%97%E5%89%8D%E8%A8%80/"/>
      <url>/2018/08/10/Spring-Cloud%E7%B3%BB%E5%88%97%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>笔者一些无聊的思考，也有一些对新手的建议</p><ol><li>了解一个新技术之前，它为什么出现，解决了什么问题，和现有的解决方案相比，它有什么优点，又有什么缺点(没有完美的方案)</li><li>DevOps，微服务dev易，ops难，有哪些技术可以实现ops，做到可持续交付，微服务的监控，管理怎么做，如何减少排查问题的复杂度</li><li>微服务如何根据业务拆分模块</li><li>Spring Cloud如何实现真正意义上的多语言，不要觉得公司只用java，同时用PHP，Go，Python太正常了，举个例子，阿里收购个公司，发现用的不是java就不收购了？收购之后要整合业务就让别人全改成java吗，现有的”老”系统重做吗</li><li>一口就吃个大胖子，一套框架解决公司所有业务？不可能的，架构应该遵循演进式原则</li><li>如何去学习Spring Cloud，由于Spring Boot 1.x版本和2.x版本的差别较大，往往因为一些教程的版本落后让人痛不欲生，所以自己摸索是一方面，比如找最新的教程，遇到问题多看官方文档也是个好习惯</li><li>关于看英文文档，只是一个适应的过程，下载一个有道翻译，只要有一些英语基础的人都能看懂，ps:本人四级考了2次飘过的学渣，:)逃，看多英文文档之后，甚至有种看不进去中文翻译的感觉，因为不好理解，还不如看英文，虽然浪费点时间，但是理解的快</li><li>关于遇到问题如何解决这件事，给新人一些建议，不要问leader一些很low的问题，我本人属于内向的人，习惯do my best之后再去问人，说下我的解决思路<ol><li>首先尽量看懂英文的错误提示</li><li>百度能帮你解决很多”常见”的问题</li><li>百度也不是个好东西，遇到难题，就会发现天下文章一大抄，抄来抄去就那么几篇</li><li>谷歌，多留意Stack Overflow的网站，同样需要你有耐心看懂英文</li><li>既然是开源项目，为什么不去github的issue搜一搜，笔者很喜欢这样做，不急的问题搜不到提个issue也比去某个论坛强</li><li>现在Github流行gitter在线聊天，可以更好和别人交流，尤其是项目作者。ps: 也可以看看别人的问题，毕竟都是坑</li><li>当然这些要看问题的具体情况，比如一个业务问题，你去github是没有意义的，最后多看官方文档，会避免很多问题，也会给你解决问题带来思路</li></ol></li><li>如何减少bug量，请正视测试用例，测试用例，测试用例</li></ol><p>咳咳，接下来说正题，<strong>Spring cloud</strong></p><p>在学习Spring cloud之后，我对它最直观的理解是: Spring cloud是用于构建分布式系统的一组通用工具集，秉承Spring的集成理念，Spring cloud并不会自己去开发一套工具，而是集成业界现有的优秀开源项目，这里的优秀必然是经得起生产环境验证，并且持续维护。Spring cloud自1.0开始就集成了Netflix OSS套件，通过Spring boot的autoconfigure简化配置，并且为其注入Spring运行环境，让开发者通过几个简单的注解就构建一个基于Netflix生产级别的分布式系统</p>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之事件监听</title>
      <link href="/2018/07/31/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
      <url>/2018/07/31/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
      <content type="html"><![CDATA[<p>在Spring Boot doc的<em>Application Events and Listeners</em>一章中提到，Spring Boot按以下顺序提供了6个事件，供开发者编写<code>ApplicationListener</code>监听相应的事件</p><pre><code>1.ApplicationStartingEvent：在开始运行时，监听器注册和初始化之后被触发2.ApplicationEnvironmentPreparedEvent：发现 Environment 被上下文使用时，上下文被创建之前触发3.ApplicationPreparedEvent：在启动刷新之前，bean定义被加载之后被触发4.ApplicationStartedEvent：上下文刷新之前，应用和命令行启动器运行之前触发5.ApplicationReadyEvent：在所有应用和命令行启动器调用之后，这表明应用已经准备好处理请求6.ApplicationFailedEvent：启动时出现异常触发</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>编写代码的难度不高，读者可根据自己的需求编写相应的listener，以ApplicationStartingEvent为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringBootListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationStartingEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;listening spring boot starting event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>根据文档中的提示，可以使用三种方式添加这6个事件的监听器</p><p>1.通过SpringApplication的addApplicationListener方法添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(SpringBootDocApplication.class,args).addApplicationListener(<span class="keyword">new</span> SpringBootListener());</span><br></pre></td></tr></table></figure><p>2.类似的用SpringApplicationBuilder实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(SpringBootDocApplication.class).listeners(<span class="keyword">new</span> SpringBootListener()).run(args);</span><br></pre></td></tr></table></figure><p>3.如果Listener很多，也可以写在配置文件中，在resources目录下新建META-INF/spring.factories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=com.ttyc.doc.extend.event.customer.SpringBootListener</span><br></pre></td></tr></table></figure><p>最终项目一启动便输出: listening spring boot starting event</p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一个对象的属性发生改变时，需要通知到依赖它的对象并自动更新</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>针对使用场景，如何用代码去实现这种效果，只要理解了观察者模式的基本原理，代码一目了然</p><ol><li>首先明确有两个对象: 观察者，被观察者，我更喜欢理解为监视器和目标</li><li>目标对象里维护一个注册列表，里面记录了注册过的监视器，对外提供注册列表的添加和移除api</li><li>目标发生改变时，遍历这个列表里的所有监视器，通过调用监视器的一个方法通知监视器</li></ol><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>原理并不难，可以说十分简单，两个类，注册列表用一个List集合表示，是否发生改变用一个布尔值表示，很容易手写出来。</p><p>首先是目标类，读者根据上述思路阅读代码应该没有什么障碍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要发生改变的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视器的注册列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Monitor&gt; monitors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否发生改变的标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registMonitor</span><span class="params">(Monitor monitor)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(monitor);</span><br><span class="line">        monitors.add(monitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注销监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregistMonitor</span><span class="params">(Monitor monitor)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(monitor);</span><br><span class="line">        monitors.remove(monitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.isChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.notifyMonitor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (monitors.size() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.isChanged)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Monitor monitor: monitors)&#123;</span><br><span class="line">                monitor.update(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通知结束后清除标志位</span></span><br><span class="line">            <span class="keyword">this</span>.isChanged = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是监视者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起个名字</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据目前对象发生的改变，做出反应</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前监视器为："</span> + getName() + <span class="string">",监视的对象已发生改变，目标名称为："</span> + target.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过测试类测试一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Monitor monitor1 = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor1.setName(<span class="string">"1号"</span>);</span><br><span class="line">        Monitor monitor2 = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor2.setName(<span class="string">"2号"</span>);</span><br><span class="line"></span><br><span class="line">        Target target = <span class="keyword">new</span> Target();</span><br><span class="line">        <span class="comment">// 测试两个监视器</span></span><br><span class="line">        target.registMonitor(monitor1);</span><br><span class="line">        target.registMonitor(monitor2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变属性</span></span><br><span class="line">        target.setName(<span class="string">"jim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注销其中一个</span></span><br><span class="line">        target.deregistMonitor(monitor1);</span><br><span class="line">        target.setName(<span class="string">"tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前监视器为：1号,监视的对象已发生改变，目标名称为：jim</span><br><span class="line">当前监视器为：2号,监视的对象已发生改变，目标名称为：jim</span><br><span class="line">当前监视器为：2号,监视的对象已发生改变，目标名称为：tom</span><br></pre></td></tr></table></figure><p>说明通知成功，并且注销监视器对象后，不再接收到通知</p><h2 id="JDK自带的观察者模式接口"><a href="#JDK自带的观察者模式接口" class="headerlink" title="JDK自带的观察者模式接口"></a>JDK自带的观察者模式接口</h2><p>为什么要用JDK自带的Observable(被观察者)，Observer(观察者)呢？</p><p>点开Observable的源码，since JDK1.0就有的一个类，十分古老，所以出现Vector也不足为奇了，再看里面的方法，关于修改Vector和changed的地方都被synchronized修饰，说明JDK对线程安全性考虑的很好</p><h2 id="JDK源码"><a href="#JDK源码" class="headerlink" title="JDK源码"></a>JDK源码</h2><p>Observable类中用于通知观察者的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自己翻译了下注释：我们不希望观察者在处理自己的监视器时，</span></span><br><span class="line"><span class="comment">         * 回调到所有的代码。我们从集合里取出每一个被观察者，并且</span></span><br><span class="line"><span class="comment">         * 存储观察者的需要同步的状态，但是不应该通知观察者们。</span></span><br><span class="line"><span class="comment">         * 任意竞争锁的最糟糕结果是</span></span><br><span class="line"><span class="comment">         *  1.一个新增的观察者可能错过通知</span></span><br><span class="line"><span class="comment">         *  2.一个最近注销的观察者在它不需要的时候被通知了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            ((Observer) arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现流程大致类似</p><h2 id="JDK方式代码实现"><a href="#JDK方式代码实现" class="headerlink" title="JDK方式代码实现"></a>JDK方式代码实现</h2><h3 id="Step-1-被观察者"><a href="#Step-1-被观察者" class="headerlink" title="Step 1: 被观察者"></a>Step 1: 被观察者</h3><p>继承Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(<span class="string">"name has been changed, now is "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-观察者"><a href="#Step-2-观察者" class="headerlink" title="Step 2: 观察者"></a>Step 2: 观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        Target target = (Target) o;</span><br><span class="line">        System.out.println(<span class="string">"I am be notified by "</span> + target.getName() + <span class="string">", message is "</span> + arg);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-验证"><a href="#Step-3-验证" class="headerlink" title="Step 3: 验证"></a>Step 3: 验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Target();</span><br><span class="line"></span><br><span class="line">        Watcher foo = <span class="keyword">new</span> Watcher();</span><br><span class="line">        Watcher bar = <span class="keyword">new</span> Watcher();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        target.addObserver(foo);</span><br><span class="line">        target.addObserver(bar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标发生改变, 自动通知监视器，并调用update方法</span></span><br><span class="line">        target.setName(<span class="string">"Jim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除监视器</span></span><br><span class="line">        target.deleteObserver(bar);</span><br><span class="line">        target.setName(<span class="string">"Kim"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>第一次setName通知了两个观察者，然后移除了bar观察者，下一次通知就只有一个观察者收到了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am be notified by Jim, message is name has been changed, now is Jim</span><br><span class="line">I am be notified by Jim, message is name has been changed, now is Jim</span><br><span class="line">I am be notified by Kim, message is name has been changed, now is Kim</span><br></pre></td></tr></table></figure><p>如果对JDK自带的线程安全实现方式不满意，可以自行实现这两个类</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring ContextRefreshedEvent事件</title>
      <link href="/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/"/>
      <url>/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">遇到的单词</span><br><span class="line">infrastructure ： 基础设施</span><br><span class="line">arbitrary : 任何的，所有的</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文主要在<a href="https://greedypirate.github.io/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a>的基础上研究Spring中的事件机制</p><p>ApplicationListener监听以下4个事件：ContextStartedEvent，ContextRefreshedEvent，ContextStartedEvent，ContextClosedEvent</p><p>实现对ApplicationContext刷新或初始化时的监听，测试中未出现加载两次的情况，如果需要加入<code>event.getApplicationContext().getParent()</code>判断</p><h2 id="监听ContextRefreshedEvent"><a href="#监听ContextRefreshedEvent" class="headerlink" title="监听ContextRefreshedEvent"></a>监听ContextRefreshedEvent</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextEnvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring Refreshed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自从Spring 4.2以后，可以使用@EventListener注解实现，相信用过Spring-Kafka的读者不会陌生这种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotateContextEvent</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRefresh</span><span class="params">(ContextRefreshedEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring Refreshed by annotated approach"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>实现起来很简单，接下来尝试下Spring中的自定义事件</p><p>自定义事件需要继承ApplicationEvent，这个类并没有什么深意，只是简单封装EventObject加入了时间戳</p><h3 id="Step-1-定义事件——被观察者"><a href="#Step-1-定义事件——被观察者" class="headerlink" title="Step 1 : 定义事件——被观察者"></a>Step 1 : 定义事件——被观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerEvent</span><span class="params">(Object source, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-定义监听器——观察者"><a href="#Step-2-定义监听器——观察者" class="headerlink" title="Step 2 : 定义监听器——观察者"></a>Step 2 : 定义监听器——观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomerEvent</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomerEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CustomerListener listening： CustomerEvent has been triggered, event name is "</span> + event.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-多了一步事件发布"><a href="#Step-3-多了一步事件发布" class="headerlink" title="Step 3 : 多了一步事件发布"></a>Step 3 : 多了一步事件发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CustomerEvent customerEvent = <span class="keyword">new</span> CustomerEvent(<span class="keyword">this</span>,<span class="string">"click"</span>);</span><br><span class="line">        publisher.publishEvent(customerEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDocApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(SpringBootDocApplication.class, args)</span><br><span class="line">                .getBean(CustomEventPublisher.class).publish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomerListener listening： CustomerEvent has been triggered, event name is click</span><br></pre></td></tr></table></figure><h3 id="如果再加入一个监听者呢？是否能通知到"><a href="#如果再加入一个监听者呢？是否能通知到" class="headerlink" title="如果再加入一个监听者呢？是否能通知到"></a>如果再加入一个监听者呢？是否能通知到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtraListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomerEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomerEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ExtraListener listening： CustomerEvent has been triggered, event name is "</span> + event.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CustomerListener listening： CustomerEvent has been triggered, event name is click</span><br><span class="line">ExtraListener listening： CustomerEvent has been triggered, event name is click</span><br></pre></td></tr></table></figure><hr><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p><img src="https://ae01.alicdn.com/kf/H01d163bde58c41e0b908f08d02d02af1N.png" width="65%" align="left"></p><p>这里和观察者模式的遍历一样，调用所有的监听器<br><img src="https://ae01.alicdn.com/kf/H9c5679f3036b4c40b70c684e1d7cf4972.png" width="65%" align="left"></p><p>进入getApplicationListeners方法，可以看到如何查找注册在event上的Listener<br><img src="https://ae01.alicdn.com/kf/Ha30a903295484252a75561e2fc2717b2f.png" width="65%" align="left"></p><p>根据@Order注解对Listener排序，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareOrderComparator.sort(allListeners);</span><br></pre></td></tr></table></figure></p><p>对两个Listener加入@Order注解，果然值较小的ExtraListener先执行</p><p>注：@Order Lower values have higher priority</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><pre><code>对自己的猜想要多验证</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2" target="_blank" rel="noopener">https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2</a><br><a href="http://wiki.jikexueyuan.com/project/spring/custom-events-in-spring.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/spring/custom-events-in-spring.html</a><br><a href="https://blog.csdn.net/tuzongxun/article/details/53637159" target="_blank" rel="noopener">https://blog.csdn.net/tuzongxun/article/details/53637159</a><br><a href="https://blog.csdn.net/zhangningzql/article/details/52515890" target="_blank" rel="noopener">https://blog.csdn.net/zhangningzql/article/details/52515890</a></p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring 扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring InitializingBean接口</title>
      <link href="/2018/07/25/Spring-InitializingBean%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/07/25/Spring-InitializingBean%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h2 id="源文档"><a href="#源文档" class="headerlink" title="源文档"></a>源文档</h2><p>InitializingBean接口的doc文档解释如下，大意为：</p><p>实现这个接口的bean，可以在BeanFactory设置完所有的属性之后生效，例如，执行自定义的bean初始化，或者只是为了检查所有的属性被设置了</p><p>另一个选择是指定<code>init-method</code>，例如在XML中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface to be implemented by beans that need to react once all their</span><br><span class="line"> * properties have been set by a BeanFactory: for example, to perform custom</span><br><span class="line"> * initialization, or merely to check that all mandatory properties have been set.</span><br><span class="line"> *</span><br><span class="line"> * An alternative to implementing InitializingBean is specifying a custom</span><br><span class="line"> * init-method, for example in an XML bean definition.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>从接口描述上可以看出和指定<em>init-method</em>的作用应该是类似的,测试代码如下</p><h3 id="Step-1：实现InitializingBean接口"><a href="#Step-1：实现InitializingBean接口" class="headerlink" title="Step 1：实现InitializingBean接口"></a>Step 1：实现InitializingBean接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanExtend</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after properties set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bean inited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-使用java-config定义bean，指定init-method"><a href="#Step-2-使用java-config定义bean，指定init-method" class="headerlink" title="Step 2: 使用java config定义bean，指定init-method"></a>Step 2: 使用java config定义bean，指定init-method</h3><p>为了方便指定init-method,使用java config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InitBeanExtend <span class="title">initBeanExtend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InitBeanExtend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-编写测试用例"><a href="#Step-3-编写测试用例" class="headerlink" title="Step 3: 编写测试用例"></a>Step 3: 编写测试用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDocApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">InitBeanExtend initBeanExtend;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InitBeanExtend bean = InitBeanExtend.class.cast(initBeanExtend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">after properties <span class="built_in">set</span></span><br><span class="line">bean inited</span><br></pre></td></tr></table></figure><p>结果表明init-method是在afterPropertiesSet方法执行之后调用的</p><hr><p>查看<code>AbstractAutowireCapableBeanFactory</code>类源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeCustomInitMethod</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">...</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">final</span> Method initMethod = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">BeanUtils.findMethod(bean.getClass(), initMethodName) :</span><br><span class="line">ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者除了先后顺序的明显区别之外，可以看出init-method是通过反射达到目的的，而InitializingBean接口具有代码侵入性，有对Spring的依赖</p><p>注意: init-method方法不能有参数，否则将抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.BeanDefinitionValidationException: Couldn&apos;t find an init method named &apos;init&apos; on bean with name &apos;initBeanExtend&apos;</span><br></pre></td></tr></table></figure><p>在IDEA下会有编译警告<br><img src="https://ae01.alicdn.com/kf/Hb3803affca7840a190a0a6a76efa6185L.png" width="65%" align="left"></p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>看过Spring源码的读者经常可以看到这个接口的使用，比如在bean初始化完属性之后，进行参数检查</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="DisposableBean接口"><a href="#DisposableBean接口" class="headerlink" title="DisposableBean接口"></a><code>DisposableBean</code>接口</h3><p>与初始化相对应的还有销毁，在Spring中提供DisposableBean接口，可用来优雅的退出Spring Boot程序，对前面的代码添加实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanExtend</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after properties set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bean inited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gracefully close applicationContext"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Java-EE5规范-PostConstruct和-PreDestroy"><a href="#Java-EE5规范-PostConstruct和-PreDestroy" class="headerlink" title="Java EE5规范@PostConstruct和@PreDestroy"></a>Java EE5规范<code>@PostConstruct</code>和<code>@PreDestroy</code></h3><p>Java EE5规范提出的两个影响Servlet声明周期的方法，添加在非静态方法上，分别会在Servlet实例初始化之后和被销毁之前执行一次</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring 扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot 官方文档阅读</title>
      <link href="/2018/07/24/Spring%20Boot%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/24/Spring%20Boot%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Spring Boot 版本 2.0.3.RELEASE</p><p>文档地址：<a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/</a></p><h2 id="遇到的英文单词"><a href="#遇到的英文单词" class="headerlink" title="遇到的英文单词"></a>遇到的英文单词</h2><ul><li>typical: 典型的</li><li>transitively: 可传递地</li><li>Several of : 几个</li><li>dives into : 深入</li><li>bootstrap : 引导</li><li>delegate : 委托</li><li>approach : 方法</li><li>perform : 执行</li><li>detect : 察觉，侦测，发现</li></ul><h2 id="Spring-CLI的使用"><a href="#Spring-CLI的使用" class="headerlink" title="Spring CLI的使用"></a>Spring CLI的使用</h2><p>step 1： sdkman安装spring-boot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install springboot</span><br></pre></td></tr></table></figure><p>step 2：运行groovy脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring run app.groovy</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisWillActuallyRun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从低版本的Spring-Boot升级到2-0"><a href="#从低版本的Spring-Boot升级到2-0" class="headerlink" title="从低版本的Spring Boot升级到2.0"></a>从低版本的Spring Boot升级到2.0</h2><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行一次后移除该依赖</p><h2 id="使用maven命令启动Spring-Boot"><a href="#使用maven命令启动Spring-Boot" class="headerlink" title="使用maven命令启动Spring Boot"></a>使用maven命令启动Spring Boot</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure><p>相应的gradle有:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle bootRun</span><br></pre></td></tr></table></figure></p><p>可以export系统变量(<strong>没有测试</strong>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_OPTS=-Xmx1024m</span><br></pre></td></tr></table></figure><h2 id="社区提供的Spring-Boot-starter"><a href="#社区提供的Spring-Boot-starter" class="headerlink" title="社区提供的Spring Boot starter"></a>社区提供的Spring Boot starter</h2><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters" target="_blank" rel="noopener">starters列表</a></p><h2 id="如何排除不想生效的Bean"><a href="#如何排除不想生效的Bean" class="headerlink" title="如何排除不想生效的Bean"></a>如何排除不想生效的Bean</h2><p>方式一：使用exclude属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration.class)</span><br></pre></td></tr></table></figure></p><p>方式二：如果classpath下没有这个类，使用类全名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(excludeName = <span class="string">"org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration"</span>)</span><br></pre></td></tr></table></figure></p><p>方式三：如果有多个，可以使用spring.autoconfigure.exclude属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.autoconfigure.exclude=DataSourceAutoConfiguration.class</span><br></pre></td></tr></table></figure></p><p>你可以同时在注解和属性上使用exclude</p><p>You can define exclusions both at the annotation level and by using the property.</p><h2 id="构造器注入可以省略-Autowired"><a href="#构造器注入可以省略-Autowired" class="headerlink" title="构造器注入可以省略@Autowired"></a>构造器注入可以省略@Autowired</h2><p><strong>If a bean has one constructor, you can omit the @Autowired</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Remote-Debug时的启动参数"><a href="#使用Remote-Debug时的启动参数" class="headerlink" title="使用Remote Debug时的启动参数"></a>使用Remote Debug时的启动参数</h2><p>仅供参考，自己还没有试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,<span class="built_in">suspend</span>=n </span><br><span class="line">-jar target/myapplication-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h2 id="IDEA中使用devtools的正确姿势"><a href="#IDEA中使用devtools的正确姿势" class="headerlink" title="IDEA中使用devtools的正确姿势"></a>IDEA中使用devtools的正确姿势</h2><p>修改代码后，需要点击: <strong>Build-&gt;Build Project</strong></p><h2 id="编程式的属性设置"><a href="#编程式的属性设置" class="headerlink" title="编程式的属性设置"></a>编程式的属性设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.setProperty(<span class="string">"spring.devtools.restart.enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line">SpringApplication.run(MyApp.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot提供的几个很有用的事件"><a href="#Spring-Boot提供的几个很有用的事件" class="headerlink" title="Spring Boot提供的几个很有用的事件"></a>Spring Boot提供的几个很有用的事件</h2><p>针对Spring boot提供的事件，编写自己的Listener,详见<strong><a href="https://greedypirate.github.io/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/">Spring-ContextRefreshedEvent事件</a></strong></p><ol><li>ApplicationStartingEvent：在开始运行时，监听器注册和初始化之后被触发</li><li>ApplicationEnvironmentPreparedEvent：发现 Environment 被上下文使用时，上下文被创建之前触发</li><li>ApplicationPreparedEvent：在启动刷新之前，bean定义被加载之后被触发</li><li>ApplicationStartedEvent：上下文刷新之前，应用和命令行启动器运行之前触发</li><li>ApplicationReadyEvent：在所有应用和命令行启动器调用之后，这表明应用已经准备好处理请求<br> 6.ApplicationFailedEvent：启动时出现异常触发</li></ol><h2 id="配置文件的名称和位置"><a href="#配置文件的名称和位置" class="headerlink" title="配置文件的名称和位置"></a>配置文件的名称和位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.config.name</span><br><span class="line">spring.config.location</span><br></pre></td></tr></table></figure><p><strong>注</strong>：这是两个需要很早初始化的属性，只能写在环境变量里(OS environment variable, a system property, or a command-line argument)</p><h2 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h2><ul><li>通过注入ApplicationArguments</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootstrapArgs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BootstrapArgs</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> myargs = args.containsOption(<span class="string">"myargs"</span>);</span><br><span class="line">        Assert.state(myargs, <span class="string">"无法获取自定义参数"</span>);</span><br><span class="line">        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();</span><br><span class="line">        System.out.println(<span class="string">"nonOptionArgs : "</span> + StringUtils.collectionToCommaDelimitedString(nonOptionArgs));</span><br><span class="line">        Set&lt;String&gt; optionNames = args.getOptionNames();</span><br><span class="line">        <span class="keyword">for</span> (String optionName : optionNames) &#123;</span><br><span class="line">            List&lt;String&gt; optionValues = args.getOptionValues(optionName);</span><br><span class="line">            System.out.println(optionValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现CommandLineRunner或ApplicationRunner接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnerBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志按环境生效"><a href="#日志按环境生效" class="headerlink" title="日志按环境生效"></a>日志按环境生效</h2><p>以下配置文件展示了多个环境，特定环境，非某个环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"test,dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.example.demo.controller"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产环境. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 非生产环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!production"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="日志使用Spring环境变量"><a href="#日志使用Spring环境变量" class="headerlink" title="日志使用Spring环境变量"></a>日志使用Spring环境变量</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"fluentHost"</span> <span class="attr">source</span>=<span class="string">"myapp.fluentd.host"</span></span></span><br><span class="line"><span class="tag"><span class="attr">defaultValue</span>=<span class="string">"localhost"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FLUENT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.more.appenders.DataFluentAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目首页查找规则"><a href="#项目首页查找规则" class="headerlink" title="项目首页查找规则"></a>项目首页查找规则</h2><p>支持html和模板引擎作为首页，首先会查找index.html，然后查找index template，还是没有时，会默认用一个欢迎页</p><h2 id="WebBindingInitializer"><a href="#WebBindingInitializer" class="headerlink" title="WebBindingInitializer"></a>WebBindingInitializer</h2><p>用于配置全局的类型转换器, 局部的可以在Controller中使用@InitBinder标记在方法上(<strong>百度所得</strong>)</p><h2 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h2><ol><li style="list-style: none"><input type="checkbox" checked> 搭建jenkins，配合git自动构建发布Spring Boot项目</li><li>研究编排系统Docker，K8s</li><li>研究项目里的Spring扩展</li><li>总结分布式链路追踪</li><li>mybatis官方文档, 源码, mybatis-plus, 通用mapper，代码生成</li><li>spring boot多数据源，分库分表，sharding-jdbc</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 官方文档阅读 </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈之链栈</title>
      <link href="/2017/07/19/%E6%A0%88%E4%B9%8B%E9%93%BE%E6%A0%88/"/>
      <url>/2017/07/19/%E6%A0%88%E4%B9%8B%E9%93%BE%E6%A0%88/</url>
      <content type="html"><![CDATA[<h1 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h1><p>链栈只是单链表的一个简单应用，只要理解单链表的头插法，链栈的出栈入栈很好理解。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>linkstack.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><p>LinkStack.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linkstack.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initLinkStack</span><span class="params">(LinkStack *&amp;ls)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(LinkStack *&amp;ls, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(LinkStack *&amp;ls, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">peek</span><span class="params">(LinkStack *ls, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(LinkStack *ls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkStack * ls;</span><br><span class="line">initLinkStack(ls);</span><br><span class="line"></span><br><span class="line">push(ls,<span class="number">10</span>);</span><br><span class="line">push(ls,<span class="number">20</span>);</span><br><span class="line">push(ls,<span class="number">30</span>);</span><br><span class="line">printStack(ls);</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line">pop(ls,e);</span><br><span class="line">printStack(ls);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initLinkStack</span><span class="params">(LinkStack *&amp;ls)</span></span>&#123;</span><br><span class="line">ls = (LinkStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(LinkStack *&amp;ls)</span></span>&#123;</span><br><span class="line">LinkStack *p = ls, *q;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(q != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈，就是一个头插法，很简单</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(LinkStack *&amp;ls, ElemType e)</span></span>&#123;</span><br><span class="line">LinkStack* node = (LinkStack*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">node-&gt;next = ls-&gt;next;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">ls-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(LinkStack *&amp;ls, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ls-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈空，无法出栈"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkStack *p = ls-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">ls-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">peek</span><span class="params">(LinkStack *ls, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ls-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = ls-&gt;next-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(LinkStack *ls)</span></span>&#123;</span><br><span class="line">LinkStack *q = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,q-&gt;data);</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">302010</span><br><span class="line">2010</span><br></pre></td></tr></table></figure><p>记录:二进制和十进制的转换<br>我们知道十进制转换为二进制采用余数倒转法，二进制转换为十进制使用2的指数与位数乘积之和</p><p>101000101<br>第一个1之和有8位，2^8为256，第二个1之和有6位，2^6为64，以此类推，相加为256+64+4+1=325</p><p>417<br>417位于256到512之间，256=2^8，则100000000，1后有8个0，<br>417减去256=161，位于128到256之间，1后有7个0，和之前的拼接，即110000000<br>以此类推，得出110100001</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈之顺序栈</title>
      <link href="/2017/07/14/%E6%A0%88%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2017/07/14/%E6%A0%88%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈也是线性表的一种，它描述了一种后入先出的操作，可以用顺序存储结构和链式存储结构实现<br>顺序栈的定义由两部分组成：</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MAX_SIZE]; <span class="comment">//存储数据的数组</span></span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">//栈顶指针，它一开始指向-1</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>sqstack.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MAX_SIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>SqStack.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqstack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>; <span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>; <span class="comment">//销毁栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//获取长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//输出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType e)</span></span>; <span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType &amp;e)</span></span>; <span class="comment">//出栈</span></span><br><span class="line"><span class="function">ElemType <span class="title">peek</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>; <span class="comment">//栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SqStack *<span class="built_in">stack</span>;</span><br><span class="line">initStack(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">push(<span class="built_in">stack</span>,<span class="number">10</span>);</span><br><span class="line">push(<span class="built_in">stack</span>,<span class="number">20</span>);</span><br><span class="line">push(<span class="built_in">stack</span>,<span class="number">30</span>);</span><br><span class="line">printStack(<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈长度为:%d\n"</span>,getLength(<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line">pop(<span class="built_in">stack</span>,e);</span><br><span class="line">printStack(<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈长度为:%d\n"</span>,getLength(<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">e = peek(<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈顶元素为:%d"</span>,e);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">stack</span> = (SqStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqStack));</span><br><span class="line"><span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">stack</span>-&gt;top + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;=<span class="built_in">stack</span>-&gt;top; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,<span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top+<span class="number">1</span> == MAX_SIZE)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈满，无法入栈\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>-&gt;top++;</span><br><span class="line"><span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SqStack *&amp;<span class="built_in">stack</span>, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈空，无可出栈元素"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line"><span class="built_in">stack</span>-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">peek</span><span class="params">(SqStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">102030栈长度为:3</span><br><span class="line">1020栈长度为:2</span><br><span class="line">栈顶元素为:20</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性表之双链表</title>
      <link href="/2017/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/2017/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="双链表概述"><a href="#双链表概述" class="headerlink" title="双链表概述"></a>双链表概述</h1><p>双链表也是线性表的一种，它的全称是：线性双向链接表，它有以下特点：<br>在每个节点中除包含有数值域外,设置有两个指针域，分别用以指向其前驱节点和后继节点。<br>既可以依次向后访问每一个节点，也可以依次向前访问每一个节点。<br><img src="https://img.blog.csdn.net/20160724112429339" alt="这里写图片描述"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>dlinklist.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">prior</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;DLinkList;</span><br></pre></td></tr></table></figure><p>DLinkList.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dlinklist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubleLinkList</span><span class="params">(DLinkList * dll)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DLinkList * dll;</span><br><span class="line">ElemType arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">headInit(dll,arr,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"头插法:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line"></span><br><span class="line">tailInit(dll,arr,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"尾插法:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line"></span><br><span class="line">insertElement(dll,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"在第3个位置上插入6之后:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line">deleteElement(dll,<span class="number">3</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除第3个元素之后:\t"</span>);</span><br><span class="line">printDoubleLinkList(dll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">dll = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line"><span class="comment">//头节点两个指针为NULL</span></span><br><span class="line">dll-&gt;next = dll-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">DLinkList * node;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">node = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">node-&gt;data = arr[i];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *插入,画图，依次赋值node-&gt;next，node-&gt;prior，dll-&gt;next(dll-&gt;prior永远为null)</span></span><br><span class="line"><span class="comment"> *可以发现除了第一次插入，以后插入的节点都要设置dll-&gt;next-&gt;prior = node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">node-&gt;next = dll-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(dll-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">dll-&gt;next-&gt;prior = node;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;prior = dll;</span><br><span class="line">dll-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(DLinkList * &amp;dll,ElemType arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">dll = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line"><span class="comment">//头节点两个指针为NULL</span></span><br><span class="line">dll-&gt;next = dll-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">DLinkList * node, *r;</span><br><span class="line">r = dll;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">node = (DLinkList *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">node-&gt;data = arr[i];</span><br><span class="line"><span class="comment">//尾插,画图很简单</span></span><br><span class="line">node-&gt;prior = r;</span><br><span class="line">r-&gt;next = node;</span><br><span class="line">r=node;</span><br><span class="line">&#125;</span><br><span class="line">r=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点，找出前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DLinkList *p = dll, *node;</span><br><span class="line"><span class="keyword">while</span>(i&lt;pos<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入的位置不合法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//分配节点</span></span><br><span class="line">node = (DLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p-&gt;next;</span><br><span class="line">node-&gt;prior = p;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">p-&gt;next-&gt;prior = node;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(DLinkList *&amp;dll, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DLinkList *p = dll, *node;</span><br><span class="line"><span class="keyword">while</span>(i&lt;pos<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">node = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;<span class="comment">//如果p是尾节点，要删除的是尾节点的下一个节点，错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = node-&gt;data;</span><br><span class="line">p-&gt;next = node-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)&#123; <span class="comment">//此时p-&gt;next已经改变，如果node-&gt;next为NULL.NULL不需要设置prior</span></span><br><span class="line">node-&gt;next-&gt;prior = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(node);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubleLinkList</span><span class="params">(DLinkList * dll)</span></span>&#123;</span><br><span class="line"><span class="comment">//不需要输出头节点的data</span></span><br><span class="line">DLinkList *p = dll-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">头插法:54321</span><br><span class="line">尾插法:12345</span><br><span class="line">在第3个位置上插入6之后:126345</span><br><span class="line">删除第3个元素之后:12345</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性表之单链表</title>
      <link href="/2017/07/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2017/07/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="单链表概述"><a href="#单链表概述" class="headerlink" title="单链表概述"></a>单链表概述</h1><p>一张图简单解释下单链表的结果，对头节点，头指针，首节点混肴的同学可以再看看<br><img src="https://img-blog.csdn.net/20160723154837259" alt="这里写图片描述"></p><p>以下是单链表的头文件和相关操作，这门课很抽象，我个人认为只在脑海中去理解很难做到，因为指针指来指去是个人都会晕，建议大家用笔在纸上画出来，更容易理解<br>比如单链表的尾插法， 在纸上一画瞬间理解了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>linklist.h如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br></pre></td></tr></table></figure><p>LinkList.cpp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linklist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(LinkList * &amp;ls, <span class="keyword">int</span> msg[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(LinkList * &amp;ls, <span class="keyword">int</span> msg[], <span class="keyword">int</span> n)</span></span>;<span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkList</span><span class="params">(LinkList *ls)</span></span>;<span class="comment">//输出链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(LinkList *&amp;ls)</span></span>;<span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkList *ls)</span></span>;<span class="comment">//获取长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getElementByIndex</span><span class="params">(LinkList *ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>;<span class="comment">//通过下标获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(LinkList *ls,ElemType e)</span></span>;<span class="comment">//获取元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(LinkList *&amp;ls,<span class="keyword">int</span> pos, ElemType e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(LinkList *&amp;ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相比于顺序表，单链表不需要连续的空间，没有冗余的空间，而且不用扩容，插入和删除操作效率高</span></span><br><span class="line"><span class="comment"> * 但是其他操作复杂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList * ls;</span><br><span class="line"></span><br><span class="line">ElemType arr1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">headInit(ls,arr1,<span class="number">5</span>);</span><br><span class="line">printLinkList(ls);</span><br><span class="line"></span><br><span class="line">ElemType arr2[] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">tailInit(ls,arr2,<span class="number">5</span>);</span><br><span class="line">printLinkList(ls);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n单链表的长度是:%d\n"</span>,getLength(ls));</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">if</span>(getElementByIndex(ls,<span class="number">5</span>,e))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个元素的值是:%d\n"</span>,<span class="number">5</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = getElementIndex(ls,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(pos)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d的位置是:%d\n"</span>,<span class="number">10</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span>(insert(ls,<span class="number">6</span>,<span class="number">11</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d插入成功\n"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">printLinkList(ls);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(deleteElement(ls,<span class="number">5</span>,e))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n要删除的第%d个元素是%d,已删除成功\n"</span>,<span class="number">5</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">printLinkList(ls);</span><br><span class="line">destory(ls);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">头插法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headInit</span><span class="params">(LinkList * &amp;ls, ElemType msg[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">LinkList *node;</span><br><span class="line">ls = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="comment">//产生一个新节点</span></span><br><span class="line">node = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">node-&gt;data = msg[i];</span><br><span class="line"><span class="comment">//把该节点插到头节点的后面，画图</span></span><br><span class="line">node-&gt;next = ls-&gt;next;</span><br><span class="line">ls-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">尾插法:定义一个尾指针指向尾节点，因为每次都在尾节点后面插，就把尾节点当作头节点去插</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tailInit</span><span class="params">(LinkList * &amp;ls, <span class="keyword">int</span> msg[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ls = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">LinkList *node,*tail = ls; <span class="comment">//尾指针最初也指向头节点</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">node = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">node-&gt;data = msg[i];</span><br><span class="line">tail-&gt;next = node;</span><br><span class="line">tail = node; <span class="comment">//尾指针指向新插入的节点，即尾节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一开始没加这句，导致tail-&gt;next成为野指针,导致一直输出</span></span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkList</span><span class="params">(LinkList *ls)</span> </span>&#123;</span><br><span class="line">LinkList *p = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的消耗要把每一个节点都free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(LinkList *&amp;ls)</span></span>&#123;</span><br><span class="line">LinkList * head = ls, * p = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">head = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁最后一个</span></span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是空表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkList *ls)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ls-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkList *ls)</span></span>&#123;</span><br><span class="line">LinkList * p = ls;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第i个节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getElementByIndex</span><span class="params">(LinkList *ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">LinkList * p = ls;</span><br><span class="line"><span class="keyword">while</span>(i&lt;pos &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后要么i&lt;pos不成立，也就是找到了，要么ls==NULL，也就是到表尾了</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在第%d个元素\n"</span>,pos);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(LinkList *ls,ElemType e)</span></span>&#123;</span><br><span class="line"><span class="comment">//用pos记录下标</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">LinkList *p = ls-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对循环结束后的条件进行判断</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的插入需要记录前一个节点,所以找到pos-1即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(LinkList *&amp;ls,<span class="keyword">int</span> pos, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">LinkList * p = ls; <span class="comment">//不要直接用ls</span></span><br><span class="line"><span class="comment">//pos-1,假如在第5个位置插入，就找出第四个节点，让它指向e</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; pos<span class="number">-1</span> &amp;&amp; p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//为插入的节点分配空间</span></span><br><span class="line">LinkList * node = (LinkList *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">node-&gt;data = e;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除同样也要找到pos-1个节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(LinkList *&amp;ls, <span class="keyword">int</span> pos, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">LinkList * p = ls , *temp;</span><br><span class="line"><span class="keyword">while</span>(i &lt; pos<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//删除节点，记得先把地址用temp保存起来，用于free</span></span><br><span class="line">temp = p-&gt;next;</span><br><span class="line">e = temp-&gt;data;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">54321678910</span><br><span class="line">单链表的长度是:5</span><br><span class="line">第5个元素的值是:10</span><br><span class="line">10的位置是:5</span><br><span class="line">11插入成功</span><br><span class="line">67891011</span><br><span class="line">要删除的第5个元素是10,已删除成功</span><br><span class="line">678911</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性表之顺序表</title>
      <link href="/2017/07/07/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2017/07/07/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>作为一个计科大学生，没有学好数据结构一直是我的遗憾，博主主攻java web方向，为了不当一个低端码农，决心静下心来学习数据结构，但是和我当初自学java一样，都存在入门难的问题，严蔚敏的数据结构一直是我的噩梦，概念多且抽象，我希望通过敲代码这种实战的方式学习数据结构，也就放弃了课本。<br>后来在CSDN上看到贺利坚的课程(收费)，和很多人一样，并不想买，后来在贴吧看到免费的观看地址（百度锐聘），就慢慢地开始学，同时写博客记录我的学习过程。<br>在此十分感谢贺利坚老师，看了他的博客后不止教会了我数据结构，也为我解开了诸多学习上的疑惑</p></blockquote><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>数据结构系列文章时从博主的CSDN中迁移过来的，重新进行排版优化，切莫闹出举报博主自己抄袭自己的笑话(咳咳，我已经授权抄袭自己了)</p><h1 id="线性表概述"><a href="#线性表概述" class="headerlink" title="线性表概述"></a>线性表概述</h1><p>线性表描述了一种线性的逻辑结构，元素之间是一对一的关系，而在存储结构上分为顺序存储和链式存储，<br>分别简称为：顺序表和链表<br>以下是顺序表的定义方式以及操作，运行环境为Eclipse CDT，程序用到少部分C++特性，新建时选择C++ project，在运行main之前，先要右键项目，进行build project</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>sqlist.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INCREMENT_SIZE 10</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ElemType可以表示一个复杂的结构体</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">int age;</span></span><br><span class="line"><span class="comment">char name[32];</span></span><br><span class="line"><span class="comment">&#125;ElemType;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MAX_SIZE];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>SqList.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqlist.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSqList</span><span class="params">(SqList *&amp;sl)</span></span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqList *sl)</span></span>; <span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCapacity</span><span class="params">(SqList *&amp;sl)</span></span>; <span class="comment">//扩容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySqList</span><span class="params">(SqList *&amp;sl)</span></span>; <span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqList *sl)</span></span>; <span class="comment">//获取长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList *sl)</span></span>; <span class="comment">//输出顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>; <span class="comment">//删除下标为i的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType e)</span></span>; <span class="comment">//在i处插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getElementByIndex</span><span class="params">(SqList *sl, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>; <span class="comment">//通过下标i获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(SqList *&amp;sl, ElemType e)</span></span>;<span class="comment">//获取元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqList *sl;</span><br><span class="line">ElemType ele;</span><br><span class="line">initSqList(sl);</span><br><span class="line">insertElement(sl, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">insertElement(sl, <span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">insertElement(sl, <span class="number">3</span>, <span class="number">30</span>);</span><br><span class="line">insertElement(sl, <span class="number">4</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">deleteElement(sl,<span class="number">4</span>,ele);</span><br><span class="line">printList(sl);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"元素%d的位置是：%d\n"</span>,<span class="number">20</span>, getElementIndex(sl,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">getElementByIndex(sl, <span class="number">2</span>, ele);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个元素是：%d\n"</span>,<span class="number">2</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSqList</span><span class="params">(SqList *&amp;sl)</span> </span>&#123;</span><br><span class="line">sl = (SqList *)<span class="built_in">malloc</span>(MAX_SIZE*<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">sl-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqList *sl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (sl-&gt;length == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCapacity</span><span class="params">(SqList *&amp;sl)</span> </span>&#123;</span><br><span class="line">sl = (SqList *)<span class="built_in">realloc</span>(sl,(sl-&gt;length + INCREMENT_SIZE));</span><br><span class="line"><span class="keyword">if</span> (!sl) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"扩容失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意是length，不是MAX_SIZE,假如这不是第一次扩容</span></span><br><span class="line">sl-&gt;length += INCREMENT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySqList</span><span class="params">(SqList *&amp;sl)</span> </span>&#123;</span><br><span class="line"><span class="built_in">free</span>(sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqList *sl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sl-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList *sl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(sl)) &#123;<span class="comment">//是否是空表</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"List is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; sl-&gt;length; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,sl-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果list里只有10个元素，你最多能在11的位置上插入，不能大于11</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;sl-&gt;length+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入的位置不合法\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果超过容量，就扩容</span></span><br><span class="line"><span class="keyword">if</span> (sl-&gt;length == MAX_SIZE) &#123;</span><br><span class="line">addCapacity(sl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">//从最后一个元素 到第i-1个元素后移，自己在纸上画出来，很容易理解j&gt;=i-1</span></span><br><span class="line"><span class="keyword">for</span> (j=sl-&gt;length<span class="number">-1</span>; j&gt;=i - <span class="number">1</span>; j--)&#123;</span><br><span class="line"><span class="comment">//为什么是j+1 = j,不是j = j-1，想想最后一个元素是怎么移动的就很好理解了</span></span><br><span class="line">sl-&gt;data[j + <span class="number">1</span>] = sl-&gt;data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把元素插入到下标为(i-1)的位置</span></span><br><span class="line">sl-&gt;data[i - <span class="number">1</span>] = e;</span><br><span class="line"><span class="comment">//记得length++</span></span><br><span class="line">sl-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteElement</span><span class="params">(SqList *&amp;sl, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;sl-&gt;length) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入的位置不合法\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = sl-&gt;data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; sl-&gt;length; j++) &#123;</span><br><span class="line">sl-&gt;data[j - <span class="number">1</span>] = sl-&gt;data[j];</span><br><span class="line">&#125;</span><br><span class="line">sl-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElementIndex</span><span class="params">(SqList *&amp;sl, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sl-&gt;length &amp;&amp; sl-&gt;data[i] != e) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; sl-&gt;length) &#123;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">//这个时候的i是从0开始算的，所以要+1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getElementByIndex</span><span class="params">(SqList *sl, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;sl-&gt;length) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"访问的位置不合法"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = sl-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除元素x，x不止一个</span></span><br><span class="line"><span class="comment">找到，然后删除, O(n) = n*n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle_1</span><span class="params">(SqList *sl, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">while</span> ((i = getElementIndex(sl, x)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">deleteElement(sl, i, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除元素x，x不止一个</span></span><br><span class="line"><span class="comment">将O(n) 降低到 O(n)</span></span><br><span class="line"><span class="comment">算法：用复制的思想</span></span><br><span class="line"><span class="comment">重新从0开始计数，只要第n个元素不等于x，就移动到前面去(同时把以前的覆盖)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle_2</span><span class="params">(SqList *sl, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sl-&gt;length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sl-&gt;data[i] != x) &#123;</span><br><span class="line">sl-&gt;data[k] = sl-&gt;data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sl-&gt;length = k; <span class="comment">//删除x后，k就是长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
