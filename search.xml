<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>架构演进史(一)</title>
      <link href="/2019/01/05/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8F%B2(%E4%B8%80)/"/>
      <url>/2019/01/05/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8F%B2(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<blockquote><p>本系列希望通过自己的所见所闻，描述出一个公司在不断发展的过程中遇到的一般性架构演进</p></blockquote>]]></content>
      
      <categories>
          
          <category> 架构随笔录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之多数据源最佳实践</title>
      <link href="/2019/01/05/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/01/05/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<blockquote><p>多数据源主要用于mysql主从，多库等场景，笔者初始接触时也在网上找了很多资料如何配置，但做法百花齐放，有很多用到了ThreadLocal，注解，数据源路由等技术，最终选择了一个简单，易用，易理解的方式：每一个数据源只扫描自己的mapper</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基于以上思想，只需要以下步骤：</p><ol><li>配置文件中采用不同的前缀配置各个数据源</li><li>为每个数据源初始化DataSource，SqlSessionFactory，TransactionManager</li><li>每个数据源都有自己的配置，扫描自己的mapper.xml，DAO接口</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p>注意，笔者遇到的情况是多库，以订单库和用户库举例，如果是主从，可以起名master，slave<br>配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#db1</span><br><span class="line">spring.datasource.default.url = jdbc:mysql://localhost:3306/order?characterEncoding=utf-8&amp;connectTimeout=2000&amp;socketTimeout=2000&amp;zeroDateTimeBehavior=convertToNull</span><br><span class="line">spring.datasource.default.username = root</span><br><span class="line">spring.datasource.default.password = 123</span><br><span class="line"></span><br><span class="line">#db2</span><br><span class="line">spring.datasource.user.url = jdbc:mysql://localhost:3306/user?characterEncoding=utf-8&amp;connectTimeout=2000&amp;socketTimeout=2000&amp;zeroDateTimeBehavior=convertToNull</span><br><span class="line">spring.datasource.user.username = root</span><br><span class="line">spring.datasource.user.password = 123</span><br></pre></td></tr></table></figure><h3 id="配置数据源相关对象"><a href="#配置数据源相关对象" class="headerlink" title="配置数据源相关对象"></a>配置数据源相关对象</h3><h4 id="抽取公共类"><a href="#抽取公共类" class="headerlink" title="抽取公共类"></a>抽取公共类</h4><p>如果数据源很多，建议抽取公共类，封装一些公共方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource 数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location mapper.xml位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">(DataSource dataSource, String location)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setConfiguration(configuration());</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver()</span><br><span class="line">                .getResources(location));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置下划线转驼峰</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Configuration <span class="title">configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置主数据源"><a href="#配置主数据源" class="headerlink" title="配置主数据源"></a>配置主数据源</h4><p>将order库作为项目的主数据源,@MapperScan用于扫描DAO接口，MAPPER_LOCATION传入父类指定mapper.xml位置<br>同时@Primary标注这是我们项目的主数据源<br><code>@ConfigurationProperties(&quot;spring.datasource.default&quot;)</code> 表示数据源配置采用的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.ttyc.dao.order"</span>, sqlSessionFactoryRef = <span class="string">"defaultSqlSessionFactory"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataSourceConfig</span> <span class="keyword">extends</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_LOCATION = <span class="string">"classpath:mapper/order/*.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.default"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">defaultDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"defaultSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">defaultSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"defaultDataSource"</span>)</span> DataSource defaultDataSource)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSessionFactory(defaultDataSource, MAPPER_LOCATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"defaultTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">defaultTransactionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"defaultDataSource"</span>)</span> DataSource defaultDataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(defaultDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理配置user库数据源，只不过去除@Primary注解，至此配置结束</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>正常编程即可，因为数据源已经按路径扫描了DAO接口和mapper.xml文件</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>以微服务的思想，多库是不应该存在的， 每个服务应该数据自治，职责单一，对于user库应该调用用户微服务接口，而不应该访问用户DB，造成耦合，目前笔者遇到的需求属于临时需求，并且将来会废弃该接口，所以从成本考虑，采用直接访问DB的形式，希望大家引以为戒！</p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective-java读书笔记-三-：类和接口</title>
      <link href="/2018/11/28/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/11/28/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%EF%BC%9A%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="使类和接口的可访问性最小化"><a href="#使类和接口的可访问性最小化" class="headerlink" title="使类和接口的可访问性最小化"></a>使类和接口的可访问性最小化</h1><p>模块设计原则：对外隐藏内部数据和实现细节，把api和他的实现隔离开来，模块之间通过api通信，一个模块不需要知道其它模块的内部细节，这称之为封装。</p><p>封装有效地让各模块直接解耦，解耦之后模块可以独立的开发，测试，优化，使用及修改。</p><ol><li>尽可能地使每个类或者成员不被外界访问<ol><li>类或接口尽可能的做成包级私有的，在以后的版本中，可以对他修改</li><li>如果你把类做成公有的，你就有责任永远对它负责，保证后续版本的兼任性</li><li>如果一个类只在某个类中使用，则考虑使用嵌套类(nested-class)</li></ol></li></ol><p>如果</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective java读书笔记(二)：对象通用方法</title>
      <link href="/2018/11/26/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/26/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="对象通用方法"><a href="#对象通用方法" class="headerlink" title="对象通用方法"></a>对象通用方法</h1><h2 id="覆盖equals时的约定"><a href="#覆盖equals时的约定" class="headerlink" title="覆盖equals时的约定"></a>覆盖equals时的约定</h2><p>当类具有特有的”逻辑相等”概念时，必须覆盖equals方法，这样也可以使这个类作为map的key，或者set中的元素</p><p>当对象非null时，equals方法满足以下四个特性：</p><ol><li>自反性：<code>x.equals(x)=true</code></li><li>对称性：<code>x.equals(y)=true</code>时，<code>y.equals(x)</code>必须为true</li><li>传递性：x=y，y=z，则x=z</li><li>一致性：<code>x.equals(y)</code>在多次调用后返回相同的值</li></ol><p>理解即可，不必要记忆</p><h3 id="高效的编写equals方法"><a href="#高效的编写equals方法" class="headerlink" title="高效的编写equals方法"></a>高效的编写equals方法</h3><p>首先了解一个小知识点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span> <span class="keyword">instanceof</span> Object = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>null不属于任何一个类型，所以对equals方法传入的对象不必做空指针判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> MyClass) &#123;</span><br><span class="line">        MyClass castObj = (MyClass)anObject;</span><br><span class="line">    <span class="comment">// 自己的判断逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写步骤"><a href="#编写步骤" class="headerlink" title="编写步骤"></a>编写步骤</h4><ol><li>首先用==检查参数是否是当前对象</li><li>判断参数是否是要判断的类型，</li><li>将对象强转成要比较的对象类型</li><li>根据类中的字段编写自己的判断逻辑，返回相应的true或false</li></ol><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h3><p>相信很多新手同学分不清这二者的区别，以及使用场景，二者区别如下：</p><ol><li><p>先说基本类型的==判断：值相等就返回true</p></li><li><p>再说引用类型的==：指向同一个对象才返回true</p></li><li><p>最后是equals：在Object里，它和==时一样的，但是类可以有自己的判断依据，比如String类</p></li></ol><h4 id="包装类的比较"><a href="#包装类的比较" class="headerlink" title="包装类的比较"></a>包装类的比较</h4><p>问题：<code>Integer i = 1, Integer j = 1</code>,如何比较二者是否相等?</p><p>答案是<code>i.equals(j)</code>,切不可写成<code>i==j,因为Integer内部采用了缓存，-128至127之间的数字被视为同一个对象，此时是可以通过==判断两个数字是否相等，但这只是假象，超过这个区间的数字就会返回</code>false</p><h2 id="覆盖equals是同时覆盖hashcode"><a href="#覆盖equals是同时覆盖hashcode" class="headerlink" title="覆盖equals是同时覆盖hashcode"></a>覆盖equals是同时覆盖hashcode</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>Java规范中包含以下约定：</p><ol><li>只要equals中用来判断两个对象是否相等的字段没有发生改变，那么调用多少次返回的结果都应该相同</li><li>如果通过equals判断出两个对象相等，那么它们的hashcode方法的返回值一定相等；如果不相等，那么hashcode方法的返回值不一定不等，但这必然降低了散列表的性能</li></ol><h3 id="编写hashcode方法"><a href="#编写hashcode方法" class="headerlink" title="编写hashcode方法"></a>编写hashcode方法</h3><p>hashcode方法编写的好坏，直接影响对象能否在集合中均匀分布，具体的编写方法见书41页，这里记下注意的几点：</p><ol><li>冗余字段不参与计算与比较，例如单价，数量，总价三者的关系，很明显总价可以通过另外二者计算出来，那么总价不必参与计算hashcode的过程，同时必须也不能参数equals的比较过程</li></ol><h2 id="覆盖toString方法"><a href="#覆盖toString方法" class="headerlink" title="覆盖toString方法"></a>覆盖toString方法</h2><p>toString方法的作用显而易见，如果不覆盖Object中的toString方法，返回<code>类名@对象hashcode十六进制值</code>的表现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><p>在实际开发中，toString用于记录日志是必不可少，例如打印用户信息，如果输出原始形式，则毫无价值，我们更关系的是用户id，用户名等关键信息</p><h2 id="谨慎覆盖clone方法"><a href="#谨慎覆盖clone方法" class="headerlink" title="谨慎覆盖clone方法"></a>谨慎覆盖clone方法</h2><h2 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h2>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective java读书笔记(一)：对象的创建与销毁篇</title>
      <link href="/2018/11/23/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%AF%87/"/>
      <url>/2018/11/23/Effective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="对象的创建与销毁篇"><a href="#对象的创建与销毁篇" class="headerlink" title="对象的创建与销毁篇"></a>对象的创建与销毁篇</h1><h2 id="使用静态工厂创建对象"><a href="#使用静态工厂创建对象" class="headerlink" title="使用静态工厂创建对象"></a>使用静态工厂创建对象</h2><p>创建一个对象最常用的方式是构造方法，但有时也要考虑使用静态工厂创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"tom"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态工厂的好处有三:</p><ol><li>有名称，不同于构造方法，静态工厂作为一个普通的静态方法，可以使用名称更清晰的表达作者的想法，对比多个构造方法的情况，往往读者看见多个不同参数类型，不同顺序的构造方法时，不知道它们是干什么的，静态工厂使用方法名提高了代码可读性，私以为在企业开发中，多人合作时，面对复杂的业务逻辑，可读性尤为重要</li><li>不必每次都创建一个对象，或者说对象可以被重复利用，例如初始化一个数据库连接对象，不必每次设置用户名密码创建这个对象</li><li>可以使用多态，返回子类类型的对象，例如通过参数来判断应该返回哪种子类型</li></ol><p>同时它也是有缺点的，在看到构造方法时，我们能一眼看出是用于创建对象，但是静态工厂则不一定，因此静态工厂的方法名遵从一些惯用名称：valueOf，getInstance，newInstance等等</p><h2 id="构造方法参数过多时，使用Builder"><a href="#构造方法参数过多时，使用Builder" class="headerlink" title="构造方法参数过多时，使用Builder"></a>构造方法参数过多时，使用Builder</h2><h3 id="Builder是什么"><a href="#Builder是什么" class="headerlink" title="Builder是什么"></a>Builder是什么</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User tom = User.builder().name(<span class="string">"tom"</span>).age(<span class="number">18</span>).build();</span><br></pre></td></tr></table></figure><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>静态工厂和构造方法都不能很好的解决参数过多时，参数是否必传问题，通常先写一个大而全的参数方法，然后提供多个部分参数方法。</p><p>以静态工厂为例，比如：有三个参数，其中address，age可不传，先写出一个三参数的，然后下面的方法传null来调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, Integer age, String address)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createUser(name,age, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createUser(name, <span class="keyword">null</span>,address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的弊端很明显，参数多了不利于扩展，不扩展又会导致调用者必须传一些无用的参数，并且代码难以阅读，调用方还容易出错</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-JavaBean"><a href="#1-JavaBean" class="headerlink" title="1.JavaBean"></a>1.JavaBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setXxx();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>通过setter可以很好的避免上述问题，但书中所说JavaBean本身时可变类，无法成为不可变类，在这set的过程中有可能会产生线程安全问题，笔者认为实际业务开发中JavaBean多用于方法形参，属于线程私有，除非定义在成员变量位置，否则线程安全问题极低</p><h4 id="2-Builder模式"><a href="#2-Builder模式" class="headerlink" title="2.Builder模式"></a>2.Builder模式</h4><p>由于Builder模式代码编写很多，我们在实际开发中使用lombok可以更快的达到目的，事先引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaBean类上加入<code>@Builder</code>注解，即可像开头那样调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果类的构造方法或者静态工厂有多个参数时，优先考虑Builder模式，特别是某些参数可选时</p><h2 id="使用枚举来创建单例模式"><a href="#使用枚举来创建单例模式" class="headerlink" title="使用枚举来创建单例模式"></a>使用枚举来创建单例模式</h2><p>使用工厂模式创建单例模式分为：懒汉式，饿汉式。使用枚举作为替代主要有以下两个原因</p><ol><li>懒汉式通常需要与double-check配合使用来保证线程安全，而枚举本身就是线程安全的</li><li>工厂模式在对象反序列化无法保证单例，需要重写readResolve，而枚举自动实现了反序列化</li></ol><h3 id="使用枚举创建User单例"><a href="#使用枚举创建User单例" class="headerlink" title="使用枚举创建User单例"></a>使用枚举创建User单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    UserSingleton() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的线程安全性"><a href="#枚举的线程安全性" class="headerlink" title="枚举的线程安全性"></a>枚举的线程安全性</h3><p>枚举类在反编译之后，是一个不可变类，因此它是线程安全的</p><h3 id="测试饿汉式的反序列化失效情况"><a href="#测试饿汉式的反序列化失效情况" class="headerlink" title="测试饿汉式的反序列化失效情况"></a>测试饿汉式的反序列化失效情况</h3><p>使用饿汉式创建User单例模式类,并为<code>User</code>类实现<code>Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserSingletonFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    User instance = UserSingletonFactory.getInstance();</span><br><span class="line">    User other = UserSingletonFactory.getInstance();</span><br><span class="line">    <span class="comment">// 此时单例模式的结果返回true</span></span><br><span class="line">    System.out.println(instance == other);</span><br><span class="line">    </span><br><span class="line">    ObjectOutputStream oos =</span><br><span class="line">            <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"obj.txt"</span>)));</span><br><span class="line">    oos.writeObject(instance);</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois =</span><br><span class="line">            <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"obj.txt"</span>)));</span><br><span class="line">    User user = (User) ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line"></span><br><span class="line">    System.out.println(instance == user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果最后的输出为false</p><h2 id="通过私有的构造方法让类不可实例化"><a href="#通过私有的构造方法让类不可实例化" class="headerlink" title="通过私有的构造方法让类不可实例化"></a>通过私有的构造方法让类不可实例化</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li>私有的构造方法，指用private修饰构造方法</li><li>不可实例化，通过私有的构造方法，让类无法产生对象</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>作为一些工具类，例如JDK中的<code>Math</code>类，只希望使用它的静态成员变量和静态方法，所以我们可以看到源码中的Math类构造方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Don't let anyone instantiate this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Math</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>原则：尽量重用对象，如果是不可变类产生的对象，那它始终可以被重用</p><p>典型的不可变类如<code>String</code>,只要是相同的字符串，内存中只有一个String对象</p><p>同时有静态工厂和构造器的不可变类，优先使用静态工厂创建对象，静态工厂不会重复创建对象，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean.valueOf(<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>优先于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Boolean(<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>除了不可变对象，还可以重用那些被认为不会被修改的可变对象，书中用一个日期类举例，将只需要初始化一次的对象放在静态代码块中，在实际开发中，诸如数据库连接池，http client请求线程池等重量级的对象，为了提高性能，必须重用</p><h2 id="清理过期的对象引用"><a href="#清理过期的对象引用" class="headerlink" title="清理过期的对象引用"></a>清理过期的对象引用</h2><p>为了防止内存泄漏，需要将不再使用的对象，解除引用，即obj = null，将引用指向空，让GC回收对象</p><p>例如List的remove方法中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br></pre></td></tr></table></figure><p>需要注意的是清除对象引用是在特殊情况下的处理，并不是一种规范，我们在实际开发中并不需要小心翼翼的处理</p><h3 id="何时清除对象引用"><a href="#何时清除对象引用" class="headerlink" title="何时清除对象引用"></a>何时清除对象引用</h3><p>如果类自己管理内存空间，如<code>ArrayList</code>内部使用<code>Object</code>数组存储，一旦其中的元素被删除，则需要清空对象引用</p><h3 id="避免使用finalize方法"><a href="#避免使用finalize方法" class="headerlink" title="避免使用finalize方法"></a>避免使用finalize方法</h3><p>老生常谈的<code>finalize</code>方法问题，不要尝试调用它，GC并不会立即回收对象，甚至不保证执行。经过测试，调用finalize还会降低性能，花费更多的时间销毁对象，书中后面讲解的内容实用性太低，不做记录</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>11.22日映客架构师讲座</title>
      <link href="/2018/11/22/11.22%E6%97%A5%E6%98%A0%E5%AE%A2%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%B2%E5%BA%A7/"/>
      <url>/2018/11/22/11.22%E6%97%A5%E6%98%A0%E5%AE%A2%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%B2%E5%BA%A7/</url>
      <content type="html"><![CDATA[<ol><li>不要把每一个单独的服务优化到极致，心中要有一个架构的演进方向，根据这个方向优化分散的点，如存储，mq，服务等，最终达到一个我们心中理想的架构。同时要融入到公司，理解业务，要有将产品带向好的方向的心态，不是完成上级的任务，产品的需求，常年下来没有进步</li><li>业务服务不要直连DB，应该抽取成基础服务，业务服务都是用基础服务拼接而成的，这样做利于基础服务的扩展</li><li>作为基础服务一定要考虑限流，服务的熔断和降级</li><li>要保证业务的关键路径高可用，其他服务挂了，不能影响它，例如淘宝，下单流程，确认收货流程一定是可用的，提高用户体验</li><li>服务的取舍，比如手机直播，100w用户在一个直播间，当前用户只关心自己送出的礼物，发出的评论有没有显示，这是我们一定要保证的<br>同时，别的用户评论，一秒只显示几百条都是没问题的，丢弃其余的消息，做到流量削峰，保证良好的用户体验</li><li>分布式事务：预占型和给予型。 预占型可以记录日志，重新请求时看有没有日志来判断上一次是否执行成功了；给予型具有延时特性，比如手机转账，总是过几秒才转过来</li><li>分库分表：如何从主从切换到分库分表，先用mysql binlog同步到分库分表中，并进行比对，一直到没有差异为止，ABA问题在多次比对后出现的几率已经很低了，此时线上业务可以将读操作切换到分库分表，因为读是不会产生脏数据的</li><li>云服务的好处：按流量计费，比如某天有秒杀活动，用户量激增，如果是自己的机房，需要增加服务器，等过了这个时间后，流量又下来了，而云服务是按流量计费的，增加缩减机器都十分方便。云服务的不足之处是要和别的企业共享资源，因为稳定性不高，还会有资源限制，如带宽限制，mysql连接数限制</li><li>对恶意用户的思考，比如刷金币，刷粉丝，刷广告等等，是否有必要赶尽杀绝，如果涉黄涉政，必然是要屏蔽的，而例如微博，用户是否也有刷粉丝的实际需要<br>如何防止恶意用户呢，可以用工具，例如内容识别，账号防刷等，但是有效期不长，建议用大数据进行行为特征分析</li><li>需求和开发：施行2周制，第一周产品和开发都是ready状态，产品准备好需求，开发人员开始开发，测试，直到第二周结束上线，同时从第一周开始并行地，开始准备下一轮新的需求，到第二周结束准备好下一轮新需求，以此往复</li><li>定期梳理自己的代码，线上服务正常运行很近，突然出现问题，说”我没动代码啊”，这样做是不对的，没动过并不代表没有隐患，可以每天上下班看一眼自己的业务指标监控(open-falcon)</li><li>线上出现问题的正确做法，立即采取一切手段修复故障，保障用户体验，及时止损，而不是在保护故障现场，排查问题。事后要对故障复盘，并且组内开会讨论，不要抱有职责，内疚的情绪，让组员都从这次问题中成长</li><li>语言和技术栈一定要统一，降低成本</li><li>抽取通用服务，如鉴权，不要每个服务都开发一套</li></ol>]]></content>
      
      <categories>
          
          <category> 架构随笔录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之Spring Cloud Consul项目接入</title>
      <link href="/2018/11/19/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8BSpring-Cloud-Consul%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5/"/>
      <url>/2018/11/19/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8BSpring-Cloud-Consul%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>本文主要介绍Spring Cloud对consul的支持，分为消费者和生产者两个客户端</p></blockquote><h2 id="应用详情"><a href="#应用详情" class="headerlink" title="应用详情"></a>应用详情</h2><p>分别新建两个spring-boot项目</p><table><thead><tr><th>应用名称</th><th>端口</th><th>consul注册地址</th></tr></thead><tbody><tr><td>consumer-service</td><td>8301</td><td>10.9.181.34:8500</td></tr><tr><td>producer-service</td><td>8302</td><td>10.9.117.128:8500</td></tr></tbody></table><h2 id="consul接入"><a href="#consul接入" class="headerlink" title="consul接入"></a>consul接入</h2><h3 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h3><p>除了通用的web模块，主要需要consul-discovery与actuator，前者用于consul客户端接入，后者提供健康检查接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulConsumerApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ConsulConsumerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8301</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer-service</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost #consul客户端地址</span><br><span class="line">      port: 8500</span><br><span class="line">      retry:</span><br><span class="line">        max-attempts: 3</span><br><span class="line">        initial-interval: 1000</span><br><span class="line">        max-interval: 2000</span><br><span class="line">        multiplier: 1.1</span><br><span class="line">      discovery:</span><br><span class="line">        health-check-interval: 10s #健康检查默认时间间隔</span><br><span class="line">        health-check-path: /actuator/health #健康检查默认请求路径</span><br><span class="line">        health-check-timeout: 5s #超时时间</span><br><span class="line">        #为服务生成一个32位随机字符作为实例名，并非最佳实践</span><br><span class="line">        #instance-id: $&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;</span><br><span class="line">        health-check-tls-skip-verify: true #跳过https校验</span><br><span class="line">        service-name: consumer-service</span><br><span class="line">        heartbeat: </span><br><span class="line">          enabled: true</span><br><span class="line">          ttl-value: 5</span><br><span class="line">          ttl-unit: s</span><br><span class="line">        prefer-ip-address: true #显示真实ip，而不是主机名</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之集群部署</title>
      <link href="/2018/11/18/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/11/18/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h1 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h1><p>根据上一章中的架构图，进行分布式部署</p><p>首先从<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">Consul官网</a>下载最新的安装包, 本文采用1.3.0版本</p><h2 id="服务器列表"><a href="#服务器列表" class="headerlink" title="服务器列表"></a>服务器列表</h2><table><thead><tr><th>节点类型</th><th>名称</th><th>ip</th></tr></thead><tbody><tr><td>server</td><td>server-01</td><td>10.9.188.187</td></tr><tr><td>server</td><td>server-02</td><td>10.9.171.147</td></tr><tr><td>server</td><td>server-03</td><td>10.9.39.37</td></tr><tr><td>client</td><td>client-01</td><td>10.9.181.34</td></tr><tr><td>client</td><td>client-02</td><td>10.9.117.128</td></tr></tbody></table><p>通过wget命令下载Consul到每台服务器中，可以在网页中右键”复制链接”获取下载地址</p><p>下载完成后，通过<code>unzip</code>命令解压</p><h2 id="启动server节点"><a href="#启动server节点" class="headerlink" title="启动server节点"></a>启动server节点</h2><p>启动的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span>=10.9.188.187 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=./data -datacenter=dc1 -node=server-01 &amp;</span><br></pre></td></tr></table></figure><p>新建<code>start.sh</code>，将以上命令拷贝进来，通过<code>sh start.sh</code>命令启动，接下来说明各个参数的含义</p><ol><li>-server：表示以server的身份启动agent</li><li>-bind：集群内部的通信地址，填写本机ip即可</li><li>-client：可以接受通信的客户端地址，<code>0.0.0.0</code>表示接收来自任意ip的客户端</li><li>-bootstrap-expect：预期的server节点数，只有达到了这个数目，才会形成server集群。注意所有server都应该配置一样的值</li><li>-data-dir：保存数据的目录，建议事先新建，server用它持久化集群状态</li><li>-datacenter：所在的数据中心，默认dc1</li><li>-node：节点名称，最终会显示在界面中</li></ol><h2 id="组建集群"><a href="#组建集群" class="headerlink" title="组建集群"></a>组建集群</h2><p>启动3个server节点之后，只是3个孤立的节点，需要用gossip协议互相告知，在Consul中，使用<code>join</code>命令加入集群</p><p>启动第二台server节点之后，就可以join到第一台server，第三台server节点加入任意一个即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul join 第一台的ip</span><br></pre></td></tr></table></figure><p>接着使用<code>members</code>检查集群成员</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul members</span><br></pre></td></tr></table></figure><p>显示3个Type为server的节点集群，同时3台服务的status为alive</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxjdws5ixuj326w050abp.jpg" alt=""></p><p>查看Server集群信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul operator raft list-peers</span><br></pre></td></tr></table></figure></p><p>可以看到Leader节点的信息<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyvjjfcknrj312c04swge.jpg" alt=""></p><h2 id="启动client节点"><a href="#启动client节点" class="headerlink" title="启动client节点"></a>启动client节点</h2><p>启动client的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -<span class="built_in">bind</span>=10.9.181.34 -data-dir=./data -client=0.0.0.0 -node=client-01 -ui &amp;</span><br></pre></td></tr></table></figure><p>参数说明</p><ol><li>-ui：启动ui界面，只需要有一个client加入这个参数即可</li><li>其他参数同 server，</li></ol><p>同样的使用join命令加入agent集群</p><h2 id="ui界面"><a href="#ui界面" class="headerlink" title="ui界面"></a>ui界面</h2><p>打开浏览器，输入10.9.181.34:8500，注意ip是添加了<code>-ui</code>参数的client地址</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxlfnff3vmj32780h2mze.jpg" alt="Consul控制台首页"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>Service显示我们的应用服务，其中默认显示了3个Server节点的Consul服务</li><li>Nodes显示所有的agent节点，包括server和client</li><li>K\V是一个key-vlaue存储，可用于分布式锁的实现</li><li>Consul提供了ACL功能，基于ip和port控制请求的畅通</li><li>Intention基于ACL，可以添加服务之间的通信规则，允许或者是禁止通信</li></ol><p>Services中Node Health的含义有些绕，指的是服务所在的agent节点中，通过检查(checks)的个数，check有三个状态：passing(通过), warning(警告),critical(危险)</p><p>节点中的checks包含且不限于健康检查，checks分为节点自身的健康状态检查，注册在节点上的服务的健康状态检查，以及自定义的健康状态检查</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Consul中的启动参数是非常多的，大多数参数都有默认值，完整的参数列表可在<a href="https://www.consul.io/docs/agent/options.html#command-line-options" target="_blank" rel="noopener">Consul 配置</a>中查到。</p><p>Consul按以下3个优先级接收参数：</p><ol><li>命令行参数</li><li>环境变量</li><li>配置文件</li></ol><p>Consul支持json和hcl格式的配置文件，同时也支持指定文件夹的方式，这将按照文件名的词法顺序加载配置文件，例如basic.json先于extra.json加载。后出现的配置项会覆盖前面的配置项</p><p>命令行参数的名称不一定完全和配置文件中的参数名称一样，例如：-node对应node_name</p><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><p>以下是一份配置文件的示例，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"datacenter"</span>: <span class="string">"dc1"</span>,</span><br><span class="line">    <span class="attr">"server"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"bootstrap_expect"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"node_name"</span>: <span class="string">"server-01"</span>,</span><br><span class="line">    <span class="attr">"bind_addr"</span>: <span class="string">"10.9.188.187"</span>,</span><br><span class="line">    <span class="attr">"client_addr"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"data_dir"</span>: <span class="string">"./data"</span>,</span><br><span class="line">    <span class="attr">"log_level"</span>: <span class="string">"INFO"</span>,</span><br><span class="line">    <span class="attr">"ports"</span>: &#123;</span><br><span class="line">        <span class="attr">"dns"</span>: <span class="number">8600</span>,</span><br><span class="line">        <span class="attr">"http"</span>: <span class="number">8500</span>,</span><br><span class="line">        <span class="attr">"server"</span>: <span class="number">8300</span>,</span><br><span class="line">        <span class="attr">"serf_lan"</span>: <span class="number">8301</span>,</span><br><span class="line">        <span class="attr">"serf_wan"</span>: <span class="number">8302</span>,</span><br><span class="line">        <span class="attr">"https"</span>: <span class="number">-1</span>,</span><br><span class="line">        <span class="attr">"grpc"</span>: <span class="number">-1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"start_join"</span>: [<span class="string">"10.9.181.34"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -config-dir=./config &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Consul实践之初识</title>
      <link href="/2018/11/16/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%9D%E8%AF%86/"/>
      <url>/2018/11/16/Consul%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%9D%E8%AF%86/</url>
      <content type="html"><![CDATA[<blockquote><p>Consul是HashiCorp公司推出的开源工具，提供服务发现，健康检查，K/V存储，多数据中心，ACL等功能，同时也是Service Mesh解决方案。</p></blockquote><h1 id="与其它注册中心的对比"><a href="#与其它注册中心的对比" class="headerlink" title="与其它注册中心的对比"></a>与其它注册中心的对比</h1><p>参考博主纯洁的微笑的文章：<a href="http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html" target="_blank" rel="noopener">springcloud(十三)：注册中心 Consul 使用详解</a></p><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>为什么有这一小节呢，本人刚接触到Consul时，对代理(agent)，client, server三者之间的关系没有搞清楚，以下对这几个概念做梳理，帮助新人快速理解</p><ul><li>代理：从Consul官网下载的zip包中，解压后只有一个启动文件，启动之后会运行一个Consul服务，你可以把这个服务理解为agent。agent分为两种，server和client，在启动agent的时候，可以通过参数指定是server还是client</li><li>agent集群：所有server和client节点形成的集群</li><li>server：server主要维护应用服务信息，响应查询，参与一致性选举，与别的数据中心交换信息。</li><li>server集群：server集群中的节点包括一个leader和多个follower，通过raft算法选举leader，保证一致性。server官方推荐的个数是一个数据中心有3或5个节点，一是为了高可用，二是奇数个方便选举，同时要保证server节点的存活数不低于（N/2）+1个，如3个server组成的集群，必须保证2个server存活，5个保证3个存活，否则server集群处于不可用状态</li><li>client：agent的另一种，主要用于转发RPC请求，本身是无状态的，运行在后台维护gossip协议池</li><li>datacenter：笔者对数据中心的理解还十分简陋，大概是机房的意思吧，将Consul部署到多个dc中，增加了可用性</li><li>gossip协议：翻译为流言协议，取自人类社会中的谣言传播，在Consul中用于管理agent和广播消息，在一个agent集群中新加入一个节点，或离开一个节点时，会通过gossip协议告诉集群中的所有节点，Consul的这些gossip协议功能是通过自家的另一个开源产品Serf实现的，这里对Serf要有个印象</li><li>LAN gossip与WAN gossip：分别代表一个数据中心中agent集群之间的的gossip协议，和多个数据中心之间的gossip协议</li></ul><h1 id="Consul的架构"><a href="#Consul的架构" class="headerlink" title="Consul的架构"></a>Consul的架构</h1><p>官网给出了两个数据中心的<a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="noopener">俯视图</a>，为了方便理解，笔者自己画了一个单数据中心的架构图，帮助大家理解</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxlh3wc72cj30mh0glwf0.jpg" alt="Consul架构"></p><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><ol><li>用3台服务器，部署3个server节点，形成server集群</li><li>每一台应用服务器上部署一个client节点，同时可以部署应用服务，可以是一个，可以是多个，视运维部署规则而定，一般生产环境每台服务器只部署一个应用</li><li>应用服务注册到本机的Consul client，通过它与server集群交互</li></ol><h1 id="Consul原理"><a href="#Consul原理" class="headerlink" title="Consul原理"></a>Consul原理</h1><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在写这一系列的文章时，笔者并不想一开始就实操，而是挈领提纲地介绍了Consul的原理，希望读者有个模糊的印象，在接下来的一步步操作中加深理解。</p>]]></content>
      
      <categories>
          
          <category> 微服务注册中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consul </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之请求参数校验</title>
      <link href="/2018/10/14/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2018/10/14/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之请求参数校验"><a href="#Spring-boot实践之请求参数校验" class="headerlink" title="Spring boot实践之请求参数校验"></a>Spring boot实践之请求参数校验</h1><blockquote><p>本文讲述的是后端参数校验，在实际开发中，参数校验是前后端都要做的工作，因为请求接口的人除了普通用户，还有有各路神仙。</p></blockquote><h2 id="常规校验的痛楚"><a href="#常规校验的痛楚" class="headerlink" title="常规校验的痛楚"></a>常规校验的痛楚</h2><p>通常的校验代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入用户名"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还有n个接口需要校验username，你可能会抽取<code>if</code>语句到一个方法中，过段时间你又会发现，不光要校验username，还要password，adress等等一堆字段，总结起来</p><ol><li>重复劳动</li><li>代码冗长，不利于阅读业务逻辑</li><li>出现问题要去不同的接口中查看校验逻辑</li></ol><p>这无疑是件让人崩溃的事情，此时作为一个开发人员，你已经意识到需要一个小而美的工具来解决这个问题，你可以去google，去github搜索这类项目，而不是毫无作为，抑或者是自己去造轮子</p><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><p>JSR303规范应运而生，其中比较出名的实现就是Hibernate Validator，已包含在<code>spring-boot-starter-web</code>其中,不需要重新引入，<code>javax.validation.constraints</code>包下常用的注解有</p><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">@NotNUll</td><td style="text-align:left">值不能为空</td></tr><tr><td style="text-align:left">@Null</td><td style="text-align:left">值必须为空</td></tr><tr><td style="text-align:left">@Pattern(regex=)</td><td style="text-align:left">值必须匹配正则表达式</td></tr><tr><td style="text-align:left">@Size(min=,max=)</td><td style="text-align:left">集合的大小必须在min~max之间，如List，数组</td></tr><tr><td style="text-align:left">@Length(min=,max=)</td><td style="text-align:left">字符串长度</td></tr><tr><td style="text-align:left">@Range(min,max)</td><td style="text-align:left">数字的区间范围</td></tr><tr><td style="text-align:left">@NotBlank</td><td style="text-align:left">字符串必须有字符</td></tr><tr><td style="text-align:left">@NotEmpty</td><td style="text-align:left">集合必须有元素，字符串</td></tr><tr><td style="text-align:left">@Email</td><td style="text-align:left">字符串必须是邮箱</td></tr><tr><td style="text-align:left">@URL</td><td style="text-align:left">字符串必须是url</td></tr><tr><td style="text-align:left">@AssertFalse</td><td style="text-align:left">值必须是false</td></tr><tr><td style="text-align:left">@AssertTrue</td><td style="text-align:left">值必须是true</td></tr><tr><td style="text-align:left">@DecimalMax(value=,inclusive=)</td><td style="text-align:left">值必须小于等于(inclusive=true)/小于(inclusive=false) value属性指定的值。可以注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@DecimalMin(value=,inclusive=)</td><td style="text-align:left">值必须大于等于(inclusive=true)/大f (inclusive=false) value属性指定的值。可以注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@Digits(integer-,fraction=)</td><td style="text-align:left">数字格式检查。integer指定整 数部分的最大长度，fraction指定小数部分的最大长度</td></tr><tr><td style="text-align:left">@Future</td><td style="text-align:left">值必须是未来的日期</td></tr><tr><td style="text-align:left">@Past</td><td style="text-align:left">值必须是过去的日期</td></tr><tr><td style="text-align:left">@Max(value=)</td><td style="text-align:left">值必须小于等于value指定的值。不能注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">@Min(value=)</td><td style="text-align:left">值必须大于等于value指定的值。不能注解在字符串类型的属性上</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><h2 id="校验实战"><a href="#校验实战" class="headerlink" title="校验实战"></a>校验实战</h2><p>接下来我们尝试一个入门例子,有一个User java bean, 为username字段加入@NotBlank注解，注意@NotBlank的包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"请输入用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表明将对username字段做非null，非空字符串校验，并为user参数添加@Valid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@RequestBody @Valid User user)</span></span></span><br></pre></td></tr></table></figure><p>按照<a href="">Spring boot实践之编写接口测试用例</a>编写一个测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBlankName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String params = <span class="string">"&#123;\"id\": 101,\"username\": \"\",\"password\": \"1234\"&#125;"</span>;</span><br><span class="line">    mockMvc.perform(post(<span class="string">"/user/login"</span>)</span><br><span class="line">    .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">    .content(params))</span><br><span class="line">    .andExpect(status().isBadRequest());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于参数为空，将返回BadRequest—400响应码，但是此时我们获取不到错误信息，由于spring的拦截，甚至你会发现不进方法断点，仅仅得到一个400响应码，对前端提示错误信息帮助不大，因此我们需要获取错误信息</p><h2 id="获取错误信息"><a href="#获取错误信息" class="headerlink" title="获取错误信息"></a>获取错误信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@Valid @RequestBody User user, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">        result.getFieldErrors().stream().forEach(error -&gt; &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们发现已经进入方法断点</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwdk366fb4j30s002eglr.jpg" alt="进入断点"></p><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>继续优化，想必大家也发现了，难道每个方法都要写<code>if</code>? 当然不用，ControllerAdvice不就是专门封装错误信息的吗，仿照<a href="">异常处理</a>中的处理方式，我们很容易写出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;MethodArgumentNotValidException.class&#125;)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseModel <span class="title">exception</span><span class="params">(MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">    ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">    model.setCode(HttpStatus.BAD_REQUEST.value());</span><br><span class="line">    model.setMsg(buildErrorMessage(ex));</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildErrorMessage</span><span class="params">(MethodArgumentNotValidException ex)</span></span>&#123;</span><br><span class="line">    List&lt;ObjectError&gt; objectErrors = ex.getBindingResult().getAllErrors();</span><br><span class="line">    StringBuilder messageBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    objectErrors.stream().forEach(error -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(error <span class="keyword">instanceof</span> FieldError)&#123;</span><br><span class="line">            FieldError fieldError = (FieldError) error;</span><br><span class="line">            messageBuilder.append(fieldError.getDefaultMessage()).append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    String message  = messageBuilder.deleteCharAt(messageBuilder.length() - <span class="number">1</span>).toString();</span><br><span class="line">    log.error(message);</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>除了使用<code>@ExceptionHandler</code>来捕获<code>MethodArgumentNotValidException</code>以外，还可以覆盖<code>ResponseEntityExceptionHandler</code>抽象类的handleMethodArgumentNotValid方法，但是二者不可以混用</p><h2 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h2><p>由于JSR303提供的注解有限，实际开发过程中校验往往需要结合实际需求，JSR303提供了自定义校验扩展接口</p><p>典型的一个请求场景是枚举类型参数，假设用户分为3类: 普通用户，VIP玩家，氪金玩家，分别用1，2，3表示，此时如何校验前端传入的值在范围内，抖机灵的朋友可能会想到@Range，万一是离散的不连续数呢？</p><p>自定义注解类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 指定校验类</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = InValidator.class)</span><br><span class="line"><span class="meta">@Target</span>( &#123; ElementType.METHOD, ElementType.FIELD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> In &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "必须在允许的数值内"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] values();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于分组校验</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的校验器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">In</span>, <span class="title">Number</span>&gt; </span>&#123;<span class="comment">// 校验Number类型 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; inValues;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(In in)</span> </span>&#123; </span><br><span class="line">    inValues = Sets.newHashSet();</span><br><span class="line">    <span class="keyword">int</span>[] arr = in.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">       inValues.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Number propertyValue, ConstraintValidatorContext cxt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyValue==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> inValues.contains(propertyValue.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，生产级别的参数校验基本完成</p><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>在不同接口中，指定不同的校验规则，如：</p><ol><li>不同的接口，校验不同的字段</li><li>同一个字段，在不同的接口中有不同的校验规则</li></ol><p>以下实现第一种情况</p><p>首先定义两个空接口，代表不同的分组，也就是不同的业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewUser</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RMBUser</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在指定校验规则时，指定分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(groups = &#123;NewUser.class&#125;, message = <span class="string">"请输入密码"</span>)   </span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@In</span>(groups = &#123;RMBUser.class&#125;, values = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, message = <span class="string">"非法的用户类型"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同的接口指定不同的校验分组"><a href="#不同的接口指定不同的校验分组" class="headerlink" title="不同的接口指定不同的校验分组"></a>不同的接口指定不同的校验分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略类定义...</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"normal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">normal</span><span class="params">(@Validated(&#123;NewUser.class&#125;)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"rmb"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">rmb</span><span class="params">(@Validated(&#123;RMBUser.class&#125;)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试用例</p><p>只检验密码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String params = <span class="string">"&#123;\"id\": 101,\"username\": \"tom\",\"password\": \"\",\"type\": \"5\"&#125;"</span>;</span><br><span class="line">       String result = mockMvc.perform(post(<span class="string">"/user/normal"</span>)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">               .content(params))</span><br><span class="line">               .andExpect(status().isBadRequest())</span><br><span class="line">               .andReturn().getResponse().getContentAsString();</span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：<code>{&quot;data&quot;:null,&quot;code&quot;:400,&quot;msg&quot;:&quot;请输入密码&quot;}</code><br>只检验用户类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRMB</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String params = <span class="string">"&#123;\"id\": 101,\"username\": \"tom\",\"password\": \"\",\"type\": \"5\"&#125;"</span>;</span><br><span class="line">       String result = mockMvc.perform(post(<span class="string">"/user/rmb"</span>)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">               .content(params))</span><br><span class="line">               .andExpect(status().isBadRequest())</span><br><span class="line">               .andReturn().getResponse().getContentAsString();</span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：<code>{&quot;data&quot;:null,&quot;code&quot;:400,&quot;msg&quot;:&quot;非法的用户类型&quot;}</code></p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之异常处理</title>
      <link href="/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之异常处理"><a href="#Spring-boot实践之异常处理" class="headerlink" title="Spring boot实践之异常处理"></a>Spring boot实践之异常处理</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一章<a href="">封装返回体</a>中，已经对请求成功的情况进行了封装，接下来便是处理异常，服务的生产者需要通过状态码此次请求是否成功，出现异常时，错误信息是什么，形如:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"FAILED"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常接口"><a href="#异常接口" class="headerlink" title="异常接口"></a>异常接口</h2><p>可以看出只需要<code>code</code>与<code>msg</code>, 参考 <code>org.springframework.http.HttpStatus</code>的实现，我们可以定义一个枚举来封装错误信息，对外暴露<code>getCode</code>，<code>getMsg</code>方法即可。由于异常属于一个基础模块，将这两个方法抽象到一个接口中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExceptionEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Integer <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常枚举"><a href="#异常枚举" class="headerlink" title="异常枚举"></a>异常枚举</h3><p>以用户模块为例，所有用户相关的业务异常信息封装到<code>UserError</code>中，例如用户不存在，密码错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UserError implements ExceptionEntity &#123;</span><br><span class="line"></span><br><span class="line">    NO_SUCH_USER(<span class="number">1</span>, <span class="string">"用户不存在"</span>),</span><br><span class="line">    ERROR_PASSWORD(<span class="number">2</span>, <span class="string">"密码错误"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer MODULE = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    UserError(Integer code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MODULE + <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h4><p>需要注意的地方是笔者定义了一个<code>MODULE</code>字段，10000代表用户微服务，这样在拿到错误信息之后，可以很快定位报错的应用</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// lombok自动生成构造方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    ExceptionEntity error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是错误接口与自定义异常属于公共模块，而<code>UserError</code>属于用户服务</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>之后，便可以抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(UserError.ERROR_PASSWORD);</span><br></pre></td></tr></table></figure><p>目前来看，我们只是较为优雅的封装了异常，此时请求接口返回的仍然是Spring boot默认的错误体，没有错误信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="string">"2018-10-18T12:28:59.150+0000"</span>,</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"No message available"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/user/error"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>接下来的异常拦截方式，各路神仙都有自己的方法，笔者只说Spring boot项目中比较通用的<code>@ControllerAdvice</code>，由于是Restful接口，这里使用<code>@RestControllerAdvice</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这属于基础模块，扫描路径不要包含具体的模块，用..代替</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>(basePackages=<span class="string">"com.ttyc..controller"</span>,annotations=&#123;RestController.class&#125;)</span><br><span class="line"><span class="comment">// lombok的日志简写</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionAdvisor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;ServiceException.class&#125;)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseModel <span class="title">handleServiceException</span><span class="params">(ServiceException ex)</span></span>&#123;</span><br><span class="line">        Integer code = ex.getError().getCode();</span><br><span class="line">        String msg = ex.getError().getMsg();</span><br><span class="line">        log.error(msg);</span><br><span class="line"></span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(code);</span><br><span class="line">        model.setMsg(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其他错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;Exception.class&#125;)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseModel <span class="title">exception</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> code = HttpStatus.INTERNAL_SERVER_ERROR.value();</span><br><span class="line">        String msg = HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase();</span><br><span class="line">        log.error(msg);</span><br><span class="line"></span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(code);</span><br><span class="line">        model.setMsg(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具有争议的一点是捕获<code>ServiceExcption</code>之后，应该返回200还是500的响应码，有的公司返回200，使用<code>code</code>字段判断成功失败，这完全没有问题，但是按照Restful的开发风格，这里的<code>@ResponseStatus</code>笔者返回了500，请读者根据自身情况返回响应码</p><h3 id="测试接口与测试用例"><a href="#测试接口与测试用例" class="headerlink" title="测试接口与测试用例"></a>测试接口与测试用例</h3><h4 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抛出业务异常示例</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(UserError.NO_SUCH_USER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testError</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String result =</span><br><span class="line">            mockMvc.perform(get(<span class="string">"/user/error"</span>))</span><br><span class="line">                    .andExpect(status().isInternalServerError())</span><br><span class="line">                    .andReturn().getResponse().getContentAsString();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"code"</span>: <span class="number">10001</span>,</span><br><span class="line"><span class="attr">"msg"</span>: <span class="string">"用户不存在"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之编写接口测试用例</title>
      <link href="/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
      <url>/2018/10/13/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之编写接口测试用例"><a href="#Spring-boot实践之编写接口测试用例" class="headerlink" title="Spring boot实践之编写接口测试用例"></a>Spring boot实践之编写接口测试用例</h1><blockquote><p> 测试用例对开发者降低bug率,方便测试人员回归测试有十分重要的意义。</p></blockquote><p>本文介绍如何使用<code>MockMvc</code>编写测试用例. </p><p>在Spring boot项目中编写测试用例十分简单，通常建立一个Spring boot项目都会test目录下生成一个Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以用户查询为例，通常有一个用户实体，以及<code>UserController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Data注解来自lombok</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getInfo方法是一个restful接口，模拟查询用户详情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"info"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getInfo</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>, required = <span class="keyword">true</span>)</span> String username)</span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(username + <span class="string">"s"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下通过MockMvc对象，测试<code>/user/info}</code>请求是否成功，并符合预期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入上下文对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化mockMvc对象</span></span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result =</span><br><span class="line">                <span class="comment">//执行get请求，这里有个小坑，第一个/必须有</span></span><br><span class="line">                mockMvc.perform(get(<span class="string">"/user/info"</span>)</span><br><span class="line">                        <span class="comment">//设置content-type请求头</span></span><br><span class="line">                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                        <span class="comment">//设置参数  </span></span><br><span class="line">                        .param(<span class="string">"name"</span>, <span class="string">"jay"</span>))</span><br><span class="line">                        <span class="comment">//预期的相应码是200-ok</span></span><br><span class="line">                        .andExpect(status().isOk())</span><br><span class="line">                        <span class="comment">//预测username的值为jays</span></span><br><span class="line">                        .andExpect(jsonPath(<span class="string">"$.username"</span>).value(<span class="string">"jays"</span>))</span><br><span class="line">                        <span class="comment">//获取响应体</span></span><br><span class="line">                        .andReturn().getResponse().getContentAsString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过测试，并输出响应体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">101</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"jays"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"1234"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>$.id</code>jsonpath的使用，参考<a href="https://github.com/json-path/JsonPath" target="_blank" rel="noopener">JsonPath</a></p><p>同时付一段使用json参数的post请求方式，大同小异，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String params = <span class="string">"&#123;\"id\": 101,\"username\": \"jason\",\"password\": \"1234\"&#125;"</span>;</span><br><span class="line">mockMvc.perform(post(<span class="string">"/user/login"</span>)</span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">        .content(params))</span><br><span class="line">        .andExpect(status().isOk());</span><br></pre></td></tr></table></figure><p>注意后端接受json格式参数的方式：<code>方法名(@RequestBody User user)</code> </p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之封装返回体</title>
      <link href="/2018/10/11/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BD%93/"/>
      <url>/2018/10/11/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BD%93/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot实践之封装返回体"><a href="#Spring-boot实践之封装返回体" class="headerlink" title="Spring boot实践之封装返回体"></a>Spring boot实践之封装返回体</h1><p>在实际开发中，一个项目会形成一套统一的返回体接口规范，常见的结构如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"SUCCESS"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: 真正的数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以根据自己的实际情况封装一个java bean，刑如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseModel</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring boot中，会将返回的实体类，通过jackson自动转换成json</p><p>Spring提供了<code>ResponseBodyAdvice</code>接口拦截响应体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseAdvisor</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Class aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MethodParameter methodParameter, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  MediaType mediaType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class aClass, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpRequest serverHttpRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpResponse serverHttpResponse)</span> </span>&#123;</span><br><span class="line">        ResponseModel model = <span class="keyword">new</span> ResponseModel();</span><br><span class="line">        model.setCode(<span class="number">0</span>);</span><br><span class="line">        model.setData(body);</span><br><span class="line">        model.setMsg(<span class="string">"SUCCESS"</span>);</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是一个最初的功能，值得优化的地方有很多，读者应根据自己的情况进行扩展</p><p>根据笔者遇到的情况，抛砖引玉一下</p><ol><li>是否需要对所有的响应拦截，可以在supports方法中判断</li><li>下载返回的是字节数据，再进行包装必然得不到正确的文件，不应该进行包装</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列:微服务注册中心——Eureka入门</title>
      <link href="/2018/09/10/Spring-Cloud%E7%B3%BB%E5%88%97-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%94%E2%80%94Eureka%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/10/Spring-Cloud%E7%B3%BB%E5%88%97-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%94%E2%80%94Eureka%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>作为一个没有经验的开发人员(捂脸），在了解Eureka之前，我更想让读者带着问题去思考</p><ol><li>什么是微服务注册中心，微服务为什么需要注册中心</li><li>注册中心都实现了哪些功能</li><li>开源的注册中心有哪些，为什么要选Eureka，优缺点有哪些</li><li>生产环境中的注册中心如何部署</li></ol><p>这些想法都是我敲完代码想要思考的，搭建一个注册中心几分钟的事，实在没什么技术含量，感觉收获到的东西太少，需要沉下来多思考</p><p>以下是Eureka server单机伪集群的配置方式：</p><p>1.首先Spring boot项目，加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>2.配置文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line">spring:</span><br><span class="line">  profiles: master</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-master</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer2:8001/eureka/</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">  server:</span><br><span class="line">    eviction-interval-timer-in-ms: 10000 # 每10s就去清理无效的实例</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">spring:</span><br><span class="line">  profiles: slave</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-slave</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer1:8000/eureka/</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">  server:</span><br><span class="line">    eviction-interval-timer-in-ms: 10000 # 每10s就去清理无效的实例</span><br><span class="line">    enable-self-preservation: false</span><br></pre></td></tr></table></figure></p><p>虽然复制粘贴到你的项目是件易事，不过有几个配置点笔者还是想要详细说一下：</p><ol><li>hostname配置了peer1、peer2，这是在模拟集群环境，需要读者自己在hosts文件中添加映射，<br><code>127.0.0.1     localhost peer1 peer2</code>.如果你的内存够大，也可以用两台虚拟机</li><li>对于Eureka来说，无效的实例是通过定时任务去清除的，默认是60s，这里我设置为了10s</li><li>IDEA中通过一个项目启动Eureka集群,通过spring.profiles.active区分配置<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw8r9iqvrgj30u0044my9.jpg" alt="点击Edit Configurations"><br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw8rfa3p3ej31kw0asn18.jpg" alt="点击加号新增Spring boot"></li></ol>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列: Spring Boot Admin</title>
      <link href="/2018/09/07/Spring-Cloud%E7%B3%BB%E5%88%97-Spring-Boot-Admin/"/>
      <url>/2018/09/07/Spring-Cloud%E7%B3%BB%E5%88%97-Spring-Boot-Admin/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了Spring Boot Admin的使用，参考Spring Boot Admin 2.0.2版本(以下简称SBA，来自官方)官方文档，主要实现了其中案例，也包括一些自己的想法</p><p>文档地址：<a href="http://codecentric.github.io/spring-boot-admin/current/" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/current/</a></p><p>以下文章内容的例子都可以在我的<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack" target="_blank" rel="noopener">GitHub</a>找到</p><h1 id="Spring-Boot-Admin介绍"><a href="#Spring-Boot-Admin介绍" class="headerlink" title="Spring Boot Admin介绍"></a>Spring Boot Admin介绍</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>SBA是一个用于管理和监控Spring Boot项目的工具，包括线程，内存，Spring bean加载情况，日志等一系列可视化界面</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>熟悉Spring Boot的读者都知道Spring Boot actuator这款组件，它使用HTTP端点或JMX来管理和监控应用程序，但是没有提供图形化界面，仅仅提供了JSON格式的数据，同时无法做到集中管理应用，对运维十分不友好，SBA基于actuator不但解决了这些痛点，并且通过扩展实现了很多强大的功能，如日志级别动态更改，查看实时日志，查看URL映射等等，对管理微服务十分有意义</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>环境的搭建将配合注册中心Eureka，当然也可以不使用注册中心，参考<a href="http://codecentric.github.io/spring-boot-admin/current/#set-up-admin-server" target="_blank" rel="noopener">Spring Boot Admin Server</a>一节,或使用别的注册中心，如<a href="http://cloud.spring.io/spring-cloud-consul/" target="_blank" rel="noopener">Consul</a>，Zookeeper，这些官方都已经在github给出了<a href="https://github.com/codecentric/spring-boot-admin/tree/master/spring-boot-admin-samples" target="_blank" rel="noopener">案例</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>服务端和客户端均加入了spring-security组件，同时都配置了关闭请求拦截和跨域防范，详见笔者的GitHub<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack" target="_blank" rel="noopener">Spring-Cloud-Stack</a>项目，<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-server" target="_blank" rel="noopener">admin-server</a>和<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-client" target="_blank" rel="noopener">admin-client</a>模块<br><strong>注意：</strong> 按常理IDEA在勾选依赖生成项目之后，会加入bom版本管理，可是笔者也遇到了没有自动生成的情况，请读者注意pom文件是否有以下内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="SBA-服务端"><a href="#SBA-服务端" class="headerlink" title="SBA 服务端"></a>SBA 服务端</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注册Eureka并添加-EnableAdminServer注解"><a href="#注册Eureka并添加-EnableAdminServer注解" class="headerlink" title="注册Eureka并添加@EnableAdminServer注解"></a>注册Eureka并添加@EnableAdminServer注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminServerApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(AdminServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-security配置"><a href="#spring-security配置" class="headerlink" title="spring-security配置"></a>spring-security配置</h3><p><code>anyRequest.permitAll</code>表示允许所有请求通过校验<br><code>csrf.disable</code>表示关闭跨域防范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityPermitAllConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().permitAll()  </span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><p>简要说明: 主要配置端口，eureka，必须暴露所有web actuator断点，生产环境考虑到安全性，应当酌情开放，最后配置了spring-security的用户名和密码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8115</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8000/eureka/,http://localhost:8001/eureka/</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">  endpoint:</span></span><br><span class="line"><span class="attr">    health:</span></span><br><span class="line"><span class="attr">      show-details:</span> <span class="string">ALWAYS</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    user:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><h2 id="SBA-客户端"><a href="#SBA-客户端" class="headerlink" title="SBA 客户端"></a>SBA 客户端</h2><h2 id="pom依赖-1"><a href="#pom依赖-1" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-Security配置"><a href="#Spring-Security配置" class="headerlink" title="Spring-Security配置"></a>Spring-Security配置</h2><p><a href="#spring-security配置">同服务端</a></p><h2 id="yml配置-1"><a href="#yml配置-1" class="headerlink" title="yml配置"></a>yml配置</h2><p>这里提一个小坑点, server的地址必须加<strong>http://</strong> 前缀，否则会在启动日志中看到WARN，注册失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8116</span><br><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8115</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: user</span><br><span class="line">      password: admin</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: ALWAYS</span><br></pre></td></tr></table></figure><h1 id="最初效果"><a href="#最初效果" class="headerlink" title="最初效果"></a>最初效果</h1><p>在启动注册中心，以及服务端，客户端之后，打开<a href="http://localhost:8115" target="_blank" rel="noopener">http://localhost:8115</a>，输入配置的用户名和密码即可登录</p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>java.io.IOException: Broken pipe, SBA 的issue中有回复：</p><p>This is a quite normal. The browser does some long polling and keeps the tcp connection open. If the browser window is closed the tcp connection is aborted and on the next write the exception is thrown. there is nothing to do about this, except changing the loglevel.<br>这是很正常的。浏览器执行一些长轮询并保持TCP连接打开。如果浏览器窗口关闭，则中止TCP连接，并在下一次写入时抛出异常。除了更改日志级别之外，这没有什么可做的。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="UI配置"><a href="#UI配置" class="headerlink" title="UI配置"></a>UI配置</h2><h3 id="如何显示项目的版本号"><a href="#如何显示项目的版本号" class="headerlink" title="如何显示项目的版本号"></a>如何显示项目的版本号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  version: @project.version@</span><br></pre></td></tr></table></figure><p>此处的project.version引用了maven中的变量</p><p>效果图如下</p><p><img src="https://ws4.sinaimg.cn/large/0069RVTdly1fv136xsz3yj31kw0b63zz.jpg" width="65%" align="left"></p><h2 id="查看实时滚动日志"><a href="#查看实时滚动日志" class="headerlink" title="查看实时滚动日志"></a>查看实时滚动日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  file: client.log</span><br></pre></td></tr></table></figure><p>配置日志文件位置即可，根据官方文档说明，SBA可以自动检测出url链接，同时支持日志颜色配置，但是项目启动时报错，遂放弃之<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.pattern.file=%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr(%5p) %clr($&#123;PID&#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n%wEx</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>日志效果如下图：<br><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fv13clxp0qj31kw0d9wts.jpg" width="65%" align="left"></p><p>可以看到提供了下载按钮，其实是打开了一个网页页签，可复制出来，中文日志会出现乱码</p><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>tag可以给每一个客户端标识，有两种途径加入tag:</p><h3 id="1-元数据"><a href="#1-元数据" class="headerlink" title="1. 元数据"></a>1. 元数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8115</span><br><span class="line">        instance:</span><br><span class="line">          metadata:</span><br><span class="line">            tags:</span><br><span class="line">              content: mesh</span><br></pre></td></tr></table></figure><h3 id="2-info端点"><a href="#2-info端点" class="headerlink" title="2. info端点"></a>2. info端点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  tags:</span><br><span class="line">    title: mosi</span><br></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fv13qitypfj30x80mkjt8.jpg" width="65%" align="left"></p><p><strong>值得注意的是，两种方式的k-v表现形式, 第一个是tags.content为key，第二个是tags为key</strong></p><h2 id="静态配置客户端"><a href="#静态配置客户端" class="headerlink" title="静态配置客户端"></a>静态配置客户端</h2><p>这一小节的内容单独用了两个项目，分别是<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-static-client" target="_blank" rel="noopener">admin-static-client</a>，<a href="https://github.com/GreedyPirate/Spring-Cloud-Stack/tree/master/admin-static-server" target="_blank" rel="noopener">admin-static-server</a></p><p>通过Spring Cloud提供的静态配置，SBA支持静态配置client，首先建立客户端项目，只需要web，actuator两个依赖即可，</p><p>server端将Eureka依赖改为如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>接下来配置客户端的地址等信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    discovery:</span><br><span class="line">      client:</span><br><span class="line">        simple:</span><br><span class="line">          instances:</span><br><span class="line">            admin-static-client:</span><br><span class="line">              - uri: http://localhost:8117</span><br><span class="line">                metadata:</span><br><span class="line">                  management.context-path: /actuator</span><br></pre></td></tr></table></figure></p><p>admin-static-client将是在界面上显示的客户端地址</p><h1 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h1><h2 id="邮件提醒"><a href="#邮件提醒" class="headerlink" title="邮件提醒"></a>邮件提醒</h2><p>当注册在SBA server上的应用出现DOWN/OFFLINE等情况时，需要通过告警的方式告知运维人员，而邮件告警是常用的方式之一，SBA支持邮件告警，使用了spring-boot-mail组件来完成这一功能，需要在server端做以下工作：</p><p><strong>注: </strong> 以下邮件有关内容,通常情况需要获取授权码，以qq邮箱为例，请参照<a href="http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256" target="_blank" rel="noopener">http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256</a>获取授权码</p><h3 id="pom中加入依赖"><a href="#pom中加入依赖" class="headerlink" title="pom中加入依赖"></a>pom中加入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="需要的配置如下"><a href="#需要的配置如下" class="headerlink" title="需要的配置如下"></a>需要的配置如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">boot:</span><br><span class="line">  admin:</span><br><span class="line">    ui:</span><br><span class="line">      title: &quot;Spring Boot Admin监控管理中心&quot;</span><br><span class="line">    notify:</span><br><span class="line">      mail:</span><br><span class="line">        from: 发送方</span><br><span class="line">        to: 收件方，多个逗号分隔</span><br><span class="line">        cc: 抄送，多个逗号分隔</span><br><span class="line">        template: classpath:/META-INF/spring-boot-admin-server/mail/status-changed.html # 定制邮件模板，请参考官方实现</span><br><span class="line">mail:</span><br><span class="line">  host: smtp.qq.com</span><br><span class="line">  port: 25</span><br><span class="line">  username: 发送方用户名</span><br><span class="line">  password: 授权码</span><br><span class="line">  protocol: smtp</span><br><span class="line">  test-connection: false</span><br><span class="line">  properties:</span><br><span class="line">    mail:</span><br><span class="line">      smtp:</span><br><span class="line">        auth: true</span><br><span class="line">        starttls:</span><br><span class="line">          enable: true</span><br><span class="line">          required: true</span><br></pre></td></tr></table></figure><h3 id="最终收到的邮件如图"><a href="#最终收到的邮件如图" class="headerlink" title="最终收到的邮件如图"></a>最终收到的邮件如图</h3><p>将客户端下线之后，收到的邮件如下<br><img src="https://ws4.sinaimg.cn/large/0069RVTdly1fv4hbx46zfj30we0lk41e.jpg" width="65%" align="left"></p><p>余下的第三方应用接入以及安全防护不再介绍，直接进入自定义通知</p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p>当应用(实例)宕机时，服务端应该主动通知运维人员，达到告警的作用，在SBA中提供了这样的扩展，可以继承<code>AbstractEventNotifier</code>或<code>AbstractStatusChangeNotifier</code>，由于二者属于继承关系，读者直接继承AbstractStatusChangeNotifier即可</p><p><strong>注: </strong>通知的方式有很多种，如钉钉，邮件，短信，大家按需扩展即可，以邮件举例，注入<code>JavaMailSender</code>对象即可实现邮件报警</p><p>下面给出一个告警样例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNotifier</span> <span class="keyword">extends</span> <span class="title">AbstractStatusChangeNotifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger LOGGER = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNotifier</span><span class="params">(InstanceRepository repositpry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(repositpry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">doNotify</span><span class="params">(InstanceEvent event, Instance instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> InstanceStatusChangedEvent) &#123;</span><br><span class="line">                StatusInfo statusInfo = ((InstanceStatusChangedEvent) event).getStatusInfo();</span><br><span class="line">                String status = statusInfo.getStatus();</span><br><span class="line">                Map&lt;String, Object&gt; details = statusInfo.getDetails();</span><br><span class="line">                String detailStr = details.toString();</span><br><span class="line">                <span class="keyword">boolean</span> isOffline = statusInfo.isOffline();</span><br><span class="line">                LOGGER.info(<span class="string">"status info are: status:&#123;&#125;, detail:&#123;&#125;, isOffline:&#123;&#125;"</span>, status, detailStr, isOffline);</span><br><span class="line"></span><br><span class="line">                String mavenVersion = instance.getBuildVersion().getValue();</span><br><span class="line">                String healthUrl = instance.getRegistration().getHealthUrl();</span><br><span class="line">                LOGGER.info(<span class="string">"instance build version is &#123;&#125;, health check url is &#123;&#125;"</span>, mavenVersion, healthUrl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取事件信息，instance(客户端)信息，包括前面说过的元信息，可用来发钉钉消息，短信等等的通知</span></span><br><span class="line">                LOGGER.info(<span class="string">"Instance &#123;&#125; (&#123;&#125;) is &#123;&#125;"</span>, instance.getRegistration().getName(), event.getInstance(),</span><br><span class="line">                        ((InstanceStatusChangedEvent) event).getStatusInfo().getStatus());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"Instance &#123;&#125; (&#123;&#125;) &#123;&#125;"</span>, instance.getRegistration().getName(), event.getInstance(),</span><br><span class="line">                        event.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>最后聊聊一些细节内容，读者有需求的可深入了解</p><ol><li>对于监控的url请求，可以<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-headers" target="_blank" rel="noopener">添加header</a>，并对request，response<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-instance-filter" target="_blank" rel="noopener">拦截</a></li><li>使用2.0的服务端监控1.5版本的spring boot客户端，需要做一些<a href="http://codecentric.github.io/spring-boot-admin/current/#monitoring-spring-boot-1.5.x" target="_blank" rel="noopener">兼容处理</a></li><li>扩展UI，由于2.0使用了Vue.js重构，可以很方便的<a href="http://codecentric.github.io/spring-boot-admin/current/#customizing-custom-views" target="_blank" rel="noopener">扩展</a></li></ol><p>完结撒花</p>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 监控 </tag>
            
            <tag> 官方文档阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud Sleuth 官方文档阅读</title>
      <link href="/2018/08/29/Spring-Cloud-Sleuth-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/"/>
      <url>/2018/08/29/Spring-Cloud-Sleuth-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>Spring Cloud Sleuth 版本 2.x</p><p>文档地址：<a href="http://cloud.spring.io/spring-cloud-sleuth/2.0.x/single/spring-cloud-sleuth.html" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-sleuth/2.0.x/single/spring-cloud-sleuth.html</a></p><h2 id="遇到的英文单词"><a href="#遇到的英文单词" class="headerlink" title="遇到的英文单词"></a>遇到的英文单词</h2><ul><li>reveals: 揭示</li><li>network latency: 网络延迟</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>一次请求中每个微服务的处理过程叫一个span，可以理解为一次请求链路中的最小单元，用一个64位的唯一ID标识，span中有若干描述信息，如：ID，产生的时间戳，IP地址，服务名等</p><p>如果是入口服务，那么span的id等于trace id</p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>一次请求经过若干个微服务，汇总每一个服务的span，最终形成一个树状的数据结构</p><h3 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h3><p>用来记录事件信息，表示请求的开始和结束，主要包含以下4个：</p><ol><li>cs:client send 客户端发起请求，标识一个span的开始</li><li><p>sr:server received 服务端接收请求，开始处理请求，此时产生的ts(时间戳，以下统称为ts)减去cs的ts，可以计算出网络传输时间</p></li><li><p>ss:server send 服务端处理结束，开始响应客户端，此时的ts减去sr的ts，就是服务端请求处理时间</p></li><li>cr:client received 客户端接收到服务端的响应，此时的ts减去cs的ts，就是一次请求所消耗的时间</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 监控 </tag>
            
            <tag> 官方文档阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux命令手记</title>
      <link href="/2018/08/27/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E8%AE%B0/"/>
      <url>/2018/08/27/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="从后往前查看日志"><a href="#从后往前查看日志" class="headerlink" title="从后往前查看日志"></a>从后往前查看日志</h2><ol><li>less 文件名</li><li>shift+g跳转到末尾，向上滑动</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>首先不推荐cat,vim等命令,大日志文件容易导致内存不足，线上排查问题时容易引起服务崩溃</p><p>有时想要查看最后五分钟内的日志，tail命令指定行数也可以大致做到，但是行数不好指定时，less会很方便</p><h2 id="查找进程命令如何排除自带的grep"><a href="#查找进程命令如何排除自带的grep" class="headerlink" title="查找进程命令如何排除自带的grep"></a>查找进程命令如何排除自带的grep</h2><p>这个技巧常用在编写shell脚本时，希望查找到某个进程的pid，但是grep命令本身也会产生一条数据，因此需要排除<br>例如查找xxx进程时<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep xxx |grep -v <span class="string">'grep'</span></span><br></pre></td></tr></table></figure></p><h2 id="查看前十个最占内存的应用"><a href="#查看前十个最占内存的应用" class="headerlink" title="查看前十个最占内存的应用"></a>查看前十个最占内存的应用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head</span><br></pre></td></tr></table></figure><h2 id="按端口终止进程"><a href="#按端口终止进程" class="headerlink" title="按端口终止进程"></a>按端口终止进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">PORT=2181</span><br><span class="line">PID=`lsof -i:<span class="variable">$&#123;PORT&#125;</span> |grep -v PID |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;PID&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"kill pid : <span class="variable">$&#123;PID&#125;</span>"</span></span><br><span class="line">        <span class="built_in">kill</span> <span class="variable">$&#123;PID&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"could not find process with port:<span class="variable">$&#123;PORT&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="生成UUID"><a href="#生成UUID" class="headerlink" title="生成UUID"></a>生成UUID</h2><p>uuidgen命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uuidgen</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d4586ba5-22da-42e5-9662-acad5942988d</span><br></pre></td></tr></table></figure><h2 id="启动shell脚本"><a href="#启动shell脚本" class="headerlink" title="启动shell脚本"></a>启动shell脚本</h2><p>编写shell脚本之后，可以通过<code>chmod +x</code>的方式，然后启动，不过用<code>sh 脚本名</code>的方式更加简洁，目前没有对比二者的优劣</p><h2 id="查找占用磁盘空间的文件"><a href="#查找占用磁盘空间的文件" class="headerlink" title="查找占用磁盘空间的文件"></a>查找占用磁盘空间的文件</h2><p>一层一层目录查找最占磁盘空间的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure><p>持续积累中 ……</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>适配器模式</title>
      <link href="/2018/08/14/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/14/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud系列前言</title>
      <link href="/2018/08/10/Spring-Cloud%E7%B3%BB%E5%88%97%E5%89%8D%E8%A8%80/"/>
      <url>/2018/08/10/Spring-Cloud%E7%B3%BB%E5%88%97%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>笔者一些无聊的思考，也有一些对新手的建议</p><ol><li>了解一个新技术之前，它为什么出现，解决了什么问题，和现有的解决方案相比，它有什么优点，又有什么缺点(没有完美的方案)</li><li>DevOps，微服务dev易，ops难，有哪些技术可以实现ops，做到可持续交付，微服务的监控，管理怎么做，如何减少排查问题的复杂度</li><li>微服务如何根据业务拆分模块</li><li>Spring Cloud如何实现真正意义上的多语言，不要觉得公司只用java，同时用PHP，Go，Python太正常了，举个例子，阿里收购个公司，发现用的不是java就不收购了？收购之后要整合业务就让别人全改成java吗，现有的”老”系统重做吗</li><li>一口就吃个大胖子，一套框架解决公司所有业务？不可能的，架构应该遵循演进式原则</li><li>如何去学习Spring Cloud，由于Spring Boot 1.x版本和2.x版本的差别较大，往往因为一些教程的版本落后让人痛不欲生，所以自己摸索是一方面，比如找最新的教程，遇到问题多看官方文档也是个好习惯</li><li>关于看英文文档，只是一个适应的过程，下载一个有道翻译，只要有一些英语基础的人都能看懂，ps:本人四级考了2次飘过的学渣，:)逃，看多英文文档之后，甚至有种看不进去中文翻译的感觉，因为不好理解，还不如看英文，虽然浪费点时间，但是理解的快</li><li>关于遇到问题如何解决这件事，给新人一些建议，不要问leader一些很low的问题，我本人属于内向的人，习惯do my best之后再去问人，说下我的解决思路<ol><li>首先尽量看懂英文的错误提示</li><li>百度能帮你解决很多”常见”的问题</li><li>百度也不是个好东西，遇到难题，就会发现天下文章一大抄，抄来抄去就那么几篇</li><li>谷歌，多留意Stack Overflow的网站，同样需要你有耐心看懂英文</li><li>既然是开源项目，为什么不去github的issue搜一搜，笔者很喜欢这样做，不急的问题搜不到提个issue也比去某个论坛强</li><li>现在Github流行gitter在线聊天，可以更好和别人交流，尤其是项目作者。ps: 也可以看看别人的问题，毕竟都是坑</li><li>当然这些要看问题的具体情况，比如一个业务问题，你去github是没有意义的，最后多看官方文档，会避免很多问题，也会给你解决问题带来思路</li></ol></li><li>如何减少bug量，请正视测试用例，测试用例，测试用例</li></ol><p>咳咳，接下来说正题，<strong>Spring cloud</strong></p><p>在学习Spring cloud之后，我对它最直观的理解是: Spring cloud是用于构建分布式系统的一组通用工具集，秉承Spring的集成理念，Spring cloud并不会自己去开发一套工具，而是集成业界现有的优秀开源项目，这里的优秀必然是经得起生产环境验证，并且持续维护。Spring cloud自1.0开始就集成了Netflix OSS套件，通过Spring boot的autoconfigure简化配置，并且为其注入Spring运行环境，让开发者通过几个简单的注解就构建一个基于Netflix生产级别的分布式系统</p>]]></content>
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring 使用TransactionSynchronizationManager在事务提交之后操作</title>
      <link href="/2018/08/04/Spring-%E4%BD%BF%E7%94%A8TransactionSynchronizationManager%E5%9C%A8%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%90%8E%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/08/04/Spring-%E4%BD%BF%E7%94%A8TransactionSynchronizationManager%E5%9C%A8%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%90%8E%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>需求: 在事务执行成功后，再去进行某一项操作,如发送邮件、短信等，此类事件通常是非及时触发的，所以采用异步执行</p><h2 id="TransactionSynchronizationManager"><a href="#TransactionSynchronizationManager" class="headerlink" title="TransactionSynchronizationManager"></a>TransactionSynchronizationManager</h2><p>使用TransactionSynchronizationManager注册一个事务同步适配器，以下代码会在插入一个User对象后输出一段文字，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">regist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User jack = User.builder().name(<span class="string">"jack"</span>).phone(<span class="string">"110"</span>).build();</span><br><span class="line">    userDao.save(jack);</span><br><span class="line"></span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"send a mail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"fail insert"</span>);</span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getOrder方法的作用:<em>They will be executed in an order according to their order value (if any)</em></p><p>注册的适配器按照顺序执行，例如我可以先发邮件，再发短信，但在异步机制中无法保证有序</p><p><code>TransactionSynchronization</code>接口中还提供了以下方法</p><ul><li>beforeCommit：事务提交之前，在<code>beforeCompletion</code>之前</li><li>beforeCompletion: 事务提交/回滚之前</li><li>afterCompletion: 事务提交/回滚之后</li></ul><h2 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h2><p>初始化一个线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写异步任务代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class NotifyService &#123;</span><br><span class="line">    @Async</span><br><span class="line">    public void sendMail(String message)&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在afterCommit中调用即可</p><p>参考：</p><ol><li><a href="https://segmentfault.com/a/1190000004235193" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004235193</a></li><li><a href="http://azagorneanu.blogspot.com/2013/06/transaction-synchronization-callbacks.html" target="_blank" rel="noopener">http://azagorneanu.blogspot.com/2013/06/transaction-synchronization-callbacks.html</a></li></ol>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot实践之事件监听</title>
      <link href="/2018/07/31/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
      <url>/2018/07/31/Spring-boot%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
      <content type="html"><![CDATA[<p>在Spring Boot doc的<em>Application Events and Listeners</em>一章中提到，Spring Boot按以下顺序提供了6个事件，供开发者编写<code>ApplicationListener</code>监听相应的事件</p><pre><code>1.ApplicationStartingEvent：在开始运行时，监听器注册和初始化之后被触发2.ApplicationEnvironmentPreparedEvent：发现 Environment 被上下文使用时，上下文被创建之前触发3.ApplicationPreparedEvent：在启动刷新之前，bean定义被加载之后被触发4.ApplicationStartedEvent：上下文刷新之前，应用和命令行启动器运行之前触发5.ApplicationReadyEvent：在所有应用和命令行启动器调用之后，这表明应用已经准备好处理请求6.ApplicationFailedEvent：启动时出现异常触发</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>编写代码的难度不高，读者可根据自己的需求编写相应的listener，以ApplicationStartingEvent为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringBootListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationStartingEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;listening spring boot starting event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>根据文档中的提示，可以使用三种方式添加这6个事件的监听器</p><p>1.通过SpringApplication的addApplicationListener方法添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(SpringBootDocApplication.class,args).addApplicationListener(<span class="keyword">new</span> SpringBootListener());</span><br></pre></td></tr></table></figure><p>2.类似的用SpringApplicationBuilder实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(SpringBootDocApplication.class).listeners(<span class="keyword">new</span> SpringBootListener()).run(args);</span><br></pre></td></tr></table></figure><p>3.如果Listener很多，也可以写在配置文件中，在resources目录下新建META-INF/spring.factories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=com.ttyc.doc.extend.event.customer.SpringBootListener</span><br></pre></td></tr></table></figure><p>最终项目一启动便输出: listening spring boot starting event</p>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一个对象的属性发生改变时，需要通知到依赖它的对象并自动更新</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>针对使用场景，如何用代码去实现这种效果，只要理解了观察者模式的基本原理，代码一目了然</p><ol><li>首先明确有两个对象: 观察者，被观察者，我更喜欢理解为监视器和目标</li><li>目标对象里维护一个注册列表，里面记录了注册过的监视器，对外提供注册列表的添加和移除api</li><li>目标发生改变时，遍历这个列表里的所有监视器，通过调用监视器的一个方法通知监视器</li></ol><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>原理并不难，可以说十分简单，两个类，注册列表用一个List集合表示，是否发生改变用一个布尔值表示，很容易手写出来。</p><p>首先是目标类，读者根据上述思路阅读代码应该没有什么障碍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要发生改变的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视器的注册列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Monitor&gt; monitors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否发生改变的标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registMonitor</span><span class="params">(Monitor monitor)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(monitor);</span><br><span class="line">        monitors.add(monitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注销监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregistMonitor</span><span class="params">(Monitor monitor)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(monitor);</span><br><span class="line">        monitors.remove(monitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.isChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.notifyMonitor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知监视器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (monitors.size() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.isChanged)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Monitor monitor: monitors)&#123;</span><br><span class="line">                monitor.update(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通知结束后清除标志位</span></span><br><span class="line">            <span class="keyword">this</span>.isChanged = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是监视者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起个名字</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据目前对象发生的改变，做出反应</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前监视器为："</span> + getName() + <span class="string">",监视的对象已发生改变，目标名称为："</span> + target.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过测试类测试一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Monitor monitor1 = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor1.setName(<span class="string">"1号"</span>);</span><br><span class="line">        Monitor monitor2 = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor2.setName(<span class="string">"2号"</span>);</span><br><span class="line"></span><br><span class="line">        Target target = <span class="keyword">new</span> Target();</span><br><span class="line">        <span class="comment">// 测试两个监视器</span></span><br><span class="line">        target.registMonitor(monitor1);</span><br><span class="line">        target.registMonitor(monitor2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变属性</span></span><br><span class="line">        target.setName(<span class="string">"jim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注销其中一个</span></span><br><span class="line">        target.deregistMonitor(monitor1);</span><br><span class="line">        target.setName(<span class="string">"tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前监视器为：1号,监视的对象已发生改变，目标名称为：jim</span><br><span class="line">当前监视器为：2号,监视的对象已发生改变，目标名称为：jim</span><br><span class="line">当前监视器为：2号,监视的对象已发生改变，目标名称为：tom</span><br></pre></td></tr></table></figure><p>说明通知成功，并且注销监视器对象后，不再接收到通知</p><h2 id="JDK自带的观察者模式接口"><a href="#JDK自带的观察者模式接口" class="headerlink" title="JDK自带的观察者模式接口"></a>JDK自带的观察者模式接口</h2><p>为什么要用JDK自带的Observable(被观察者)，Observer(观察者)呢？</p><p>点开Observable的源码，since JDK1.0就有的一个类，十分古老，所以出现Vector也不足为奇了，再看里面的方法，关于修改Vector和changed的地方都被synchronized修饰，说明JDK对线程安全性考虑的很好</p><h2 id="JDK源码"><a href="#JDK源码" class="headerlink" title="JDK源码"></a>JDK源码</h2><p>Observable类中用于通知观察者的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自己翻译了下注释：我们不希望观察者在处理自己的监视器时，</span></span><br><span class="line"><span class="comment">         * 回调到所有的代码。我们从集合里取出每一个被观察者，并且</span></span><br><span class="line"><span class="comment">         * 存储观察者的需要同步的状态，但是不应该通知观察者们。</span></span><br><span class="line"><span class="comment">         * 任意竞争锁的最糟糕结果是</span></span><br><span class="line"><span class="comment">         *  1.一个新增的观察者可能错过通知</span></span><br><span class="line"><span class="comment">         *  2.一个最近注销的观察者在它不需要的时候被通知了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            ((Observer) arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现流程大致类似</p><h2 id="JDK方式代码实现"><a href="#JDK方式代码实现" class="headerlink" title="JDK方式代码实现"></a>JDK方式代码实现</h2><h3 id="Step-1-被观察者"><a href="#Step-1-被观察者" class="headerlink" title="Step 1: 被观察者"></a>Step 1: 被观察者</h3><p>继承Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(<span class="string">"name has been changed, now is "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-观察者"><a href="#Step-2-观察者" class="headerlink" title="Step 2: 观察者"></a>Step 2: 观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        Target target = (Target) o;</span><br><span class="line">        System.out.println(<span class="string">"I am be notified by "</span> + target.getName() + <span class="string">", message is "</span> + arg);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-验证"><a href="#Step-3-验证" class="headerlink" title="Step 3: 验证"></a>Step 3: 验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Target();</span><br><span class="line"></span><br><span class="line">        Watcher foo = <span class="keyword">new</span> Watcher();</span><br><span class="line">        Watcher bar = <span class="keyword">new</span> Watcher();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        target.addObserver(foo);</span><br><span class="line">        target.addObserver(bar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标发生改变, 自动通知监视器，并调用update方法</span></span><br><span class="line">        target.setName(<span class="string">"Jim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除监视器</span></span><br><span class="line">        target.deleteObserver(bar);</span><br><span class="line">        target.setName(<span class="string">"Kim"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>第一次setName通知了两个观察者，然后移除了bar观察者，下一次通知就只有一个观察者收到了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am be notified by Jim, message is name has been changed, now is Jim</span><br><span class="line">I am be notified by Jim, message is name has been changed, now is Jim</span><br><span class="line">I am be notified by Kim, message is name has been changed, now is Kim</span><br></pre></td></tr></table></figure><p>如果对JDK自带的线程安全实现方式不满意，可以自行实现这两个类</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring ContextRefreshedEvent事件</title>
      <link href="/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/"/>
      <url>/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">遇到的单词</span><br><span class="line">infrastructure ： 基础设施</span><br><span class="line">arbitrary : 任何的，所有的</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文主要在<a href="https://greedypirate.github.io/2018/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a>的基础上研究Spring中的事件机制</p><p>ApplicationListener监听以下4个事件：ContextStartedEvent，ContextRefreshedEvent，ContextStartedEvent，ContextClosedEvent</p><p>实现对ApplicationContext刷新或初始化时的监听，测试中未出现加载两次的情况，如果需要加入<code>event.getApplicationContext().getParent()</code>判断</p><h2 id="监听ContextRefreshedEvent"><a href="#监听ContextRefreshedEvent" class="headerlink" title="监听ContextRefreshedEvent"></a>监听ContextRefreshedEvent</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextEnvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring Refreshed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自从Spring 4.2以后，可以使用@EventListener注解实现，相信用过Spring-Kafka的读者不会陌生这种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotateContextEvent</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRefresh</span><span class="params">(ContextRefreshedEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring Refreshed by annotated approach"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>实现起来很简单，接下来尝试下Spring中的自定义事件</p><p>自定义事件需要继承ApplicationEvent，这个类并没有什么深意，只是简单封装EventObject加入了时间戳</p><h3 id="Step-1-定义事件——被观察者"><a href="#Step-1-定义事件——被观察者" class="headerlink" title="Step 1 : 定义事件——被观察者"></a>Step 1 : 定义事件——被观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerEvent</span><span class="params">(Object source, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-定义监听器——观察者"><a href="#Step-2-定义监听器——观察者" class="headerlink" title="Step 2 : 定义监听器——观察者"></a>Step 2 : 定义监听器——观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomerEvent</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomerEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CustomerListener listening： CustomerEvent has been triggered, event name is "</span> + event.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-多了一步事件发布"><a href="#Step-3-多了一步事件发布" class="headerlink" title="Step 3 : 多了一步事件发布"></a>Step 3 : 多了一步事件发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CustomerEvent customerEvent = <span class="keyword">new</span> CustomerEvent(<span class="keyword">this</span>,<span class="string">"click"</span>);</span><br><span class="line">        publisher.publishEvent(customerEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDocApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(SpringBootDocApplication.class, args)</span><br><span class="line">                .getBean(CustomEventPublisher.class).publish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomerListener listening： CustomerEvent has been triggered, event name is click</span><br></pre></td></tr></table></figure><h3 id="如果再加入一个监听者呢？是否能通知到"><a href="#如果再加入一个监听者呢？是否能通知到" class="headerlink" title="如果再加入一个监听者呢？是否能通知到"></a>如果再加入一个监听者呢？是否能通知到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtraListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomerEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomerEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ExtraListener listening： CustomerEvent has been triggered, event name is "</span> + event.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CustomerListener listening： CustomerEvent has been triggered, event name is click</span><br><span class="line">ExtraListener listening： CustomerEvent has been triggered, event name is click</span><br></pre></td></tr></table></figure><hr><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftndnytxtsj30wa03maat.jpg" width="65%" align="left"></p><p>这里和观察者模式的遍历一样，调用所有的监听器<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftndouogerj312e0b2gok.jpg" width="65%" align="left"></p><p>进入getApplicationListeners方法，可以看到如何查找注册在event上的Listener<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftndn5aqzej30us0ion18.jpg" width="65%" align="left"></p><p>根据@Order注解对Listener排序，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareOrderComparator.sort(allListeners);</span><br></pre></td></tr></table></figure></p><p>对两个Listener加入@Order注解，果然值较小的ExtraListener先执行</p><p>注：@Order Lower values have higher priority</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><pre><code>对自己的猜想要多验证</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2" target="_blank" rel="noopener">https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2</a><br><a href="http://wiki.jikexueyuan.com/project/spring/custom-events-in-spring.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/spring/custom-events-in-spring.html</a><br><a href="https://blog.csdn.net/tuzongxun/article/details/53637159" target="_blank" rel="noopener">https://blog.csdn.net/tuzongxun/article/details/53637159</a><br><a href="https://blog.csdn.net/zhangningzql/article/details/52515890" target="_blank" rel="noopener">https://blog.csdn.net/zhangningzql/article/details/52515890</a></p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring 扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring InitializingBean接口</title>
      <link href="/2018/07/25/Spring-InitializingBean%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/07/25/Spring-InitializingBean%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h2 id="源文档"><a href="#源文档" class="headerlink" title="源文档"></a>源文档</h2><p>InitializingBean接口的doc文档解释如下，大意为：</p><p>实现这个接口的bean，可以在BeanFactory设置完所有的属性之后生效，例如，执行自定义的bean初始化，或者只是为了检查所有的属性被设置了</p><p>另一个选择是指定<code>init-method</code>，例如在XML中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface to be implemented by beans that need to react once all their</span><br><span class="line"> * properties have been set by a BeanFactory: for example, to perform custom</span><br><span class="line"> * initialization, or merely to check that all mandatory properties have been set.</span><br><span class="line"> *</span><br><span class="line"> * An alternative to implementing InitializingBean is specifying a custom</span><br><span class="line"> * init-method, for example in an XML bean definition.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>从接口描述上可以看出和指定<em>init-method</em>的作用应该是类似的,测试代码如下</p><h3 id="Step-1：实现InitializingBean接口"><a href="#Step-1：实现InitializingBean接口" class="headerlink" title="Step 1：实现InitializingBean接口"></a>Step 1：实现InitializingBean接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanExtend</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after properties set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bean inited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-使用java-config定义bean，指定init-method"><a href="#Step-2-使用java-config定义bean，指定init-method" class="headerlink" title="Step 2: 使用java config定义bean，指定init-method"></a>Step 2: 使用java config定义bean，指定init-method</h3><p>为了方便指定init-method,使用java config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InitBeanExtend <span class="title">initBeanExtend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InitBeanExtend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-编写测试用例"><a href="#Step-3-编写测试用例" class="headerlink" title="Step 3: 编写测试用例"></a>Step 3: 编写测试用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDocApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">InitBeanExtend initBeanExtend;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InitBeanExtend bean = InitBeanExtend.class.cast(initBeanExtend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">after properties <span class="built_in">set</span></span><br><span class="line">bean inited</span><br></pre></td></tr></table></figure><p>结果表明init-method是在afterPropertiesSet方法执行之后调用的</p><hr><p>查看<code>AbstractAutowireCapableBeanFactory</code>类源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeCustomInitMethod</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">...</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">final</span> Method initMethod = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">BeanUtils.findMethod(bean.getClass(), initMethodName) :</span><br><span class="line">ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者除了先后顺序的明显区别之外，可以看出init-method是通过反射达到目的的，而InitializingBean接口具有代码侵入性，有对Spring的依赖</p><p>注意: init-method方法不能有参数，否则将抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.BeanDefinitionValidationException: Couldn&apos;t find an init method named &apos;init&apos; on bean with name &apos;initBeanExtend&apos;</span><br></pre></td></tr></table></figure><p>在IDEA下会有编译警告<br><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftn30ruqgzj30lc03waas.jpg" width="65%" align="left"></p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>看过Spring源码的读者经常可以看到这个接口的使用，比如在bean初始化完属性之后，进行参数检查</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="DisposableBean接口"><a href="#DisposableBean接口" class="headerlink" title="DisposableBean接口"></a><code>DisposableBean</code>接口</h3><p>与初始化相对应的还有销毁，在Spring中提供DisposableBean接口，可用来优雅的退出Spring Boot程序，对前面的代码添加实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanExtend</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after properties set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bean inited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gracefully close applicationContext"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Java-EE5规范-PostConstruct和-PreDestroy"><a href="#Java-EE5规范-PostConstruct和-PreDestroy" class="headerlink" title="Java EE5规范@PostConstruct和@PreDestroy"></a>Java EE5规范<code>@PostConstruct</code>和<code>@PreDestroy</code></h3><p>Java EE5规范提出的两个影响Servlet声明周期的方法，添加在非静态方法上，分别会在Servlet实例初始化之后和被销毁之前执行一次</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring 扩展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot 官方文档阅读</title>
      <link href="/2018/07/24/Spring%20Boot%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/24/Spring%20Boot%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Spring Boot 版本 2.0.3.RELEASE</p><p>文档地址：<a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/</a></p><h2 id="遇到的英文单词"><a href="#遇到的英文单词" class="headerlink" title="遇到的英文单词"></a>遇到的英文单词</h2><ul><li>typical: 典型的</li><li>transitively: 可传递地</li><li>Several of : 几个</li><li>dives into : 深入</li><li>bootstrap : 引导</li><li>delegate : 委托</li><li>approach : 方法</li><li>perform : 执行</li><li>detect : 察觉，侦测，发现</li></ul><h2 id="Spring-CLI的使用"><a href="#Spring-CLI的使用" class="headerlink" title="Spring CLI的使用"></a>Spring CLI的使用</h2><p>step 1： sdkman安装spring-boot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install springboot</span><br></pre></td></tr></table></figure><p>step 2：运行groovy脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring run app.groovy</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisWillActuallyRun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从低版本的Spring-Boot升级到2-0"><a href="#从低版本的Spring-Boot升级到2-0" class="headerlink" title="从低版本的Spring Boot升级到2.0"></a>从低版本的Spring Boot升级到2.0</h2><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行一次后移除该依赖</p><h2 id="使用maven命令启动Spring-Boot"><a href="#使用maven命令启动Spring-Boot" class="headerlink" title="使用maven命令启动Spring Boot"></a>使用maven命令启动Spring Boot</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure><p>相应的gradle有:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle bootRun</span><br></pre></td></tr></table></figure></p><p>可以export系统变量(<strong>没有测试</strong>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_OPTS=-Xmx1024m</span><br></pre></td></tr></table></figure><h2 id="社区提供的Spring-Boot-starter"><a href="#社区提供的Spring-Boot-starter" class="headerlink" title="社区提供的Spring Boot starter"></a>社区提供的Spring Boot starter</h2><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters" target="_blank" rel="noopener">starters列表</a></p><h2 id="如何排除不想生效的Bean"><a href="#如何排除不想生效的Bean" class="headerlink" title="如何排除不想生效的Bean"></a>如何排除不想生效的Bean</h2><p>方式一：使用exclude属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration.class)</span><br></pre></td></tr></table></figure></p><p>方式二：如果classpath下没有这个类，使用类全名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(excludeName = <span class="string">"org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration"</span>)</span><br></pre></td></tr></table></figure></p><p>方式三：如果有多个，可以使用spring.autoconfigure.exclude属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.autoconfigure.exclude=DataSourceAutoConfiguration.class</span><br></pre></td></tr></table></figure></p><p>你可以同时在注解和属性上使用exclude</p><p>You can define exclusions both at the annotation level and by using the property.</p><h2 id="构造器注入可以省略-Autowired"><a href="#构造器注入可以省略-Autowired" class="headerlink" title="构造器注入可以省略@Autowired"></a>构造器注入可以省略@Autowired</h2><p><strong>If a bean has one constructor, you can omit the @Autowired</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Remote-Debug时的启动参数"><a href="#使用Remote-Debug时的启动参数" class="headerlink" title="使用Remote Debug时的启动参数"></a>使用Remote Debug时的启动参数</h2><p>仅供参考，自己还没有试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,<span class="built_in">suspend</span>=n </span><br><span class="line">-jar target/myapplication-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h2 id="IDEA中使用devtools的正确姿势"><a href="#IDEA中使用devtools的正确姿势" class="headerlink" title="IDEA中使用devtools的正确姿势"></a>IDEA中使用devtools的正确姿势</h2><p>修改代码后，需要点击: <strong>Build-&gt;Build Project</strong></p><h2 id="编程式的属性设置"><a href="#编程式的属性设置" class="headerlink" title="编程式的属性设置"></a>编程式的属性设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.setProperty(<span class="string">"spring.devtools.restart.enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line">SpringApplication.run(MyApp.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot提供的几个很有用的事件"><a href="#Spring-Boot提供的几个很有用的事件" class="headerlink" title="Spring Boot提供的几个很有用的事件"></a>Spring Boot提供的几个很有用的事件</h2><p>针对Spring boot提供的事件，编写自己的Listener,详见<strong><a href="https://greedypirate.github.io/2018/07/26/Spring-ContextRefreshedEvent%E4%BA%8B%E4%BB%B6/">Spring-ContextRefreshedEvent事件</a></strong></p><ol><li>ApplicationStartingEvent：在开始运行时，监听器注册和初始化之后被触发</li><li>ApplicationEnvironmentPreparedEvent：发现 Environment 被上下文使用时，上下文被创建之前触发</li><li>ApplicationPreparedEvent：在启动刷新之前，bean定义被加载之后被触发</li><li>ApplicationStartedEvent：上下文刷新之前，应用和命令行启动器运行之前触发</li><li>ApplicationReadyEvent：在所有应用和命令行启动器调用之后，这表明应用已经准备好处理请求<br> 6.ApplicationFailedEvent：启动时出现异常触发</li></ol><h2 id="配置文件的名称和位置"><a href="#配置文件的名称和位置" class="headerlink" title="配置文件的名称和位置"></a>配置文件的名称和位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.config.name</span><br><span class="line">spring.config.location</span><br></pre></td></tr></table></figure><p><strong>注</strong>：这是两个需要很早初始化的属性，只能写在环境变量里(OS environment variable, a system property, or a command-line argument)</p><h2 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h2><ul><li>通过注入ApplicationArguments</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootstrapArgs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BootstrapArgs</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> myargs = args.containsOption(<span class="string">"myargs"</span>);</span><br><span class="line">        Assert.state(myargs, <span class="string">"无法获取自定义参数"</span>);</span><br><span class="line">        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();</span><br><span class="line">        System.out.println(<span class="string">"nonOptionArgs : "</span> + StringUtils.collectionToCommaDelimitedString(nonOptionArgs));</span><br><span class="line">        Set&lt;String&gt; optionNames = args.getOptionNames();</span><br><span class="line">        <span class="keyword">for</span> (String optionName : optionNames) &#123;</span><br><span class="line">            List&lt;String&gt; optionValues = args.getOptionValues(optionName);</span><br><span class="line">            System.out.println(optionValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现CommandLineRunner或ApplicationRunner接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnerBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志按环境生效"><a href="#日志按环境生效" class="headerlink" title="日志按环境生效"></a>日志按环境生效</h2><p>以下配置文件展示了多个环境，特定环境，非某个环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"test,dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.example.demo.controller"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产环境. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 非生产环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!production"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="日志使用Spring环境变量"><a href="#日志使用Spring环境变量" class="headerlink" title="日志使用Spring环境变量"></a>日志使用Spring环境变量</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"fluentHost"</span> <span class="attr">source</span>=<span class="string">"myapp.fluentd.host"</span></span></span><br><span class="line"><span class="tag"><span class="attr">defaultValue</span>=<span class="string">"localhost"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FLUENT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.more.appenders.DataFluentAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目首页查找规则"><a href="#项目首页查找规则" class="headerlink" title="项目首页查找规则"></a>项目首页查找规则</h2><p>支持html和模板引擎作为首页，首先会查找index.html，然后查找index template，还是没有时，会默认用一个欢迎页</p><h2 id="WebBindingInitializer"><a href="#WebBindingInitializer" class="headerlink" title="WebBindingInitializer"></a>WebBindingInitializer</h2><p>用于配置全局的类型转换器, 局部的可以在Controller中使用@InitBinder标记在方法上(<strong>百度所得</strong>)</p><h2 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h2><ol><li style="list-style: none"><input type="checkbox" checked> 搭建jenkins，配合git自动构建发布Spring Boot项目</li><li>研究编排系统Docker，K8s</li><li>研究项目里的Spring扩展</li><li>总结分布式链路追踪</li><li>mybatis官方文档, 源码, mybatis-plus, 通用mapper，代码生成</li><li>spring boot多数据源，分库分表，sharding-jdbc</li></ol>]]></content>
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 官方文档阅读 </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
